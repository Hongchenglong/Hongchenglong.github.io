<!DOCTYPE html>





<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: false,
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>


  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "d7dbba2c"
    });
  daovoice('update');
  </script>

  <meta name="description" content="Java快速入门Java简介 JDK：Java Development Kit JRE：Java Runtime Environment  简单地说，JRE就是运行Java字节码的虚拟机。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具。   二者关系如下： 1234567891011 ┌─    ┌─────────">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java_notes">
<meta property="og:url" content="http://yoursite.com/2021/01/23/Java/Java-notes/index.html">
<meta property="og:site_name" content="匡山读书处">
<meta property="og:description" content="Java快速入门Java简介 JDK：Java Development Kit JRE：Java Runtime Environment  简单地说，JRE就是运行Java字节码的虚拟机。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具。   二者关系如下： 1234567891011 ┌─    ┌─────────">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2021-01-27T03:09:46.298Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java_notes">
<meta name="twitter:description" content="Java快速入门Java简介 JDK：Java Development Kit JRE：Java Runtime Environment  简单地说，JRE就是运行Java字节码的虚拟机。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具。   二者关系如下： 1234567891011 ┌─    ┌─────────">
  <link rel="canonical" href="http://yoursite.com/2021/01/23/Java/Java-notes/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Java_notes | 匡山读书处</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-left">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">匡山读书处</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">世即用我，而我奚以为用</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/23/Java/Java-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hongchenglong">
      <meta itemprop="description" content="相信过程">
      <meta itemprop="image" content="https://images.cnblogs.com/cnblogs_com/oeong/1593757/o_191209052450kongaj.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="匡山读书处">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">Java_notes

            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2021-01-23 11:06:35" itemprop="dateCreated datePublished" datetime="2021-01-23T11:06:35+08:00">2021-01-23</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-27 11:09:46" itemprop="dateModified" datetime="2021-01-27T11:09:46+08:00">2021-01-27</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <a id="more"></a>

<h1 id="Java快速入门"><a href="#Java快速入门" class="headerlink" title="Java快速入门"></a>Java快速入门</h1><h2 id="Java简介"><a href="#Java简介" class="headerlink" title="Java简介"></a>Java简介</h2><ul>
<li>JDK：Java Development Kit</li>
<li>JRE：Java Runtime Environment</li>
</ul>
<p>简单地说，JRE就是运行Java字节码的<strong>虚拟机</strong>。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了<strong>包含</strong>JRE，还提供了编译器、调试器等开发工具。</p>
<p>  二者关系如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> ┌─    ┌──────────────────────────────────┐</span><br><span class="line"> │     │     Compiler, debugger, etc.     │</span><br><span class="line"> │     └──────────────────────────────────┘</span><br><span class="line">JDK ┌─ ┌──────────────────────────────────┐</span><br><span class="line"> │  │  │                                  │</span><br><span class="line"> │ JRE │      JVM + Runtime Library       │</span><br><span class="line"> │  │  │                                  │</span><br><span class="line"> └─ └─ └──────────────────────────────────┘</span><br><span class="line">       ┌───────┐┌───────┐┌───────┐┌───────┐</span><br><span class="line">       │Windows││ Linux ││ macOS ││others │</span><br><span class="line">       └───────┘└───────┘└───────┘└───────┘</span><br></pre></td></tr></table></figure>

<h2 id="Java程序基础"><a href="#Java程序基础" class="headerlink" title="Java程序基础"></a>Java程序基础</h2><p><code>int[] ns = new int[5];</code></p>
<p>对象、数组都是引用数据类型。</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h4 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h4><p><code>==</code>表示“引用的<strong>对象</strong>是否相等”，浮点数判断相等不能直接用</p>
<p>使用<code>equals()</code>判断引用类型<strong>内容</strong>相等，注意避免<code>NullPointerException</code>。</p>
<h4 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for each循环"></a>for each循环</h4><p><code>for each</code>循环可以直接遍历数组的每个元素；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[] ns = &#123; 1, 4, 9, 16, 25 &#125;;</span><br><span class="line">for (int n : ns) &#123;</span><br><span class="line">	System.out.println(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><p>遍历数组可以使用<code>for</code>循环，<code>for</code>循环可以访问数组索引，<code>for each</code>循环直接迭代每个数组元素，但无法获取索引；</p>
<p>使用<code>Arrays.toString()</code>可以快速获取数组内容。</p>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>排序前</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                   ┌──────────────────────────────────┐</span><br><span class="line">               ┌───┼──────────────────────┐           │</span><br><span class="line">               │   │                      ▼           ▼</span><br><span class="line">         ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐</span><br><span class="line">ns ─────&gt;│░░░│░░░│░░░│   │&quot;banana&quot;│   │&quot;apple&quot;│   │&quot;pear&quot;│   │</span><br><span class="line">         └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘</span><br><span class="line">           │                 ▲</span><br><span class="line">           └─────────────────┘</span><br></pre></td></tr></table></figure>

<p>排序后，原来的3个字符串在<strong>内存</strong>中均没有任何变化，但是<code>ns</code>数组的每个元素<strong>指向</strong>变化了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                   ┌──────────────────────────────────┐</span><br><span class="line">               ┌───┼──────────┐                       │</span><br><span class="line">               │   │          ▼                       ▼</span><br><span class="line">         ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐</span><br><span class="line">ns ─────&gt;│░░░│░░░│░░░│   │&quot;banana&quot;│   │&quot;apple&quot;│   │&quot;pear&quot;│   │</span><br><span class="line">         └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘</span><br><span class="line">           │                              ▲</span><br><span class="line">           └──────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>Java是一种面向对象的编程语言。面向对象编程，英文是Object-Oriented Programming，简称OOP。</p>
<h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><p>在OOP中，<code>class</code>和<code>instance</code>是“模版”和“实例”的关系；</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>在方法内部，可以使用一个隐含的变量<code>this</code>，它始终指向当前实例。因此，通过<code>this.field</code>就可以访问当前实例的字段。</p>
<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>方法重载是指多个方法的方法名相同，但各自的参数不同；</p>
<p>重载方法返回值类型应该相同。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="区分继承和组合"><a href="#区分继承和组合" class="headerlink" title="区分继承和组合"></a>区分继承和组合</h4><p><code>Student</code>和<code>Book</code>的关系是has关系。</p>
<ul>
<li>继承是面向对象编程的一种强大的代码复用方式；</li>
<li>Java只允许单继承，所有类最终的根类是<code>Object</code>；</li>
<li><code>protected</code>允许子类访问父类的字段和方法；</li>
<li>子类的构造方法可以通过<code>super()</code>调用父类的构造方法；</li>
<li>可以<strong>安全地向上转型</strong>为更抽象的类型；</li>
<li>可以强制向下转型，最好借助<code>instanceof</code>判断；</li>
<li>子类和父类的关系是is，has关系不能用继承。</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。</p>
<ul>
<li>子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为；</li>
<li>Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；</li>
<li><code>final</code>修饰符有多种作用：<ul>
<li><code>final</code>修饰的方法可以阻止被覆写；</li>
<li><code>final</code>修饰的class可以阻止被继承；</li>
<li><code>final</code>修饰的field必须在创建对象时初始化，随后不可修改。</li>
</ul>
</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>通过<code>abstract</code>定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范；</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>所谓<code>interface</code>，就是比抽象类还要抽象的纯抽象接口，因为<strong>不能定义实例字段</strong>。</p>
<p><code>interface</code>的字段只能是<code>public static final</code>类型</p>
<h3 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h3><p>所有实例共享一个静态字段。</p>
<p>不推荐用<code>实例变量.静态字段</code>去访问静态字段，推荐<strong>用类名来访问静态字段</strong>。</p>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>Java内建的<code>package</code>机制是为了避免<code>class</code>命名冲突；</p>
<p>JDK的核心类使用<code>java.lang</code>包，编译器会自动导入；</p>
<p>JDK的其它常用类定义在<code>java.util.*</code>，<code>java.math.*</code>，<code>java.text.*</code>，……；</p>
<p>包名推荐使用<strong>倒置的域名</strong>，避免冲突，例如<code>org.apache</code>。</p>
<p>包没有父子关系，<code>com.apache</code>和<code>com.apache.abc</code>是不同的包。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>定义在一个<code>class</code>内部的<code>class</code>称为嵌套类（<code>nested class</code>）</p>
<p>如果不确定是否需要<code>public</code>，就不声明为<code>public</code>，即尽可能少地暴露对外的字段和方法。</p>
<p>把方法定义为<code>package</code>权限有助于测试，因为测试类和被测试类只要位于同一个<code>package</code>，测试代码就可以访问被测试类的<code>package</code>权限方法。</p>
<p>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。如果有<code>public</code>类，文件名必须和<code>public</code>类的名字相同。</p>
<p><code>protected</code>作用于继承关系。定义为<code>protected</code>的字段和方法可以被子类访问，以及子类的子类</p>
<h3 id="classpath和jar"><a href="#classpath和jar" class="headerlink" title="classpath和jar"></a>classpath和jar</h3><p><code>classpath</code>是JVM用到的一个环境变量，它用来指示JVM如何搜索<code>class</code>。</p>
<p>因为Java是编译型语言，源码文件是<code>.java</code>，而编译后的<code>.class</code>文件才是真正可以被JVM执行的字节码。</p>
<p>jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。</p>
<blockquote>
<p> 如何创建jar包？</p>
</blockquote>
<p>因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从<code>.zip</code>改为<code>.jar</code>，一个jar包就创建成功。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>JVM通过环境变量<code>classpath</code>决定搜索<code>class</code>的路径和顺序；</p>
<p>不推荐设置系统环境变量<code>classpath</code>，始终建议通过<code>-cp</code>命令传入；</p>
<p>jar包相当于目录，可以包含很多<code>.class</code>文件，方便下载和使用；</p>
<p><code>MANIFEST.MF</code>文件可以提供jar包的信息，如<code>Main-Class</code>，这样可以直接运行jar包。</p>
<h2 id="Java核心类"><a href="#Java核心类" class="headerlink" title="Java核心类"></a>Java核心类</h2><h3 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h3><ul>
<li>Java字符串<code>String</code>是不可变对象；</li>
<li>字符串操作不改变原字符串内容，而是返回新字符串；</li>
<li>常用的字符串操作：提取子串、查找、替换、大小写转换等；</li>
<li>Java使用Unicode编码表示<code>String</code>和<code>char</code>；</li>
<li>转换编码就是将<code>String</code>和<code>byte[]</code>转换，需要指定编码；</li>
<li>转换为<code>byte[]</code>时，始终优先考虑<code>UTF-8</code>编码。</li>
</ul>
<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>为了能高效拼接字符串，Java标准库提供了<code>StringBuilder</code>，它是一个可变对象，可以预分配<strong>缓冲区</strong>，这样，往<code>StringBuilder</code>中新增字符时，<strong>不会创建新的临时对象</strong>；</p>
<p><code>StringBuilder</code>可以支持<strong>链式操作</strong>，实现链式操作的关键是返回实例本身；</p>
<h3 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h3><p>用指定分隔符拼接字符串数组时，使用<code>StringJoiner</code>或者<code>String.join()</code>更方便；</p>
<p>用<code>StringJoiner</code>拼接字符串时，还可以额外附加一个“开头”和“结尾”。</p>
<h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>Java核心库提供的包装类型可以把基本类型包装为<code>class</code>；</p>
<p>自动装箱和自动拆箱都是在编译期完成的（JDK&gt;=1.5）；</p>
<p>装箱和拆箱会影响执行效率，且拆箱时可能发生<code>NullPointerException</code>；</p>
<p>包装类型的比较必须使用<code>equals()</code>；</p>
<p>整数和浮点数的包装类型都继承自<code>Number</code>；</p>
<p>包装类型提供了大量实用方法。</p>
<h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><p>JavaBean是一种符合命名规范的<code>class</code>，它通过<code>getter</code>和<code>setter</code>来定义属性；</p>
<p>JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输；</p>
<p>可以利用IDE快速生成<code>getter</code>和<code>setter</code>；</p>
<p>属性是一种通用的叫法，并非Java语法规定；</p>
<p>使用<code>Introspector.getBeanInfo()</code>可以获取属性列表。</p>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>Java使用<code>enum</code>定义枚举类型，它被编译器编译为<code>final class Xxx extends Enum { … }</code>；</p>
<p>通过<code>name()</code>获取常量定义的字符串，注意不要使用<code>toString()</code>；</p>
<p>通过<code>ordinal()</code>返回常量定义的顺序（无实质意义）；</p>
<p>可以为<code>enum</code>编写构造方法、字段和方法</p>
<p><code>enum</code>的构造方法要声明为<code>private</code>，字段强烈建议声明为<code>final</code>；</p>
<p><code>enum</code>适合用在<code>switch</code>语句中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Weekday &#123;</span><br><span class="line">    MON(<span class="number">1</span>), TUE(<span class="number">2</span>), WED(<span class="number">3</span>), THU(<span class="number">4</span>), FRI(<span class="number">5</span>), SAT(<span class="number">6</span>), SUN(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="纪录类"><a href="#纪录类" class="headerlink" title="纪录类"></a>纪录类</h3><p>使用<code>String</code>、<code>Integer</code>等类型的时候，这些类型都是<strong>不变类</strong>，一个不变类具有以下特点：</p>
<ol>
<li>定义class时使用<code>final</code>，无法派生子类；</li>
<li>每个字段使用<code>final</code>，保证创建实例后无法修改任何字段。</li>
</ol>
<p><code>public record Point(int x, int y) {}</code></p>
<p>从Java 14开始，提供新的<code>record</code>关键字，可以非常方便地定义Data Class：</p>
<ul>
<li>使用<code>record</code>定义的是不变类；</li>
<li>可以编写Compact Constructor对参数进行验证；</li>
<li>可以定义静态方法。</li>
</ul>
<h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h3><p><code>BigInteger</code>用于表示任意大小的整数；</p>
<p><code>BigInteger</code>是不变类，并且继承自<code>Number</code>；</p>
<p>将<code>BigInteger</code>转换成基本类型时可使用<code>longValueExact()</code>等方法保证结果准确。</p>
<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>如果查看<code>BigDecimal</code>的源码，可以发现，实际上一个<code>BigDecimal</code>是通过一个<code>BigInteger</code>和一个<code>scale</code>来表示的，即<code>BigInteger</code>表示一个完整的整数，而<code>scale</code>表示小数位数；</p>
<p><code>BigDecimal</code>用于表示精确的小数，常用于财务计算；</p>
<p>比较<code>BigDecimal</code>的值是否相等，必须使用<code>compareTo()</code>而不能使用<code>equals()</code></p>
<h3 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h3><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><p>数学计算</p>
<h4 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h4><p>创建<code>Random</code>实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的<strong>伪随机数</strong>序列就不同。</p>
<h4 id="SecureRandom"><a href="#SecureRandom" class="headerlink" title="SecureRandom"></a>SecureRandom</h4><p>安全的随机数，真随机数。种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。</p>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="Java的异常"><a href="#Java的异常" class="headerlink" title="Java的异常"></a>Java的异常</h2><p>Java使用异常来表示错误，并通过<code>try ... catch</code>捕获异常；</p>
<p>Java的异常是<code>class</code>，并且从<code>Throwable</code>继承；</p>
<p><code>Error</code>是无需捕获的严重错误，<code>Exception</code>是应该捕获的可处理的错误；</p>
<p><code>RuntimeException</code>无需强制捕获，非<code>RuntimeException</code>（Checked Exception）需强制捕获，或者用<code>throws</code>声明；</p>
<p>如果不想写任何<code>try</code>代码，可以直接把<code>main()</code>方法定义为<code>throws Exception</code>。也就声明了可能抛出所有的<code>Exception</code>，因此在内部就无需捕获了。代价就是一旦发生异常，程序会立刻退出。</p>
<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>使用<code>try ... catch ... finally</code>时：</p>
<ul>
<li>多个<code>catch</code>语句的匹配顺序非常重要，子类必须放在前面；</li>
<li><code>finally</code>语句保证了有无异常都会执行，它是可选的；</li>
<li>一个<code>catch</code>语句也可以匹配多个非继承关系的异常。</li>
</ul>
<h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>调用<code>printStackTrace()</code>可以打印异常的传播栈，对于调试非常有用；</p>
<p>捕获异常并再次抛出新的异常时，应该持有原始异常信息；</p>
<p>通常不要在<code>finally</code>中抛出异常。如果在<code>finally</code>中抛出异常，应该原始异常加入到原有异常中。调用方可通过<code>Throwable.getSuppressed()</code>获取所有添加的<code>Suppressed Exception</code>。</p>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>抛出异常时，尽量复用JDK已定义的异常类型；</p>
<p>自定义异常体系时，推荐从<code>RuntimeException</code>派生“根异常”，再派生出业务异常；</p>
<p>自定义异常时，应该提供多种构造方法。</p>
<h2 id="NullPointerException"><a href="#NullPointerException" class="headerlink" title="NullPointerException"></a>NullPointerException</h2><p>空指针异常</p>
<p>编写业务逻辑时，用空字符串<code>&quot;&quot;</code>表示未填写比<code>null</code>安全得多。</p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>断言（Assertion）是一种调试程序的方式。在Java中，使用<code>assert</code>关键字来实现断言。</p>
<h2 id="JDK-Logging"><a href="#JDK-Logging" class="headerlink" title="JDK Logging"></a>JDK Logging</h2><p>日志是为了替代<code>System.out.println()</code>，可以定义格式，重定向到文件等；</p>
<p>日志可以存档，便于追踪问题；</p>
<p>日志记录可以按级别分类，便于打开或关闭某些级别；</p>
<p>可以根据配置文件调整日志，无需修改代码；</p>
<p>Java标准库提供了<code>java.util.logging</code>来实现日志功能。</p>
<h2 id="Commons-Logging"><a href="#Commons-Logging" class="headerlink" title="Commons Logging"></a>Commons Logging</h2><p>和Java标准库提供的日志不同，Commons Logging是一个第三方日志库，它是由Apache创建的日志模块。</p>
<p>Commons Logging是使用最广泛的日志模块；</p>
<p>Commons Logging的API非常简单；</p>
<p>Commons Logging可以自动检测并使用其他日志模块。</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>Java的集合类定义在<code>java.util</code>包中，支持泛型，主要提供了3种集合类，包括<code>List</code>，<code>Set</code>和<code>Map</code>。Java集合使用统一的<code>Iterator</code>遍历，尽量不要使用遗留接口。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><code>List</code>的行为和数组几乎完全相同。 List是一个接口，而ArrayList是List接口的一个实现类。 </p>
<p><code>List</code>是按索引顺序访问的长度可变的有序表，优先使用<code>ArrayList</code>而不是<code>LinkedList</code>；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list = List.of(<span class="string">"apple"</span>, <span class="string">"pear"</span>, <span class="string">"banana"</span>);</span><br></pre></td></tr></table></figure>

<p>通过<code>Iterator</code>遍历<code>List</code>永远是最高效的方式。并且，由于<code>Iterator</code>遍历是如此常用，所以，Java的<code>for each</code>循环本身就可以帮我们使用<code>Iterator</code>遍历。</p>
<p><code>List</code>可以和<code>Array</code>相互转换。</p>
<p>List和Array的区别是什么？</p>
<ol>
<li>数组是定长，list是自动增长。</li>
<li>数组效率高，list效率低。</li>
</ol>
<h2 id="编写equals方法"><a href="#编写equals方法" class="headerlink" title="编写equals方法"></a>编写equals方法</h2><p><code>List</code>还提供了<code>boolean contains(Object o)</code>方法来判断<code>List</code>是否包含某个指定元素。此外，<code>int indexOf(Object o)</code>方法可以返回某个元素的索引，如果元素不存在，就返回<code>-1</code>。</p>
<p>对于引用字段比较，我们使用<code>equals()</code>，对于基本类型字段的比较，我们使用<code>==</code>。</p>
<p>总结一下<code>equals()</code>方法的正确编写方法：</p>
<ol>
<li>先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；</li>
<li>用<code>instanceof</code>判断传入的待比较的<code>Object</code>是不是当前类型，如果是，继续比较，否则，返回<code>false</code>；</li>
<li>对引用类型用<code>Objects.equals()</code>比较，对基本类型直接用<code>==</code>比较。</li>
</ol>
<p>如果不调用<code>List</code>的<code>contains()</code>、<code>indexOf()</code>这些方法，就不必覆写<code>equals()</code>方法。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><code>Map</code>是一种映射表，可以通过<code>key</code>快速查找<code>value</code>。无序。</p>
<p>可以通过<code>for each</code>遍历<code>keySet()</code>，也可以通过<code>for each</code>遍历<code>entrySet()</code>，直接获取<code>key-value</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String key : map.keySet())</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet())</span><br></pre></td></tr></table></figure>

<p>最常用的一种<code>Map</code>实现是<code>HashMap</code>。</p>
<h2 id="编写equals和hashCode"><a href="#编写equals和hashCode" class="headerlink" title="编写equals和hashCode"></a>编写equals和hashCode</h2><p><code>HashMap</code>之所以能根据<code>key</code>直接拿到<code>value</code>，原因是它内部通过空间换时间的方法，用一个大数组存储所有<code>value</code>，并根据key直接计算出<code>value</code>应该存储在哪个索引</p>
<p>要正确使用<code>HashMap</code>，作为<code>key</code>的类必须正确覆写<code>equals()</code>和<code>hashCode()</code>方法；</p>
<p>一个类如果覆写了<code>equals()</code>，就必须覆写<code>hashCode()</code>，并且覆写规则是：</p>
<ul>
<li>如果<code>equals()</code>返回<code>true</code>，则<code>hashCode()</code>返回值必须相等；</li>
<li>如果<code>equals()</code>返回<code>false</code>，则<code>hashCode()</code>返回值尽量不要相等。</li>
</ul>
<p>实现<code>hashCode()</code>方法可以通过<code>Objects.hashCode()</code>辅助方法实现。</p>
<h2 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h2><p>如果<code>Map</code>的key是<code>enum</code>类型，推荐使用<code>EnumMap</code>，既保证速度，也不浪费空间。</p>
<p>使用<code>EnumMap</code>的时候，根据面向抽象编程的原则，应持有<code>Map</code>接口。</p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">       ┌───┐</span><br><span class="line">       │Map│</span><br><span class="line">       └───┘</span><br><span class="line">         ▲</span><br><span class="line">    ┌────┴─────┐</span><br><span class="line">    │          │</span><br><span class="line">┌───────┐ ┌─────────┐</span><br><span class="line">│HashMap│ │SortedMap│</span><br><span class="line">└───────┘ └─────────┘</span><br><span class="line">               ▲</span><br><span class="line">               │</span><br><span class="line">          ┌─────────┐</span><br><span class="line">          │ TreeMap │</span><br><span class="line">          └─────────┘</span><br></pre></td></tr></table></figure>

<p><code>SortedMap</code>是接口，它的实现类是<code>TreeMap</code>。创建<code>TreeMap</code>时同时指定一个自定义排序算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Person, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.name.compareTo(p2.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>SortedMap</code>在遍历时严格按照Key的<strong>顺序</strong>遍历，最常用的实现类是<code>TreeMap</code>；</p>
<p>作为<code>SortedMap</code>的Key必须实现<code>Comparable</code>接口，或者传入<code>Comparator</code>；</p>
<p>要严格按照<code>compare()</code>规范实现比较逻辑，否则，<code>TreeMap</code>将不能正常工作。</p>
<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>Java集合库提供的<code>Properties</code>用于读写配置文件<code>.properties</code>。<code>.properties</code>文件可以使用UTF-8编码。</p>
<p>可以从文件系统、classpath或其他任何地方读取<code>.properties</code>文件。</p>
<p>读写<code>Properties</code>时，注意仅使用<code>getProperty()</code>和<code>setProperty()</code>方法，不要调用继承而来的<code>get()</code>和<code>put()</code>等方法。</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><code>Set</code>实际上相当于只存储key、不存储value的<code>Map</code>。</p>
<p><code>Set</code>用于存储不重复的元素集合：</p>
<ul>
<li>放入<code>HashSet</code>的元素与作为<code>HashMap</code>的key要求相同；</li>
<li>放入<code>TreeSet</code>的元素与作为<code>TreeMap</code>的Key要求相同；</li>
</ul>
<p>利用<code>Set</code>可以去除重复元素；</p>
<p>遍历<code>SortedSet</code>按照元素的排序顺序遍历，也可以自定义排序算法。</p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>队列<code>Queue</code>实现了一个先进先出（FIFO）的数据结构：</p>
<ul>
<li>通过<code>add()</code>/<code>offer()</code>方法将元素添加到队尾；</li>
<li>通过<code>remove()</code>/<code>poll()</code>从队首获取元素并删除；</li>
<li>通过<code>element()</code>/<code>peek()</code>从队首获取元素但不删除。</li>
</ul>
<p>要避免把<code>null</code>添加到队列，很难确定是取到了<code>null</code>元素还是队列为空。</p>
<h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p><code>PriorityQueue</code>实现了一个优先队列：从队首获取元素时，总是获取优先级最高的元素。</p>
<p><code>PriorityQueue</code>默认按元素比较的顺序排序（必须实现<code>Comparable</code>接口），也可以通过<code>Comparator</code>自定义排序算法（元素就不必实现<code>Comparable</code>接口）。</p>
<h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p><code>Deque</code>实现了一个双端队列（Double Ended Queue），它可以：</p>
<ul>
<li>将元素添加到队尾或队首：<code>addLast()</code>/<code>offerLast()</code>/<code>addFirst()</code>/<code>offerFirst()</code>；</li>
<li>从队首／队尾获取元素并删除：<code>removeFirst()</code>/<code>pollFirst()</code>/<code>removeLast()</code>/<code>pollLast()</code>；</li>
<li>从队首／队尾获取元素但不删除：<code>getFirst()</code>/<code>peekFirst()</code>/<code>getLast()</code>/<code>peekLast()</code>；</li>
<li>总是调用<code>xxxFirst()</code>/<code>xxxLast()</code>以便与<code>Queue</code>的方法区分开；</li>
<li>避免把<code>null</code>添加到队列。</li>
</ul>
<p><code>Deque</code>是一个接口，它的实现类有<code>ArrayDeque</code>和<code>LinkedList</code>。</p>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>栈（Stack）是一种后进先出（LIFO）的数据结构，操作栈的元素的方法有：</p>
<ul>
<li>把元素压栈：<code>push(E)</code>；</li>
<li>把栈顶的元素“弹出”：<code>pop(E)</code>；</li>
<li>取栈顶元素但不弹出：<code>peek(E)</code>。</li>
</ul>
<p>在Java中，我们用<code>Deque</code>可以实现<code>Stack</code>的功能，注意只调用<code>push()</code>/<code>pop()</code>/<code>peek()</code>方法，避免调用<code>Deque</code>的其他方法。</p>
<p>最后，不要使用遗留类<code>Stack</code>。</p>
<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>我们把这种通过<code>Iterator</code>对象遍历集合的模式称为迭代器。</p>
<p>使用迭代器的好处在于，调用方总是以统一的方式遍历各种集合类型，而不必关系它们内部的存储结构。</p>
<p><code>Iterator</code>是一种抽象的数据访问模型。使用<code>Iterator</code>模式进行迭代的好处有：</p>
<ul>
<li>对任何集合都采用<strong>同一种访问模型</strong>；</li>
<li>调用者对集合<strong>内部结构</strong>一无所知；</li>
<li>集合类返回的<code>Iterator</code>对象知道如何迭代。</li>
</ul>
<p>Java提供了标准的迭代器模型，即集合类实现<code>java.util.Iterable</code>接口，返回<code>java.util.Iterator</code>实例。</p>
<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p><code>Collections</code>类提供了一组工具方法来方便使用集合类：</p>
<ul>
<li>创建空集合；</li>
<li>创建单元素集合；</li>
<li>创建不可变集合；</li>
<li>排序／洗牌等操作。</li>
</ul>
<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><p>IO是指Input/Output，即输入和输出。以<strong>内存</strong>为中心：</p>
<ul>
<li>Input指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。</li>
<li>Output指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据从内存输出到网络等等。</li>
</ul>
<p>IO流是一种顺序读写数据的模式，它的特点是单向流动。数据类似自来水一样在水管中流动，所以我们把它称为IO流。</p>
<p>IO流以<code>byte</code>（字节）为最小单位，因此也称为<em>字节流</em>。</p>
<p>如果我们需要读写的是字符，并且字符不全是单字节表示的ASCII字符，那么，按照<code>char</code>来读写显然更方便，这种流称为<em>字符流</em>。</p>
<h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>同步IO是指，读写IO时代码必须等待数据返回后才继续执行后续代码，它的优点是代码编写简单，缺点是CPU执行效率低。</p>
<p>而异步IO是指，读写IO时仅发出请求，然后立刻执行后续代码，它的优点是CPU执行效率高，缺点是代码编写复杂。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>IO流是一种流式的数据输入/输出模型：</p>
<ul>
<li>二进制数据以<code>byte</code>为最小单位在<code>InputStream</code>/<code>OutputStream</code>中单向流动；</li>
<li>字符数据以<code>char</code>为最小单位在<code>Reader</code>/<code>Writer</code>中单向流动。</li>
</ul>
<p>Java标准库的<code>java.io</code>包提供了同步IO功能：</p>
<ul>
<li>字节流接口：<code>InputStream</code>/<code>OutputStream</code>；</li>
<li>字符流接口：<code>Reader</code>/<code>Writer</code>。</li>
</ul>
<h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><p>传入相对路径时，相对路径前面加上当前目录就是绝对路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设当前目录是C:\Docs</span></span><br><span class="line">File f1 = <span class="keyword">new</span> File(<span class="string">"sub\\javac"</span>); <span class="comment">// 绝对路径是C:\Docs\sub\javac</span></span><br></pre></td></tr></table></figure>

<p>Java标准库的<code>java.io.File</code>对象表示一个文件或者目录：</p>
<ul>
<li>创建<code>File</code>对象本身不涉及IO操作；</li>
<li>可以获取路径／绝对路径／规范路径：<code>getPath()</code>/<code>getAbsolutePath()</code>/<code>getCanonicalPath()</code>；</li>
<li>可以获取目录的文件和子目录：<code>list()</code>/<code>listFiles()</code>；</li>
<li>可以创建或删除文件和目录。</li>
</ul>
<h2 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h2><p>Java标准库的<code>java.io.InputStream</code>定义了所有输入流的超类：</p>
<ul>
<li><code>FileInputStream</code>实现了文件流输入；</li>
<li><code>ByteArrayInputStream</code>在内存中模拟一个字节流输入。</li>
</ul>
<p>总是使用<code>try(resource)</code>来保证<code>InputStream</code>正确关闭。</p>
<h2 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h2><p>为什么要有<code>flush()</code>？因为向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个<code>byte[]</code>数组），<strong>等到缓冲区写满了，再一次性写入文件或者网络。</strong></p>
<p>Java标准库的<code>java.io.OutputStream</code>定义了所有输出流的超类：</p>
<ul>
<li><code>FileOutputStream</code>实现了文件流输出；</li>
<li><code>ByteArrayOutputStream</code>在内存中模拟一个字节流输出。</li>
</ul>
<p>某些情况下需要手动调用<code>OutputStream</code>的<code>flush()</code>方法来强制输出缓冲区。</p>
<p>总是使用<code>try(resource)</code>来保证<code>OutputStream</code>正确关闭。</p>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>Java的IO标准库使用Filter模式为<code>InputStream</code>和<code>OutputStream</code>增加功能：</p>
<ul>
<li>可以把一个<code>InputStream</code>和任意个<code>FilterInputStream</code>组合；</li>
<li>可以把一个<code>OutputStream</code>和任意个<code>FilterOutputStream</code>组合。</li>
</ul>
<p>Filter模式可以在运行期动态增加功能（又称Decorator模式）。</p>
<h2 id="操作Zip"><a href="#操作Zip" class="headerlink" title="操作Zip"></a>操作Zip</h2><p><code>ZipInputStream</code>可以读取zip格式的流，<code>ZipOutputStream</code>可以把多份数据写入zip包；</p>
<p>配合<code>FileInputStream</code>和<code>FileOutputStream</code>就可以读写zip文件。</p>
<h2 id="读取classpath资源"><a href="#读取classpath资源" class="headerlink" title="读取classpath资源"></a>读取classpath资源</h2><p>把资源存储在classpath中可以避免文件路径依赖；</p>
<p><code>Class</code>对象的<code>getResourceAsStream()</code>可以从classpath中读取指定资源；</p>
<p>根据classpath读取资源时，需要检查返回的<code>InputStream</code>是否为<code>null</code>。</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>序列化是指把一个Java对象变成二进制内容，本质上就是一个<code>byte[]</code>数组。</p>
<p>为什么要把Java对象序列化呢？因为序列化后可以把<code>byte[]</code>保存到文件中，或者把<code>byte[]</code>通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。</p>
<p>可序列化的Java对象必须实现<code>java.io.Serializable</code>接口，类似<code>Serializable</code>这样的空接口被称为“标记接口”（Marker Interface）；</p>
<p>反序列化时不调用构造方法，可设置<code>serialVersionUID</code>作为版本号（非必需）；</p>
<p>Java的序列化机制仅适用于Java，如果需要与其它语言交换数据，必须使用通用的序列化方法，例如JSON。</p>
<h2 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h2><p><code>Reader</code>是Java的IO库提供的另一个输入流接口。和<code>InputStream</code>的区别是，<code>InputStream</code>是一个字节流，即以<code>byte</code>为单位读取，而<code>Reader</code>是一个字符流，即以<code>char</code>为单位读取。</p>
<p><code>Reader</code>定义了所有<strong>字符</strong>输入流的超类：</p>
<ul>
<li><code>FileReader</code>实现了文件字符流输入，使用时需要指定编码；</li>
<li><code>CharArrayReader</code>和<code>StringReader</code>可以在内存中模拟一个字符流输入。</li>
</ul>
<p><code>Reader</code>是基于<code>InputStream</code>构造的：可以通过<code>InputStreamReader</code>在指定编码的同时将任何<code>InputStream</code>转换为<code>Reader</code>。</p>
<p>总是使用<code>try (resource)</code>保证<code>Reader</code>正确关闭。</p>
<h2 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h2><p><code>Writer</code>定义了所有字符输出流的超类：</p>
<ul>
<li><code>FileWriter</code>实现了文件字符流输出；</li>
<li><code>CharArrayWriter</code>和<code>StringWriter</code>在内存中模拟一个字符流输出。</li>
</ul>
<p>使用<code>try (resource)</code>保证<code>Writer</code>正确关闭。</p>
<p><code>Writer</code>是基于<code>OutputStream</code>构造的，可以通过<code>OutputStreamWriter</code>将<code>OutputStream</code>转换为<code>Writer</code>，转换时需要指定编码。</p>
<h2 id="PrintStream和PrintWriter"><a href="#PrintStream和PrintWriter" class="headerlink" title="PrintStream和PrintWriter"></a>PrintStream和PrintWriter</h2><p><code>PrintStream</code>是一种<code>FilterOutputStream</code>，它在<code>OutputStream</code>的接口上，额外提供了一些写入各种数据类型的方法。</p>
<p><code>PrintStream</code>是一种能接收各种数据类型的输出，打印数据时比较方便：</p>
<ul>
<li><code>System.out</code>是标准输出；</li>
<li><code>System.err</code>是标准错误输出。</li>
</ul>
<p><code>PrintWriter</code>是基于<code>Writer</code>的输出。</p>
<h2 id="使用Files"><a href="#使用Files" class="headerlink" title="使用Files"></a>使用Files</h2><p>对于简单的小文件读写操作，可以使用<code>Files</code>工具类简化代码。</p>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/Java/" rel="tag"># Java</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2021/01/19/服务器/Apache配置https/" rel="next" title="Apache配置https">
                  <i class="fa fa-chevron-left"></i> Apache配置https
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2021/01/23/tools/" rel="prev" title="收藏夹">
                  收藏夹 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    
  <div class="comments" id="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80NTk4Mi8yMjQ5Mw=="></div>
  </div>
  
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="https://images.cnblogs.com/cnblogs_com/oeong/1593757/o_191209052450kongaj.jpg"
      alt="Hongchenglong">
  <p class="site-author-name" itemprop="name">Hongchenglong</p>
  <div class="site-description motion-element" itemprop="description">相信过程</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>


  <div class="links-of-blogroll motion-element links-of-blogroll-block">
    <div class="links-of-blogroll-title">
      <i class="fa  fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/oeong" title="https://www.cnblogs.com/oeong" rel="noopener" target="_blank">oeong</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="http://www.zhoushouhao.com/" title="http://www.zhoushouhao.com/" rel="noopener" target="_blank">Shouhao's Notes</a>
        </li>
      
    </ul>
  </div>

        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java快速入门"><span class="nav-number">1.</span> <span class="nav-text">Java快速入门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java简介"><span class="nav-number">1.1.</span> <span class="nav-text">Java简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java程序基础"><span class="nav-number">1.2.</span> <span class="nav-text">Java程序基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流程控制"><span class="nav-number">1.3.</span> <span class="nav-text">流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#if判断"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">if判断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#for-each循环"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">for each循环</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组操作"><span class="nav-number">1.4.</span> <span class="nav-text">数组操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#遍历数组"><span class="nav-number">1.4.0.1.</span> <span class="nav-text">遍历数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排序"><span class="nav-number">1.4.0.2.</span> <span class="nav-text">排序</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象编程"><span class="nav-number">2.</span> <span class="nav-text">面向对象编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象基础"><span class="nav-number">2.1.</span> <span class="nav-text">面向对象基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法"><span class="nav-number">2.1.1.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法重载"><span class="nav-number">2.1.2.</span> <span class="nav-text">方法重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承"><span class="nav-number">2.1.3.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#区分继承和组合"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">区分继承和组合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多态"><span class="nav-number">2.1.4.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象类"><span class="nav-number">2.1.5.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口"><span class="nav-number">2.1.6.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态字段和静态方法"><span class="nav-number">2.1.7.</span> <span class="nav-text">静态字段和静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包"><span class="nav-number">2.1.8.</span> <span class="nav-text">包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域"><span class="nav-number">2.1.9.</span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#classpath和jar"><span class="nav-number">2.1.10.</span> <span class="nav-text">classpath和jar</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-number">2.1.10.1.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java核心类"><span class="nav-number">2.2.</span> <span class="nav-text">Java核心类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串和编码"><span class="nav-number">2.2.1.</span> <span class="nav-text">字符串和编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringBuilder"><span class="nav-number">2.2.2.</span> <span class="nav-text">StringBuilder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringJoiner"><span class="nav-number">2.2.3.</span> <span class="nav-text">StringJoiner</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包装类型"><span class="nav-number">2.2.4.</span> <span class="nav-text">包装类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaBean"><span class="nav-number">2.2.5.</span> <span class="nav-text">JavaBean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举类"><span class="nav-number">2.2.6.</span> <span class="nav-text">枚举类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#纪录类"><span class="nav-number">2.2.7.</span> <span class="nav-text">纪录类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BigInteger"><span class="nav-number">2.2.8.</span> <span class="nav-text">BigInteger</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BigDecimal"><span class="nav-number">2.2.9.</span> <span class="nav-text">BigDecimal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用工具类"><span class="nav-number">2.2.10.</span> <span class="nav-text">常用工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Math"><span class="nav-number">2.2.10.1.</span> <span class="nav-text">Math</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Random"><span class="nav-number">2.2.10.2.</span> <span class="nav-text">Random</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SecureRandom"><span class="nav-number">2.2.10.3.</span> <span class="nav-text">SecureRandom</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#异常处理"><span class="nav-number">3.</span> <span class="nav-text">异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java的异常"><span class="nav-number">3.1.</span> <span class="nav-text">Java的异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#捕获异常"><span class="nav-number">3.2.</span> <span class="nav-text">捕获异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抛出异常"><span class="nav-number">3.3.</span> <span class="nav-text">抛出异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义异常"><span class="nav-number">3.4.</span> <span class="nav-text">自定义异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NullPointerException"><span class="nav-number">3.5.</span> <span class="nav-text">NullPointerException</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#断言"><span class="nav-number">3.6.</span> <span class="nav-text">断言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK-Logging"><span class="nav-number">3.7.</span> <span class="nav-text">JDK Logging</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Commons-Logging"><span class="nav-number">3.8.</span> <span class="nav-text">Commons Logging</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#集合"><span class="nav-number">4.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#List"><span class="nav-number">4.1.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编写equals方法"><span class="nav-number">4.2.</span> <span class="nav-text">编写equals方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map"><span class="nav-number">4.3.</span> <span class="nav-text">Map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编写equals和hashCode"><span class="nav-number">4.4.</span> <span class="nav-text">编写equals和hashCode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EnumMap"><span class="nav-number">4.5.</span> <span class="nav-text">EnumMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TreeMap"><span class="nav-number">4.6.</span> <span class="nav-text">TreeMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Properties"><span class="nav-number">4.7.</span> <span class="nav-text">Properties</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set"><span class="nav-number">4.8.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Queue"><span class="nav-number">4.9.</span> <span class="nav-text">Queue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PriorityQueue"><span class="nav-number">4.10.</span> <span class="nav-text">PriorityQueue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Deque"><span class="nav-number">4.11.</span> <span class="nav-text">Deque</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stack"><span class="nav-number">4.12.</span> <span class="nav-text">Stack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Iterator"><span class="nav-number">4.13.</span> <span class="nav-text">Iterator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collections"><span class="nav-number">4.14.</span> <span class="nav-text">Collections</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IO"><span class="nav-number">5.</span> <span class="nav-text">IO</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#同步和异步"><span class="nav-number">5.0.0.1.</span> <span class="nav-text">同步和异步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结-1"><span class="nav-number">5.0.0.2.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#File"><span class="nav-number">5.1.</span> <span class="nav-text">File</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InputStream"><span class="nav-number">5.2.</span> <span class="nav-text">InputStream</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OutputStream"><span class="nav-number">5.3.</span> <span class="nav-text">OutputStream</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Filter"><span class="nav-number">5.4.</span> <span class="nav-text">Filter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作Zip"><span class="nav-number">5.5.</span> <span class="nav-text">操作Zip</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读取classpath资源"><span class="nav-number">5.6.</span> <span class="nav-text">读取classpath资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#序列化"><span class="nav-number">5.7.</span> <span class="nav-text">序列化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reader"><span class="nav-number">5.8.</span> <span class="nav-text">Reader</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Writer"><span class="nav-number">5.9.</span> <span class="nav-text">Writer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PrintStream和PrintWriter"><span class="nav-number">5.10.</span> <span class="nav-text">PrintStream和PrintWriter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Files"><span class="nav-number">5.11.</span> <span class="nav-text">使用Files</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hongchenglong</span>
</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>


  <script src="/js/affix.js?v=7.3.0"></script>
  <script src="/js/schemes/pisces.js?v=7.3.0"></script>


<script src="/js/next-boot.js?v=7.3.0"></script>




  




























  

  

  


  
  <script src="/js/scrollspy.js?v=7.3.0"></script>
<script src="/js/post-details.js?v=7.3.0"></script>


    
<script>
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
</script>

</body>
</html>
