<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaScript</title>
    <link href="/2021/02/09/JavaScript/"/>
    <url>/2021/02/09/JavaScript/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><a id="more"></a><p>为什么起名叫JavaScript？原因是当时Java语言非常红火，所以网景公司希望<strong>借Java的名气来推广</strong>，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。</p><p>JavaScript语言是在10天时间内设计出来的，有很多设计缺陷。</p><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p>JavaScript<strong>严格区分大小写</strong>，如果弄错了大小写，程序将报错或者运行不正常。</p><h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><p>JavaScript不区分整数和浮点数，统一用<strong>Number</strong>表示。</p><p><strong>比较运算符</strong></p><p>第一种是<code>==</code>比较，它会<strong>自动转换数据类型</strong>再比较，很多时候，会得到非常诡异的结果；</p><p>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回<code>false</code>，如果一致，再比较。</p><p>由于JavaScript这个设计缺陷，不要使用<code>==</code>比较，始终坚持使用<code>===</code>比较。</p><p>这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言，Java是静态语言。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>; <span class="hljs-comment">// a的值是整数123</span><br>a = <span class="hljs-string">'ABC'</span>; <span class="hljs-comment">// a变为字符串</span><br></code></pre></td></tr></table></figure><p>alert()</p><p>console.log()</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>多行字符串：反引号``</p><p>模板字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">"world"</span>;<br><span class="hljs-keyword">var</span> message = <span class="hljs-string">`hello <span class="hljs-subst">$&#123;name&#125;</span>`</span>; <span class="hljs-comment">// 反引号</span><br></code></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>JavaScript的<code>Array</code>可以包含任意数据类型，并通过索引来访问每个元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">'Hello'</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>];<br>arr.length = <span class="hljs-number">2</span>; <span class="hljs-comment">// arr变为[1, 2]</span><br></code></pre></td></tr></table></figure><p>indexOf</p><p>slice: 对应String的<code>substring()</code></p><p>push和pop: <code>pop()</code>则把<code>Array</code>的最后一个元素删除掉</p><p>unshift和shift: 如果要往<code>Array</code>的头部添加若干元素，使用<code>unshift()</code>方法，<code>shift()</code>方法则把<code>Array</code>的第一个元素删掉</p><p>sort</p><p>reverse</p><p>splice</p><p><code>splice()</code>方法是修改<code>Array</code>的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">'Microsoft'</span>, <span class="hljs-string">'Apple'</span>, <span class="hljs-string">'Yahoo'</span>, <span class="hljs-string">'AOL'</span>, <span class="hljs-string">'Excite'</span>, <span class="hljs-string">'Oracle'</span>];<br><span class="hljs-comment">// 从索引2开始删除3个元素,然后再添加两个元素:</span><br>arr.splice(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">'Google'</span>, <span class="hljs-string">'Facebook'</span>); <span class="hljs-comment">// 返回删除的元素 ['Yahoo', 'AOL', 'Excite']</span><br></code></pre></td></tr></table></figure><p>concat: 拼接Array</p><p>join：把当前<code>Array</code>的每个元素都用指定的字符串连接起来，然后返回连接后的字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.join(<span class="hljs-string">'-'</span>); <span class="hljs-comment">// 'A-B-C-1-2-3'</span><br><br>alert(<span class="hljs-string">`欢迎<span class="hljs-subst">$&#123;arr.slice(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)&#125;</span>和<span class="hljs-subst">$&#123;arr[<span class="hljs-number">3</span>]&#125;</span>同学！`</span>);<br></code></pre></td></tr></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>JavaScript的对象是动态类型，可以自由地给一个对象添加或删除属性</p><p>检测<code>xiaoming</code>是否拥有某一属性，可以用<code>in</code>操作符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">'小明'</span><br>&#125;;<br><span class="hljs-keyword">delete</span> xiaoming.age;<br><span class="hljs-string">'toString'</span> <span class="hljs-keyword">in</span> xiaoming<br></code></pre></td></tr></table></figure><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p><code>for ... in</code>对<code>Array</code>的循环得到的是<code>String</code>而不是<code>Number</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> arr) &#123;<br>    <span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// '0', '1', '2'</span><br>    <span class="hljs-built_in">console</span>.log(arr[i]); <span class="hljs-comment">// 'A', 'B', 'C'</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Map和Set"><a href="#Map和Set" class="headerlink" title="Map和Set"></a>Map和Set</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">'Michael'</span>, <span class="hljs-number">95</span>], [<span class="hljs-string">'Bob'</span>, <span class="hljs-number">75</span>], [<span class="hljs-string">'Tracy'</span>, <span class="hljs-number">85</span>]]);<br><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-string">'3'</span>]);<br></code></pre></td></tr></table></figure><h2 id="iterable"><a href="#iterable" class="headerlink" title="iterable"></a>iterable</h2><p>遍历<code>Array</code>可以采用下标循环，遍历<code>Map</code>和<code>Set</code>就无法使用下标。为了统一集合类型，ES6标准引入了新的<code>iterable</code>类型，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x <span class="hljs-keyword">of</span> arr)<br>    <br>arr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element, index, array</span>)</span><br></code></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java面试宝典</title>
    <link href="/2021/02/09/Java/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
    <url>/2021/02/09/Java/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><a id="more"></a><h1 id="Java-SE"><a href="#Java-SE" class="headerlink" title="Java SE"></a>Java SE</h1><h2 id="Java基础（一）"><a href="#Java基础（一）" class="headerlink" title="Java基础（一）"></a>Java基础（一）</h2><h3 id="Java和PHP的区别？"><a href="#Java和PHP的区别？" class="headerlink" title="Java和PHP的区别？"></a>Java和PHP的区别？</h3><p>PHP专注于Web开发，在Web后台开发PHP优于Java；Java比较全面，在数据库访问方面强于PHP。</p><p>Java适合于开发大型的应用系统，应用的前景比较广阔，系统易维护、可复用性较好。</p><h3 id="简单描述一下正则表达式及其用途。"><a href="#简单描述一下正则表达式及其用途。" class="headerlink" title="简单描述一下正则表达式及其用途。"></a>简单描述一下正则表达式及其用途。</h3><p>在编写处理字符串的程序时，经常需要<strong>查找符合某些复杂规则的字符串</strong>。正则表达式就是用于描述这些规则的工具。</p><h3 id="Java中是如何支持正则表达式操作的？"><a href="#Java中是如何支持正则表达式操作的？" class="headerlink" title="Java中是如何支持正则表达式操作的？"></a>Java中是如何支持正则表达式操作的？</h3><p>Java中的<code>String</code>类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java中可以用<code>Pattern</code>类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作，如compile。</p><h3 id="比较一下Java和JavaSciprt？"><a href="#比较一下Java和JavaSciprt？" class="headerlink" title="比较一下Java和JavaSciprt？"></a>比较一下Java和JavaSciprt？</h3><p>Java与JavaScript是两个公司开发的不同的两个产品。</p><ul><li>面向对象和基于对象</li></ul><p>Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；</p><p>JavaScript是基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，用来制作与网络无关的，与用户交互作用的复杂软件。</p><ul><li>编译和解释</li></ul><p>Java的源代码在执行之前，必须经过编译；</p><p>JavaScript无需编译，由浏览器解释执行。</p><ul><li>强类型和弱类型变量</li></ul><p>Java采用强类型变量检查，即所有变量在编译之前必须作声明；</p><p>JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，在运行时检查推断其数据类型。</p><h3 id="Java中如何跳出当前的多重嵌套循环？"><a href="#Java中如何跳出当前的多重嵌套循环？" class="headerlink" title="Java中如何跳出当前的多重嵌套循环？"></a>Java中如何跳出当前的多重嵌套循环？</h3><p>在最外层循环前加一个标记如A，然后用<code>break A</code>，可以跳出多重循环，类似goto。</p><h3 id="amp-和-amp-amp-的区别？"><a href="#amp-和-amp-amp-的区别？" class="headerlink" title="&amp;和&amp;&amp;的区别？"></a>&amp;和&amp;&amp;的区别？</h3><p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。</p><p>&amp;&amp;运算符是<strong>短路与</strong>运算。如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。</p><h3 id="int和Integer有什么区别？"><a href="#int和Integer有什么区别？" class="headerlink" title="int和Integer有什么区别？"></a>int和Integer有什么区别？</h3><p>Java是一个近乎纯洁的面向对象编程语言，但是==为了编程的方便还是引入了基本数据类型==，但是为了能够将这些基本数据类型当成==对象==操作，Java为每一个基本数据类型都引入了对应的==包装类型==（wrapper class），<strong>int的包装类就是Integer</strong>，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以<strong>相互转换</strong>。</p><h3 id="在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，请你讲讲如何输出一个某种编码的字符串？"><a href="#在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，请你讲讲如何输出一个某种编码的字符串？" class="headerlink" title="在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，请你讲讲如何输出一个某种编码的字符串？"></a>在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，请你讲讲如何输出一个某种编码的字符串？</h3><p><code>String str = new String(&quot;字符串&quot;.getBytes(&quot;ISO-8859-1&quot;), &quot;GBK&quot;);</code></p><h3 id="说明String和StringBuffer的区别"><a href="#说明String和StringBuffer的区别" class="headerlink" title="说明String和StringBuffer的区别"></a>说明String和StringBuffer的区别</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Maven配置</title>
    <link href="/2021/02/04/Java/maven%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/02/04/Java/maven%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><a id="more"></a><h2 id="Maven是什么"><a href="#Maven是什么" class="headerlink" title="Maven是什么"></a>Maven是什么</h2><ul><li>Maven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。</li><li>Maven 是一个<strong>项目管理工具</strong>，可以对 Java 项目进行构建、依赖管理。</li></ul><p><a href="https://www.runoob.com/maven/maven-setup.html" target="_blank" rel="noopener">Maven 环境配置</a></p><h2 id="配置MAVEN-HOME报错"><a href="#配置MAVEN-HOME报错" class="headerlink" title="配置MAVEN_HOME报错"></a>配置MAVEN_HOME报错</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">The JAVA_HOME environment <span class="hljs-built_in">variable</span> is <span class="hljs-keyword">not</span> defined correctly<br>This environment <span class="hljs-built_in">variable</span> is needed <span class="hljs-built_in">to</span> run this program<br>NB: JAVA_HOME should point <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> JDK <span class="hljs-keyword">not</span> <span class="hljs-keyword">a</span> JRE<br></code></pre></td></tr></table></figure><p>原因是我安装了两个jdk版本，并同时将路径写在JAVA_HOME中。于是分别为两个jdk设置JAVA_HOME。设置<code>JAVA_HOME = %JAVA_HOME8%</code>，当需要另一版本则切换为<code>JAVA_HOME = %JAVA_HOME15%</code>。</p><p><img src="http://cdn.oeong.com/niu20210204235021.png" srcset="/img/loading.gif" alt="image-20210204235019615"></p><p>学习博客：<a href="https://blog.csdn.net/yuruixin_china/article/details/53607248?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs" target="_blank" rel="noopener">同一个电脑安装两个jdk版本</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>收藏夹</title>
    <link href="/2021/01/23/tools/"/>
    <url>/2021/01/23/tools/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><a id="more"></a><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>七牛图床：免费10G，需要域名</p><p><a href="https://molunerfinn.com/PicGo" target="_blank" rel="noopener">PicGo</a>：免费开源的图床上传应用</p><p><a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a>：Markdown编辑器</p><p><a href="https://u.tools/" target="_blank" rel="noopener">uTools</a>：生产力工具集</p><p><a href="https://carbon.now.sh/" target="_blank" rel="noopener">carbon</a>：生成漂亮代码的截图工具</p><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰</a></p><p><a href="https://kuangstudy.com/" target="_blank" rel="noopener">狂神说</a></p><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><p><a href="https://www.52pojie.cn/" target="_blank" rel="noopener">吾爱破解</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java_notes</title>
    <link href="/2021/01/23/Java/Java-notes/"/>
    <url>/2021/01/23/Java/Java-notes/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><a id="more"></a><h1 id="Java快速入门"><a href="#Java快速入门" class="headerlink" title="Java快速入门"></a>Java快速入门</h1><h2 id="Java简介"><a href="#Java简介" class="headerlink" title="Java简介"></a>Java简介</h2><ul><li>JDK：Java Development Kit</li><li>JRE：Java Runtime Environment</li></ul><p>简单地说，JRE就是运行Java字节码的<strong>虚拟机</strong>。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了<strong>包含</strong>JRE，还提供了编译器、调试器等开发工具。</p><p>  二者关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ascii"> ┌─    ┌──────────────────────────────────┐<br> │     │     Compiler, debugger, etc.     │<br> │     └──────────────────────────────────┘<br>JDK ┌─ ┌──────────────────────────────────┐<br> │  │  │                                  │<br> │ JRE │      JVM + Runtime Library       │<br> │  │  │                                  │<br> └─ └─ └──────────────────────────────────┘<br>       ┌───────┐┌───────┐┌───────┐┌───────┐<br>       │Windows││ Linux ││ macOS ││others │<br>       └───────┘└───────┘└───────┘└───────┘<br></code></pre></td></tr></table></figure><h2 id="Java程序基础"><a href="#Java程序基础" class="headerlink" title="Java程序基础"></a>Java程序基础</h2><p><code>int[] ns = new int[5];</code></p><p>对象、数组都是引用数据类型。</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h4 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h4><p><code>==</code>表示“引用的<strong>对象</strong>是否相等”，浮点数判断相等不能直接用</p><p>使用<code>equals()</code>判断引用类型<strong>内容</strong>相等，注意避免<code>NullPointerException</code>。</p><h4 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for each循环"></a>for each循环</h4><p><code>for each</code>循环可以直接遍历数组的每个元素；</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">int</span>[] ns = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span> &#125;;<br><span class="hljs-built_in">for</span> (<span class="hljs-keyword">int</span> n : ns) &#123;<br>System.out.<span class="hljs-built_in">println</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><p>遍历数组可以使用<code>for</code>循环，<code>for</code>循环可以访问数组索引，<code>for each</code>循环直接迭代每个数组元素，但无法获取索引；</p><p>使用<code>Arrays.toString()</code>可以快速获取数组内容。</p><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>排序前</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                   ┌──────────────────────────────────┐<br>               ┌───┼──────────────────────┐           │<br>               │   │                      ▼           ▼<br>         ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐<br>ns ─────&gt;│░░░│░░░│░░░│   │&quot;banana&quot;│   │&quot;apple&quot;│   │&quot;pear&quot;│   │<br>         └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘<br>           │                 ▲<br>           └─────────────────┘<br></code></pre></td></tr></table></figure><p>排序后，原来的3个字符串在<strong>内存</strong>中均没有任何变化，但是<code>ns</code>数组的每个元素<strong>指向</strong>变化了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                   ┌──────────────────────────────────┐<br>               ┌───┼──────────┐                       │<br>               │   │          ▼                       ▼<br>         ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐<br>ns ─────&gt;│░░░│░░░│░░░│   │&quot;banana&quot;│   │&quot;apple&quot;│   │&quot;pear&quot;│   │<br>         └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘<br>           │                              ▲<br>           └──────────────────────────────┘<br></code></pre></td></tr></table></figure><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>Java是一种面向对象的编程语言。面向对象编程，英文是Object-Oriented Programming，简称OOP。</p><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><p>在OOP中，<code>class</code>和<code>instance</code>是“模版”和“实例”的关系；</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>在方法内部，可以使用一个隐含的变量<code>this</code>，它始终指向当前实例。因此，通过<code>this.field</code>就可以访问当前实例的字段。</p><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>方法重载是指多个方法的方法名相同，但各自的参数不同；</p><p>重载方法返回值类型应该相同。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="区分继承和组合"><a href="#区分继承和组合" class="headerlink" title="区分继承和组合"></a>区分继承和组合</h4><p><code>Student</code>和<code>Book</code>的关系是has关系。</p><ul><li>继承是面向对象编程的一种强大的代码复用方式；</li><li>Java只允许单继承，所有类最终的根类是<code>Object</code>；</li><li><code>protected</code>允许子类访问父类的字段和方法；</li><li>子类的构造方法可以通过<code>super()</code>调用父类的构造方法；</li><li>可以<strong>安全地向上转型</strong>为更抽象的类型；</li><li>可以强制向下转型，最好借助<code>instanceof</code>判断；</li><li>子类和父类的关系是is，has关系不能用继承。</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。</p><ul><li>子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为；</li><li>Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；</li><li><code>final</code>修饰符有多种作用：<ul><li><code>final</code>修饰的方法可以阻止被覆写；</li><li><code>final</code>修饰的class可以阻止被继承；</li><li><code>final</code>修饰的field必须在创建对象时初始化，随后不可修改。</li></ul></li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>通过<code>abstract</code>定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范；</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>所谓<code>interface</code>，就是比抽象类还要抽象的纯抽象接口，因为<strong>不能定义实例字段</strong>。</p><p><code>interface</code>的字段只能是<code>public static final</code>类型</p><h3 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h3><p>所有实例共享一个静态字段。</p><p>不推荐用<code>实例变量.静态字段</code>去访问静态字段，推荐<strong>用类名来访问静态字段</strong>。</p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>Java内建的<code>package</code>机制是为了避免<code>class</code>命名冲突；</p><p>JDK的核心类使用<code>java.lang</code>包，编译器会自动导入；</p><p>JDK的其它常用类定义在<code>java.util.*</code>，<code>java.math.*</code>，<code>java.text.*</code>，……；</p><p>包名推荐使用<strong>倒置的域名</strong>，避免冲突，例如<code>org.apache</code>。</p><p>包没有父子关系，<code>com.apache</code>和<code>com.apache.abc</code>是不同的包。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>定义在一个<code>class</code>内部的<code>class</code>称为嵌套类（<code>nested class</code>）</p><p>如果不确定是否需要<code>public</code>，就不声明为<code>public</code>，即尽可能少地暴露对外的字段和方法。</p><p>把方法定义为<code>package</code>权限有助于测试，因为测试类和被测试类只要位于同一个<code>package</code>，测试代码就可以访问被测试类的<code>package</code>权限方法。</p><p>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。如果有<code>public</code>类，文件名必须和<code>public</code>类的名字相同。</p><p><code>protected</code>作用于继承关系。定义为<code>protected</code>的字段和方法可以被子类访问，以及子类的子类</p><h3 id="classpath和jar"><a href="#classpath和jar" class="headerlink" title="classpath和jar"></a>classpath和jar</h3><p><code>classpath</code>是JVM用到的一个环境变量，它用来指示JVM如何搜索<code>class</code>。</p><p>因为Java是编译型语言，源码文件是<code>.java</code>，而编译后的<code>.class</code>文件才是真正可以被JVM执行的字节码。</p><p>jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。</p><blockquote><p> 如何创建jar包？</p></blockquote><p>因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从<code>.zip</code>改为<code>.jar</code>，一个jar包就创建成功。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>JVM通过环境变量<code>classpath</code>决定搜索<code>class</code>的路径和顺序；</p><p>不推荐设置系统环境变量<code>classpath</code>，始终建议通过<code>-cp</code>命令传入；</p><p>jar包相当于目录，可以包含很多<code>.class</code>文件，方便下载和使用；</p><p><code>MANIFEST.MF</code>文件可以提供jar包的信息，如<code>Main-Class</code>，这样可以直接运行jar包。</p><h2 id="Java核心类"><a href="#Java核心类" class="headerlink" title="Java核心类"></a>Java核心类</h2><h3 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h3><ul><li>Java字符串<code>String</code>是不可变对象；</li><li>字符串操作不改变原字符串内容，而是返回新字符串；</li><li>常用的字符串操作：提取子串、查找、替换、大小写转换等；</li><li>Java使用Unicode编码表示<code>String</code>和<code>char</code>；</li><li>转换编码就是将<code>String</code>和<code>byte[]</code>转换，需要指定编码；</li><li>转换为<code>byte[]</code>时，始终优先考虑<code>UTF-8</code>编码。</li></ul><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>为了能高效拼接字符串，Java标准库提供了<code>StringBuilder</code>，它是一个可变对象，可以预分配<strong>缓冲区</strong>，这样，往<code>StringBuilder</code>中新增字符时，<strong>不会创建新的临时对象</strong>；</p><p><code>StringBuilder</code>可以支持<strong>链式操作</strong>，实现链式操作的关键是返回实例本身；</p><h3 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h3><p>用指定分隔符拼接字符串数组时，使用<code>StringJoiner</code>或者<code>String.join()</code>更方便；</p><p>用<code>StringJoiner</code>拼接字符串时，还可以额外附加一个“开头”和“结尾”。</p><h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>Java核心库提供的包装类型可以把基本类型包装为<code>class</code>；</p><p>自动装箱和自动拆箱都是在编译期完成的（JDK&gt;=1.5）；</p><p>装箱和拆箱会影响执行效率，且拆箱时可能发生<code>NullPointerException</code>；</p><p>包装类型的比较必须使用<code>equals()</code>；</p><p>整数和浮点数的包装类型都继承自<code>Number</code>；</p><p>包装类型提供了大量实用方法。</p><h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><p>JavaBean是一种符合命名规范的<code>class</code>，它通过<code>getter</code>和<code>setter</code>来定义属性；</p><p>JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输；</p><p>可以利用IDE快速生成<code>getter</code>和<code>setter</code>；</p><p>属性是一种通用的叫法，并非Java语法规定；</p><p>使用<code>Introspector.getBeanInfo()</code>可以获取属性列表。</p><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>Java使用<code>enum</code>定义枚举类型，它被编译器编译为<code>final class Xxx extends Enum { … }</code>；</p><p>通过<code>name()</code>获取常量定义的字符串，注意不要使用<code>toString()</code>；</p><p>通过<code>ordinal()</code>返回常量定义的顺序（无实质意义）；</p><p>可以为<code>enum</code>编写构造方法、字段和方法</p><p><code>enum</code>的构造方法要声明为<code>private</code>，字段强烈建议声明为<code>final</code>；</p><p><code>enum</code>适合用在<code>switch</code>语句中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> Weekday &#123;<br>    MON(<span class="hljs-number">1</span>), TUE(<span class="hljs-number">2</span>), WED(<span class="hljs-number">3</span>), THU(<span class="hljs-number">4</span>), FRI(<span class="hljs-number">5</span>), SAT(<span class="hljs-number">6</span>), SUN(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="纪录类"><a href="#纪录类" class="headerlink" title="纪录类"></a>纪录类</h3><p>使用<code>String</code>、<code>Integer</code>等类型的时候，这些类型都是<strong>不变类</strong>，一个不变类具有以下特点：</p><ol><li>定义class时使用<code>final</code>，无法派生子类；</li><li>每个字段使用<code>final</code>，保证创建实例后无法修改任何字段。</li></ol><p><code>public record Point(int x, int y) {}</code></p><p>从Java 14开始，提供新的<code>record</code>关键字，可以非常方便地定义Data Class：</p><ul><li>使用<code>record</code>定义的是不变类；</li><li>可以编写Compact Constructor对参数进行验证；</li><li>可以定义静态方法。</li></ul><h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h3><p><code>BigInteger</code>用于表示任意大小的整数；</p><p><code>BigInteger</code>是不变类，并且继承自<code>Number</code>；</p><p>将<code>BigInteger</code>转换成基本类型时可使用<code>longValueExact()</code>等方法保证结果准确。</p><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>如果查看<code>BigDecimal</code>的源码，可以发现，实际上一个<code>BigDecimal</code>是通过一个<code>BigInteger</code>和一个<code>scale</code>来表示的，即<code>BigInteger</code>表示一个完整的整数，而<code>scale</code>表示小数位数；</p><p><code>BigDecimal</code>用于表示精确的小数，常用于财务计算；</p><p>比较<code>BigDecimal</code>的值是否相等，必须使用<code>compareTo()</code>而不能使用<code>equals()</code></p><h3 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h3><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><p>数学计算</p><h4 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h4><p>创建<code>Random</code>实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的<strong>伪随机数</strong>序列就不同。</p><h4 id="SecureRandom"><a href="#SecureRandom" class="headerlink" title="SecureRandom"></a>SecureRandom</h4><p>安全的随机数，真随机数。种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="Java的异常"><a href="#Java的异常" class="headerlink" title="Java的异常"></a>Java的异常</h2><p>Java使用异常来表示错误，并通过<code>try ... catch</code>捕获异常；</p><p>Java的异常是<code>class</code>，并且从<code>Throwable</code>继承；</p><p><code>Error</code>是无需捕获的严重错误，<code>Exception</code>是应该捕获的可处理的错误；</p><p><code>RuntimeException</code>无需强制捕获，非<code>RuntimeException</code>（Checked Exception）需强制捕获，或者用<code>throws</code>声明；</p><p>如果不想写任何<code>try</code>代码，可以直接把<code>main()</code>方法定义为<code>throws Exception</code>。也就声明了可能抛出所有的<code>Exception</code>，因此在内部就无需捕获了。代价就是一旦发生异常，程序会立刻退出。</p><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>使用<code>try ... catch ... finally</code>时：</p><ul><li>多个<code>catch</code>语句的匹配顺序非常重要，子类必须放在前面；</li><li><code>finally</code>语句保证了有无异常都会执行，它是可选的；</li><li>一个<code>catch</code>语句也可以匹配多个非继承关系的异常。</li></ul><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>调用<code>printStackTrace()</code>可以打印异常的传播栈，对于调试非常有用；</p><p>捕获异常并再次抛出新的异常时，应该持有原始异常信息；</p><p>通常不要在<code>finally</code>中抛出异常。如果在<code>finally</code>中抛出异常，应该原始异常加入到原有异常中。调用方可通过<code>Throwable.getSuppressed()</code>获取所有添加的<code>Suppressed Exception</code>。</p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>抛出异常时，尽量复用JDK已定义的异常类型；</p><p>自定义异常体系时，推荐从<code>RuntimeException</code>派生“根异常”，再派生出业务异常；</p><p>自定义异常时，应该提供多种构造方法。</p><h2 id="NullPointerException"><a href="#NullPointerException" class="headerlink" title="NullPointerException"></a>NullPointerException</h2><p>空指针异常</p><p>编写业务逻辑时，用空字符串<code>&quot;&quot;</code>表示未填写比<code>null</code>安全得多。</p><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>断言（Assertion）是一种调试程序的方式。在Java中，使用<code>assert</code>关键字来实现断言。</p><h2 id="JDK-Logging"><a href="#JDK-Logging" class="headerlink" title="JDK Logging"></a>JDK Logging</h2><p>日志是为了替代<code>System.out.println()</code>，可以定义格式，重定向到文件等；</p><p>日志可以存档，便于追踪问题；</p><p>日志记录可以按级别分类，便于打开或关闭某些级别；</p><p>可以根据配置文件调整日志，无需修改代码；</p><p>Java标准库提供了<code>java.util.logging</code>来实现日志功能。</p><h2 id="Commons-Logging"><a href="#Commons-Logging" class="headerlink" title="Commons Logging"></a>Commons Logging</h2><p>和Java标准库提供的日志不同，Commons Logging是一个第三方日志库，它是由Apache创建的日志模块。</p><p>Commons Logging是使用最广泛的日志模块；</p><p>Commons Logging的API非常简单；</p><p>Commons Logging可以自动检测并使用其他日志模块。</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。</p><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>JVM为每个加载的class及interface创建了对应的Class实例来保存class及interface的所有信息；</p><p>获取一个class对应的Class实例后，就可以获取该class的所有信息；</p><p>通过Class实例获取class信息的方法称为反射（Reflection）；</p><p>JVM总是动态加载class，可以在运行期根据条件来控制加载class。</p><h2 id="访问字段"><a href="#访问字段" class="headerlink" title="访问字段"></a>访问字段</h2><p>Java的反射API提供的<code>Field</code>类封装了字段的所有信息：</p><p>通过<code>Class</code>实例的方法可以获取<code>Field</code>实例：<code>getField()</code>，<code>getFields()</code>，<code>getDeclaredField()</code>，<code>getDeclaredFields()</code>；</p><p>通过Field实例可以获取字段信息：<code>getName()</code>，<code>getType()</code>，<code>getModifiers()</code>；</p><p>通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用<code>setAccessible(true)</code>来访问非<code>public</code>字段。</p><p>通过反射读写字段是一种非常规方法，它会破坏对象的封装。</p><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>Java的反射API提供的Method对象封装了方法的所有信息：</p><p>通过<code>Class</code>实例的方法可以获取<code>Method</code>实例：<code>getMethod()</code>，<code>getMethods()</code>，<code>getDeclaredMethod()</code>，<code>getDeclaredMethods()</code>；</p><p>通过<code>Method</code>实例可以获取方法信息：<code>getName()</code>，<code>getReturnType()</code>，<code>getParameterTypes()</code>，<code>getModifiers()</code>；</p><p>通过<code>Method</code>实例可以调用某个对象的方法：<code>Object invoke(Object instance, Object... parameters)</code>；</p><p>通过设置<code>setAccessible(true)</code>来访问非<code>public</code>方法；</p><p>通过反射调用方法时，仍然遵循多态原则。</p><h2 id="调用构造方法"><a href="#调用构造方法" class="headerlink" title="调用构造方法"></a>调用构造方法</h2><p><code>Constructor</code>对象封装了构造方法的所有信息；</p><p>通过<code>Class</code>实例的方法可以获取<code>Constructor</code>实例：<code>getConstructor()</code>，<code>getConstructors()</code>，<code>getDeclaredConstructor()</code>，<code>getDeclaredConstructors()</code>；</p><p>通过<code>Constructor</code>实例可以创建一个实例对象：<code>newInstance(Object... parameters)</code>； 通过设置<code>setAccessible(true)</code>来访问非<code>public</code>构造方法。</p><h2 id="获取继承关系"><a href="#获取继承关系" class="headerlink" title="获取继承关系"></a>获取继承关系</h2><p>通过<code>Class</code>对象可以获取继承关系：</p><ul><li><code>Class getSuperclass()</code>：获取父类类型；</li><li><code>Class[] getInterfaces()</code>：获取当前类实现的所有接口。</li></ul><p>通过<code>Class</code>对象的<code>isAssignableFrom()</code>方法可以判断一个向上转型是否可以实现。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>Java标准库提供了动态代理功能，允许在运行期动态创建一个接口的实例；</p><p>动态代理是通过<code>Proxy</code>创建代理对象，然后将接口方法“代理”给<code>InvocationHandler</code>完成的。</p><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>Java的集合类定义在<code>java.util</code>包中，支持泛型，主要提供了3种集合类，包括<code>List</code>，<code>Set</code>和<code>Map</code>。Java集合使用统一的<code>Iterator</code>遍历，尽量不要使用遗留接口。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><code>List</code>的行为和数组几乎完全相同。 List是一个接口，而ArrayList是List接口的一个实现类。 </p><p><code>List</code>是按索引顺序访问的长度可变的有序表，优先使用<code>ArrayList</code>而不是<code>LinkedList</code>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>List&lt;String&gt; list = List.of(<span class="hljs-string">"apple"</span>, <span class="hljs-string">"pear"</span>, <span class="hljs-string">"banana"</span>);<br></code></pre></td></tr></table></figure><p>通过<code>Iterator</code>遍历<code>List</code>永远是最高效的方式。并且，由于<code>Iterator</code>遍历是如此常用，所以，Java的<code>for each</code>循环本身就可以帮我们使用<code>Iterator</code>遍历。</p><p><code>List</code>可以和<code>Array</code>相互转换。</p><p>List和Array的区别是什么？</p><ol><li>数组是定长，list是自动增长。</li><li>数组效率高，list效率低。</li></ol><h2 id="编写equals方法"><a href="#编写equals方法" class="headerlink" title="编写equals方法"></a>编写equals方法</h2><p><code>List</code>还提供了<code>boolean contains(Object o)</code>方法来判断<code>List</code>是否包含某个指定元素。此外，<code>int indexOf(Object o)</code>方法可以返回某个元素的索引，如果元素不存在，就返回<code>-1</code>。</p><p>对于引用字段比较，我们使用<code>equals()</code>，对于基本类型字段的比较，我们使用<code>==</code>。</p><p>总结一下<code>equals()</code>方法的正确编写方法：</p><ol><li>先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；</li><li>用<code>instanceof</code>判断传入的待比较的<code>Object</code>是不是当前类型，如果是，继续比较，否则，返回<code>false</code>；</li><li>对引用类型用<code>Objects.equals()</code>比较，对基本类型直接用<code>==</code>比较。</li></ol><p>如果不调用<code>List</code>的<code>contains()</code>、<code>indexOf()</code>这些方法，就不必覆写<code>equals()</code>方法。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><code>Map</code>是一种映射表，可以通过<code>key</code>快速查找<code>value</code>。无序。</p><p>可以通过<code>for each</code>遍历<code>keySet()</code>，也可以通过<code>for each</code>遍历<code>entrySet()</code>，直接获取<code>key-value</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (String key : map.keySet())<br><span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet())<br></code></pre></td></tr></table></figure><p>最常用的一种<code>Map</code>实现是<code>HashMap</code>。</p><h2 id="编写equals和hashCode"><a href="#编写equals和hashCode" class="headerlink" title="编写equals和hashCode"></a>编写equals和hashCode</h2><p><code>HashMap</code>之所以能根据<code>key</code>直接拿到<code>value</code>，原因是它内部通过空间换时间的方法，用一个大数组存储所有<code>value</code>，并根据key直接计算出<code>value</code>应该存储在哪个索引</p><p>要正确使用<code>HashMap</code>，作为<code>key</code>的类必须正确覆写<code>equals()</code>和<code>hashCode()</code>方法；</p><p>一个类如果覆写了<code>equals()</code>，就必须覆写<code>hashCode()</code>，并且覆写规则是：</p><ul><li>如果<code>equals()</code>返回<code>true</code>，则<code>hashCode()</code>返回值必须相等；</li><li>如果<code>equals()</code>返回<code>false</code>，则<code>hashCode()</code>返回值尽量不要相等。</li></ul><p>实现<code>hashCode()</code>方法可以通过<code>Objects.hashCode()</code>辅助方法实现。</p><h2 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h2><p>如果<code>Map</code>的key是<code>enum</code>类型，推荐使用<code>EnumMap</code>，既保证速度，也不浪费空间。</p><p>使用<code>EnumMap</code>的时候，根据面向抽象编程的原则，应持有<code>Map</code>接口。</p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ascii">       ┌───┐<br>       │Map│<br>       └───┘<br>         ▲<br>    ┌────┴─────┐<br>    │          │<br>┌───────┐ ┌─────────┐<br>│HashMap│ │SortedMap│<br>└───────┘ └─────────┘<br>               ▲<br>               │<br>          ┌─────────┐<br>          │ TreeMap │<br>          └─────────┘<br></code></pre></td></tr></table></figure><p><code>SortedMap</code>是接口，它的实现类是<code>TreeMap</code>。创建<code>TreeMap</code>时同时指定一个自定义排序算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Person, Integer&gt; map = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;(<span class="hljs-keyword">new</span> Comparator&lt;Person&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person p1, Person p2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> p1.name.compareTo(p2.name);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>SortedMap</code>在遍历时严格按照Key的<strong>顺序</strong>遍历，最常用的实现类是<code>TreeMap</code>；</p><p>作为<code>SortedMap</code>的Key必须实现<code>Comparable</code>接口，或者传入<code>Comparator</code>；</p><p>要严格按照<code>compare()</code>规范实现比较逻辑，否则，<code>TreeMap</code>将不能正常工作。</p><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>Java集合库提供的<code>Properties</code>用于读写配置文件<code>.properties</code>。<code>.properties</code>文件可以使用UTF-8编码。</p><p>可以从文件系统、classpath或其他任何地方读取<code>.properties</code>文件。</p><p>读写<code>Properties</code>时，注意仅使用<code>getProperty()</code>和<code>setProperty()</code>方法，不要调用继承而来的<code>get()</code>和<code>put()</code>等方法。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><code>Set</code>实际上相当于只存储key、不存储value的<code>Map</code>。</p><p><code>Set</code>用于存储不重复的元素集合：</p><ul><li>放入<code>HashSet</code>的元素与作为<code>HashMap</code>的key要求相同；</li><li>放入<code>TreeSet</code>的元素与作为<code>TreeMap</code>的Key要求相同；</li></ul><p>利用<code>Set</code>可以去除重复元素；</p><p>遍历<code>SortedSet</code>按照元素的排序顺序遍历，也可以自定义排序算法。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>队列<code>Queue</code>实现了一个先进先出（FIFO）的数据结构：</p><ul><li>通过<code>add()</code>/<code>offer()</code>方法将元素添加到队尾；</li><li>通过<code>remove()</code>/<code>poll()</code>从队首获取元素并删除；</li><li>通过<code>element()</code>/<code>peek()</code>从队首获取元素但不删除。</li></ul><p>要避免把<code>null</code>添加到队列，很难确定是取到了<code>null</code>元素还是队列为空。</p><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p><code>PriorityQueue</code>实现了一个优先队列：从队首获取元素时，总是获取优先级最高的元素。</p><p><code>PriorityQueue</code>默认按元素比较的顺序排序（必须实现<code>Comparable</code>接口），也可以通过<code>Comparator</code>自定义排序算法（元素就不必实现<code>Comparable</code>接口）。</p><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p><code>Deque</code>实现了一个双端队列（Double Ended Queue），它可以：</p><ul><li>将元素添加到队尾或队首：<code>addLast()</code>/<code>offerLast()</code>/<code>addFirst()</code>/<code>offerFirst()</code>；</li><li>从队首／队尾获取元素并删除：<code>removeFirst()</code>/<code>pollFirst()</code>/<code>removeLast()</code>/<code>pollLast()</code>；</li><li>从队首／队尾获取元素但不删除：<code>getFirst()</code>/<code>peekFirst()</code>/<code>getLast()</code>/<code>peekLast()</code>；</li><li>总是调用<code>xxxFirst()</code>/<code>xxxLast()</code>以便与<code>Queue</code>的方法区分开；</li><li>避免把<code>null</code>添加到队列。</li></ul><p><code>Deque</code>是一个接口，它的实现类有<code>ArrayDeque</code>和<code>LinkedList</code>。</p><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>栈（Stack）是一种后进先出（LIFO）的数据结构，操作栈的元素的方法有：</p><ul><li>把元素压栈：<code>push(E)</code>；</li><li>把栈顶的元素“弹出”：<code>pop(E)</code>；</li><li>取栈顶元素但不弹出：<code>peek(E)</code>。</li></ul><p>在Java中，我们用<code>Deque</code>可以实现<code>Stack</code>的功能，注意只调用<code>push()</code>/<code>pop()</code>/<code>peek()</code>方法，避免调用<code>Deque</code>的其他方法。</p><p>最后，不要使用遗留类<code>Stack</code>。</p><h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>我们把这种通过<code>Iterator</code>对象遍历集合的模式称为迭代器。</p><p>使用迭代器的好处在于，调用方总是以统一的方式遍历各种集合类型，而不必关系它们内部的存储结构。</p><p><code>Iterator</code>是一种抽象的数据访问模型。使用<code>Iterator</code>模式进行迭代的好处有：</p><ul><li>对任何集合都采用<strong>同一种访问模型</strong>；</li><li>调用者对集合<strong>内部结构</strong>一无所知；</li><li>集合类返回的<code>Iterator</code>对象知道如何迭代。</li></ul><p>Java提供了标准的迭代器模型，即集合类实现<code>java.util.Iterable</code>接口，返回<code>java.util.Iterator</code>实例。</p><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p><code>Collections</code>类提供了一组工具方法来方便使用集合类：</p><ul><li>创建空集合；</li><li>创建单元素集合；</li><li>创建不可变集合；</li><li>排序／洗牌等操作。</li></ul><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><p>IO是指Input/Output，即输入和输出。以<strong>内存</strong>为中心：</p><ul><li>Input指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。</li><li>Output指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据从内存输出到网络等等。</li></ul><p>IO流是一种顺序读写数据的模式，它的特点是单向流动。数据类似自来水一样在水管中流动，所以我们把它称为IO流。</p><p>IO流以<code>byte</code>（字节）为最小单位，因此也称为<em>字节流</em>。</p><p>如果我们需要读写的是字符，并且字符不全是单字节表示的ASCII字符，那么，按照<code>char</code>来读写显然更方便，这种流称为<em>字符流</em>。</p><h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>同步IO是指，读写IO时代码必须等待数据返回后才继续执行后续代码，它的优点是代码编写简单，缺点是CPU执行效率低。</p><p>而异步IO是指，读写IO时仅发出请求，然后立刻执行后续代码，它的优点是CPU执行效率高，缺点是代码编写复杂。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>IO流是一种流式的数据输入/输出模型：</p><ul><li>二进制数据以<code>byte</code>为最小单位在<code>InputStream</code>/<code>OutputStream</code>中单向流动；</li><li>字符数据以<code>char</code>为最小单位在<code>Reader</code>/<code>Writer</code>中单向流动。</li></ul><p>Java标准库的<code>java.io</code>包提供了同步IO功能：</p><ul><li>字节流接口：<code>InputStream</code>/<code>OutputStream</code>；</li><li>字符流接口：<code>Reader</code>/<code>Writer</code>。</li></ul><h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><p>传入相对路径时，相对路径前面加上当前目录就是绝对路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设当前目录是C:\Docs</span><br>File f1 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"sub\\javac"</span>); <span class="hljs-comment">// 绝对路径是C:\Docs\sub\javac</span><br></code></pre></td></tr></table></figure><p>Java标准库的<code>java.io.File</code>对象表示一个文件或者目录：</p><ul><li>创建<code>File</code>对象本身不涉及IO操作；</li><li>可以获取路径／绝对路径／规范路径：<code>getPath()</code>/<code>getAbsolutePath()</code>/<code>getCanonicalPath()</code>；</li><li>可以获取目录的文件和子目录：<code>list()</code>/<code>listFiles()</code>；</li><li>可以创建或删除文件和目录。</li></ul><h2 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h2><p>Java标准库的<code>java.io.InputStream</code>定义了所有输入流的超类：</p><ul><li><code>FileInputStream</code>实现了文件流输入；</li><li><code>ByteArrayInputStream</code>在内存中模拟一个字节流输入。</li></ul><p>总是使用<code>try(resource)</code>来保证<code>InputStream</code>正确关闭。</p><h2 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h2><p>为什么要有<code>flush()</code>？因为向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个<code>byte[]</code>数组），<strong>等到缓冲区写满了，再一次性写入文件或者网络。</strong></p><p>Java标准库的<code>java.io.OutputStream</code>定义了所有输出流的超类：</p><ul><li><code>FileOutputStream</code>实现了文件流输出；</li><li><code>ByteArrayOutputStream</code>在内存中模拟一个字节流输出。</li></ul><p>某些情况下需要手动调用<code>OutputStream</code>的<code>flush()</code>方法来强制输出缓冲区。</p><p>总是使用<code>try(resource)</code>来保证<code>OutputStream</code>正确关闭。</p><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>Java的IO标准库使用Filter模式为<code>InputStream</code>和<code>OutputStream</code>增加功能：</p><ul><li>可以把一个<code>InputStream</code>和任意个<code>FilterInputStream</code>组合；</li><li>可以把一个<code>OutputStream</code>和任意个<code>FilterOutputStream</code>组合。</li></ul><p>Filter模式可以在运行期动态增加功能（又称Decorator模式）。</p><h2 id="操作Zip"><a href="#操作Zip" class="headerlink" title="操作Zip"></a>操作Zip</h2><p><code>ZipInputStream</code>可以读取zip格式的流，<code>ZipOutputStream</code>可以把多份数据写入zip包；</p><p>配合<code>FileInputStream</code>和<code>FileOutputStream</code>就可以读写zip文件。</p><h2 id="读取classpath资源"><a href="#读取classpath资源" class="headerlink" title="读取classpath资源"></a>读取classpath资源</h2><p>把资源存储在classpath中可以避免文件路径依赖；</p><p><code>Class</code>对象的<code>getResourceAsStream()</code>可以从classpath中读取指定资源；</p><p>根据classpath读取资源时，需要检查返回的<code>InputStream</code>是否为<code>null</code>。</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>序列化是指把一个Java对象变成二进制内容，本质上就是一个<code>byte[]</code>数组。</p><p>为什么要把Java对象序列化呢？因为序列化后可以把<code>byte[]</code>保存到文件中，或者把<code>byte[]</code>通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。</p><p>可序列化的Java对象必须实现<code>java.io.Serializable</code>接口，类似<code>Serializable</code>这样的空接口被称为“标记接口”（Marker Interface）；</p><p>反序列化时不调用构造方法，可设置<code>serialVersionUID</code>作为版本号（非必需）；</p><p>Java的序列化机制仅适用于Java，如果需要与其它语言交换数据，必须使用通用的序列化方法，例如JSON。</p><h2 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h2><p><code>Reader</code>是Java的IO库提供的另一个输入流接口。和<code>InputStream</code>的区别是，<code>InputStream</code>是一个字节流，即以<code>byte</code>为单位读取，而<code>Reader</code>是一个字符流，即以<code>char</code>为单位读取。</p><p><code>Reader</code>定义了所有<strong>字符</strong>输入流的超类：</p><ul><li><code>FileReader</code>实现了文件字符流输入，使用时需要指定编码；</li><li><code>CharArrayReader</code>和<code>StringReader</code>可以在内存中模拟一个字符流输入。</li></ul><p><code>Reader</code>是基于<code>InputStream</code>构造的：可以通过<code>InputStreamReader</code>在指定编码的同时将任何<code>InputStream</code>转换为<code>Reader</code>。</p><p>总是使用<code>try (resource)</code>保证<code>Reader</code>正确关闭。</p><h2 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h2><p><code>Writer</code>定义了所有字符输出流的超类：</p><ul><li><code>FileWriter</code>实现了文件字符流输出；</li><li><code>CharArrayWriter</code>和<code>StringWriter</code>在内存中模拟一个字符流输出。</li></ul><p>使用<code>try (resource)</code>保证<code>Writer</code>正确关闭。</p><p><code>Writer</code>是基于<code>OutputStream</code>构造的，可以通过<code>OutputStreamWriter</code>将<code>OutputStream</code>转换为<code>Writer</code>，转换时需要指定编码。</p><h2 id="PrintStream和PrintWriter"><a href="#PrintStream和PrintWriter" class="headerlink" title="PrintStream和PrintWriter"></a>PrintStream和PrintWriter</h2><p><code>PrintStream</code>是一种<code>FilterOutputStream</code>，它在<code>OutputStream</code>的接口上，额外提供了一些写入各种数据类型的方法。</p><p><code>PrintStream</code>是一种能接收各种数据类型的输出，打印数据时比较方便：</p><ul><li><code>System.out</code>是标准输出；</li><li><code>System.err</code>是标准错误输出。</li></ul><p><code>PrintWriter</code>是基于<code>Writer</code>的输出。</p><h2 id="使用Files"><a href="#使用Files" class="headerlink" title="使用Files"></a>使用Files</h2><p>对于简单的小文件读写操作，可以使用<code>Files</code>工具类简化代码。</p><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h2><p>现代操作系统（Windows，macOS，Linux）都可以执行多任务。多任务就是同时运行多个任务。例如，让浏览器执行0.001秒，让QQ执行0.001秒，再让音乐播放器执行0.001秒，在人看来，CPU就是在同时执行多个任务。</p><p>在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。某些进程内部还需要同时执行多个子任务。例如，我们在使用Word时，Word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。</p><p>进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。</p><p>Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行<code>main()</code>方法，在<code>main()</code>方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。</p><p>因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用<strong>多线程实现多任务</strong>。</p><p>和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难。</p><p>Java多线程编程的特点又在于：</p><ul><li>多线程模型是Java程序最基本的并发模型；</li><li>后续读写网络、数据库、Web开发等都依赖Java多线程模型。</li></ul><h2 id="创建新线程"><a href="#创建新线程" class="headerlink" title="创建新线程"></a>创建新线程</h2><p>Java用<code>Thread</code>对象表示一个线程，通过调用<code>start()</code>启动一个新线程；</p><p>一个线程对象只能调用一次<code>start()</code>方法；</p><p>线程的执行代码写在<code>run()</code>方法中；</p><p>线程调度由操作系统决定，程序本身无法决定调度顺序；</p><p><code>Thread.sleep()</code>可以把当前线程暂停一段时间。</p><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>Java线程对象<code>Thread</code>的状态包括：<code>New</code>、<code>Runnable</code>、<code>Blocked</code>、<code>Waiting</code>、<code>Timed Waiting</code>和<code>Terminated</code>；</p><p>通过对另一个线程对象调用<code>join()</code>方法可以等待其执行结束；</p><p>可以指定等待时间，超过等待时间线程仍然没有结束就不再等待；</p><p>对已经运行结束的线程调用<code>join()</code>方法会立刻返回。</p><h2 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h2><blockquote><p>如果线程需要执行一个长时间任务，就可能需要能中断线程。</p></blockquote><p>对目标线程调用<code>interrupt()</code>方法可以请求中断一个线程，目标线程通过检测<code>isInterrupted()</code>标志获取自身是否已中断。如果目标线程处于等待状态，该线程会捕获到<code>InterruptedException</code>；</p><p>目标线程检测到<code>isInterrupted()</code>为<code>true</code>或者捕获了<code>InterruptedException</code>都应该立刻结束自身线程；</p><p><code>public volatile boolean running = true;</code>通过标志位判断需要正确使用<code>volatile</code>关键字；</p><p><code>volatile</code>关键字解决的是<strong>可见性</strong>问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。</p><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>Java程序入口就是由JVM启动<code>main</code>线程，<code>main</code>线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束。如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。但是有一种线程的目的就是<strong>无限循环</strong>，例如，一个定时触发任务的线程。如果这个线程不结束，JVM进程就无法结束。</p><p>守护线程（Daemon Thread）是指<strong>为其他线程服务</strong>的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。</p><p>守护线程不能持有需要关闭的资源（如打开文件等）。</p><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>当多个线程同时运行时，线程的调度由<strong>操作系统</strong>决定，程序本身无法决定。因此，任何一个线程都有可能在任何指令处被操作系统暂停，然后在某个时间段后继续执行。</p><p>多线程同时读写共享变量时，会造成逻辑错误，因此需要通过<code>synchronized</code>同步；</p><p>同步的本质就是给指定对象加锁lock，加锁后才能继续执行后续代码；</p><p>注意加锁对象必须是同一个实例；</p><p>对JVM定义的单个原子操作不需要同步。</p><h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><p>用<code>synchronized</code>修饰方法可以把整个方法变为同步代码块，<code>synchronized</code>方法加锁对象是<code>this</code>；</p><p>通过合理的设计和数据封装可以让一个类变为“线程安全”；</p><p>一个类没有特殊说明，默认不是thread-safe；</p><p>多线程能否安全访问某个非线程安全的实例，需要具体问题具体分析。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>Java的<code>synchronized</code>锁是可重入锁；</p><p>死锁产生的条件是多线程各自持有不同的锁，并互相试图获取对方已持有的锁，导致无限等待；</p><p>避免死锁的方法是多线程获取锁的顺序要一致。</p><h2 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h2><p><code>wait</code>和<code>notify</code>用于多线程协调运行：</p><ul><li>在<code>synchronized</code>内部可以调用<code>wait()</code>使线程进入等待状态；</li><li>必须在已获得的锁对象上调用<code>wait()</code>方法；</li><li>在<code>synchronized</code>内部可以调用<code>notify()</code>或<code>notifyAll()</code>唤醒其他等待线程；</li><li>必须在已获得的锁对象上调用<code>notify()</code>或<code>notifyAll()</code>方法；</li><li>已唤醒的线程还需要重新获得锁后才能继续执行。</li></ul><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p><code>ReentrantLock</code>可以替代<code>synchronized</code>进行同步；</p><p><code>ReentrantLock</code>获取锁更安全；</p><p>必须先获取到锁，再进入<code>try {...}</code>代码块，最后使用<code>finally</code>保证释放锁；</p><p>可以使用<code>tryLock()</code>尝试获取锁。</p><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p><code>Condition</code>可以替代<code>wait</code>和<code>notify</code>；</p><p><code>Condition</code>对象必须从<code>Lock</code>对象获取。</p><h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><p>使用<code>ReadWriteLock</code>可以提高读取效率：</p><ul><li><code>ReadWriteLock</code>只允许一个线程写入；</li><li><code>ReadWriteLock</code>允许多个线程在没有写入时同时读取；</li><li><code>ReadWriteLock</code>适合读多写少的场景。</li></ul><h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><p><code>StampedLock</code>和<code>ReadWriteLock</code>相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。</p><p>乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</p><p><code>StampedLock</code>提供了乐观读锁，可取代<code>ReadWriteLock</code>以进一步提升并发性能；</p><p><code>StampedLock</code>是不可重入锁。</p><h2 id="Concurrent集合"><a href="#Concurrent集合" class="headerlink" title="Concurrent集合"></a>Concurrent集合</h2><p>使用<code>java.util.concurrent</code>包提供的线程安全的并发集合可以大大简化多线程编程：</p><p>多线程同时读写并发集合是安全的；</p><p>尽量使用Java标准库提供的并发集合，避免自己编写同步代码。</p><h2 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h2><p>使用<code>java.util.concurrent.atomic</code>提供的原子操作可以简化多线程编程：</p><ul><li>原子操作实现了无锁的线程安全；</li><li>适用于计数器，累加器等。</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>JDK提供了<code>ExecutorService</code>实现了线程池功能：</p><ul><li>线程池内部维护一组线程，可以高效执行大量小任务；</li><li><code>Executors</code>提供了静态方法创建不同类型的<code>ExecutorService</code>；</li><li>必须调用<code>shutdown()</code>关闭<code>ExecutorService</code>；</li><li><code>ScheduledThreadPool</code>可以定期调度多个任务。</li></ul><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>对线程池提交一个<code>Callable</code>任务，可以获得一个<code>Future</code>对象；</p><p>可以用<code>Future</code>在将来某个时刻获取结果。</p><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p><code>CompletableFuture</code>可以指定异步处理流程：</p><ul><li><code>thenAccept()</code>处理正常结果；</li><li><code>exceptional()</code>处理异常结果；</li><li><code>thenApplyAsync()</code>用于串行化另一个<code>CompletableFuture</code>；</li><li><code>anyOf()</code>和<code>allOf()</code>用于并行化多个<code>CompletableFuture</code>。</li></ul><h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>Fork/Join是一种基于“分治”的算法：通过分解任务，并行执行，最后合并结果得到最终结果。</p><p><code>ForkJoinPool</code>线程池可以把一个大任务分拆成小任务并行执行，任务类必须继承自<code>RecursiveTask</code>或<code>RecursiveAction</code>。</p><p>使用Fork/Join模式可以进行并行计算以提高效率。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><code>ThreadLocal</code>表示线程的“局部变量”，它确保每个线程的<code>ThreadLocal</code>变量都是各自独立的；</p><p><code>ThreadLocal</code>适合在一个线程的处理流程中保持上下文（避免了同一参数在所有方法中传递）；</p><p>使用<code>ThreadLocal</code>要用<code>try ... finally</code>结构，并在<code>finally</code>中清除。</p><h1 id="Maven基础"><a href="#Maven基础" class="headerlink" title="Maven基础"></a>Maven基础</h1><p>Maven是一个Java项目管理和构建工具，它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建。</p><h2 id="Maven介绍"><a href="#Maven介绍" class="headerlink" title="Maven介绍"></a>Maven介绍</h2><p>项目结构</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">a-maven-project<br>├── pom.xml  <span class="hljs-comment">// 项目描述文件</span><br>├── src<br>│   ├── main<br>│   │   ├── java  <span class="hljs-comment">// Java源码目录</span><br>│   │   └── <span class="hljs-built_in">resources</span>  <span class="hljs-comment">// 资源文件</span><br>│   └── test<br>│       ├── java  <span class="hljs-comment">// 测试源码</span><br>│       └── <span class="hljs-built_in">resources</span><br>└── target  <span class="hljs-comment">// 所有编译、打包生成的文件都放在target目录里</span><br></code></pre></td></tr></table></figure><p>一个Java项目的管理和构建工具：</p><ul><li>Maven使用<code>pom.xml</code>定义项目内容，并使用预设的目录结构；</li><li>在Maven中声明一个依赖项可以自动下载并导入classpath；</li><li>Maven使用<code>groupId</code>，<code>artifactId</code>和<code>version</code>唯一定位一个依赖。</li></ul><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>Maven通过解析依赖关系确定项目所需的jar包，常用的4种<code>scope</code>有：<code>compile</code>（默认），<code>test</code>，<code>runtime</code>和<code>provided</code>；</p><p>Maven从中央仓库下载所需的jar包并缓存在本地；</p><p>可以通过镜像仓库加速下载。</p><h2 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h2><p>Maven通过lifecycle、phase和goal来提供标准的构建流程。</p><p>最常用的构建命令是指定phase，然后让Maven执行到指定的phase：</p><ul><li>mvn clean</li><li>mvn clean compile</li><li>mvn clean test</li><li>mvn clean package</li></ul><p>通常情况，我们总是执行phase默认绑定的goal，因此不必指定goal。</p><h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p>Maven通过自定义插件可以执行项目构建时需要的额外功能，使用自定义插件必须在pom.xml中声明插件及配置；</p><p>插件会在某个phase被执行时执行；</p><p>插件的配置和用法需参考插件的官方文档。</p><h2 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h2><p>Maven支持模块化管理，可以把一个大项目拆成几个模块：</p><ul><li>可以通过继承在parent的<code>pom.xml</code>统一定义重复配置；</li><li>可以通过<code>&lt;modules&gt;</code>编译多个模块。</li></ul><h2 id="mvnw"><a href="#mvnw" class="headerlink" title="mvnw"></a>mvnw</h2><p>使用Maven Wrapper，可以为一个项目指定特定的Maven版本。</p><h2 id="发布Artifact"><a href="#发布Artifact" class="headerlink" title="发布Artifact"></a>发布Artifact</h2><p>使用Maven发布一个Artifact时：</p><ul><li>可以发布到本地，然后由静态服务器提供repo服务，使用方必须声明repo地址；</li><li>可以发布到<a href="https://central.sonatype.org/" target="_blank" rel="noopener">central.sonatype.org</a>，并自动同步到Maven中央仓库，需要前期申请账号以及本地配置；</li><li>可以发布到GitHub Packages作为私有仓库使用，必须提供Token以及正确的权限才能发布和使用。</li></ul><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="网络编程基础"><a href="#网络编程基础" class="headerlink" title="网络编程基础"></a>网络编程基础</h2><p>计算机网络是指两台或更多的计算机组成的网络，在同一个网络中，任意两台计算机都可以直接通信，因为所有计算机都需要遵循同一种网络协议。</p><p>那什么是互联网呢？互联网是网络的网络（internet），即把很多计算机网络连接起来，形成一个全球统一的互联网。</p><p>因为直接记忆IP地址非常困难，所以我们通常使用域名访问某个特定的服务。域名解析服务器DNS负责把域名翻译成对应的IP，客户端再根据IP地址访问服务器。</p><p>计算机网络的基本概念主要有：</p><ul><li>计算机网络：由两台或更多计算机组成的网络；</li><li>互联网：连接网络的网络；</li><li>IP地址：计算机的网络接口（通常是网卡）在网络中的唯一标识；</li><li>网关：负责连接多个网络，并在多个网络之间转发数据的计算机，通常是路由器或交换机；</li><li>网络协议：互联网使用TCP/IP协议，它泛指互联网协议簇；</li><li>IP协议：一种分组交换传输协议；</li><li>TCP协议：传输控制协议，一种面向连接，可靠传输的协议；</li><li>UDP协议：用户数据报协议，一种无连接，不可靠传输的协议</li></ul><h2 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h2><blockquote><p>为什么需要Socket进行网络通信？</p></blockquote><p>因为仅仅通过IP地址进行通信是不够的，同一台计算机同一时间会运行多个网络应用程序，例如浏览器、QQ、邮件客户端等。当操作系统接收到一个数据包的时候，如果只有IP地址，它没法判断应该发给哪个应用程序，所以，操作系统抽象出Socket接口，每个应用程序需要各自对应到不同的Socket，数据包才能根据Socket正确地发到对应的应用程序。</p><p>一个Socket就是由<strong>IP地址和端口号</strong>（范围是0～65535）组成，可以把Socket简单理解为IP地址加端口号。端口号总是由操作系统分配，它是一个0～65535之间的数字，其中，小于1024的端口属于<em>特权端口</em>，需要管理员权限，大于1024的端口可以由任意用户的应用程序打开。</p><p>使用Java进行TCP编程时，需要使用Socket模型：</p><ul><li>服务器端用<code>ServerSocket</code>监听指定端口；</li><li>客户端使用<code>Socket(InetAddress, port)</code>连接服务器；</li><li>服务器端用<code>accept()</code>接收连接并返回<code>Socket</code>；</li><li>双方通过<code>Socket</code>打开<code>InputStream</code>/<code>OutputStream</code>读写数据；</li><li>服务器端通常使用多线程同时处理多个客户端连接，利用线程池可大幅提升效率；</li><li><code>flush()</code>用于强制输出缓冲区到网络。</li></ul><h2 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h2><p>使用UDP协议通信时，服务器和客户端双方无需建立连接：</p><ul><li>服务器端用<code>DatagramSocket(port)</code>监听端口；</li><li>客户端使用<code>DatagramSocket.connect()</code>指定远程地址和端口；</li><li>双方通过<code>receive()</code>和<code>send()</code>读写数据；</li><li><code>DatagramSocket</code>没有IO流接口，数据被直接写入<code>byte[]</code>缓冲区。</li></ul><h2 id="发生Email"><a href="#发生Email" class="headerlink" title="发生Email"></a>发生Email</h2><p>使用JavaMail API发送邮件本质上是一个MUA(Mail User Agent)软件通过SMTP协议发送邮件至MTA(Mail Transfer Agent)服务器；</p><p>打开调试模式可以看到详细的SMTP交互信息；</p><p>某些邮件服务商需要开启SMTP，并需要独立的SMTP登录密码。</p><h2 id="接收Email"><a href="#接收Email" class="headerlink" title="接收Email"></a>接收Email</h2><p>使用Java接收Email时，可以用POP3协议或IMAP协议。</p><p>使用POP3协议时，需要用Maven引入JavaMail依赖，并确定POP3服务器的域名／端口／是否使用SSL等，然后，调用相关API接收Email。</p><p>设置debug模式可以查看通信详细内容，便于排查错误。</p><h2 id="HTTP编程"><a href="#HTTP编程" class="headerlink" title="HTTP编程"></a>HTTP编程</h2><p>什么是HTTP？HTTP就是目前使用最广泛的Web应用程序使用的基础协议，例如，浏览器访问网站，手机App访问后台服务器，都是通过HTTP协议实现的。</p><p>Java提供了<code>HttpClient</code>作为新的HTTP客户端编程接口用于取代老的<code>HttpURLConnection</code>接口；</p><p><code>HttpClient</code>使用链式调用并通过内置的<code>BodyPublishers</code>和<code>BodyHandlers</code>来更方便地处理数据。</p><h2 id="RMI远程调用"><a href="#RMI远程调用" class="headerlink" title="RMI远程调用"></a>RMI远程调用</h2><p>Java的RMI远程调用是指，一个JVM中的代码可以通过网络实现远程调用另一个JVM的某个方法。RMI是Remote Method Invocation的缩写。</p><p>Java提供了RMI实现远程方法调用：</p><p>RMI通过自动生成stub和skeleton实现网络调用，客户端只需要查找服务并获得接口实例，服务器端只需要编写实现类并注册为服务；</p><p>RMI的序列化和反序列化可能会造成安全漏洞，因此调用双方必须是内网互相信任的机器，不要把1099端口暴露在公网上作为对外服务。</p><h1 id="XML与JSON"><a href="#XML与JSON" class="headerlink" title="XML与JSON"></a>XML与JSON</h1><h2 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a>XML简介</h2><p>XML是可扩展标记语言（eXtensible Markup Language）的缩写，它是是一种数据表示格式，可以描述非常复杂的数据结构，常用于传输和存储数据。</p><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>Java提供的DOM API可以将XML解析为DOM结构，以Document对象表示；</p><p>DOM可在内存中完整表示XML数据结构；</p><p>DOM解析速度慢，内存占用大。</p><h2 id="SAX"><a href="#SAX" class="headerlink" title="SAX"></a>SAX</h2><p>SAX是Simple API for XML的缩写，它是一种基于流的解析方式，边读取XML边解析，并以事件回调的方式让调用者获取数据。因为是一边读一边解析，所以无论XML有多大，占用的内存都很小。</p><p>SAX是一种流式解析XML的API；</p><p>SAX通过事件触发，读取速度快，消耗内存少；</p><p>调用方必须通过回调方法获得解析过程中的数据。</p><h2 id="Jackson"><a href="#Jackson" class="headerlink" title="Jackson"></a>Jackson</h2><p>使用Jackson解析XML，可以直接把XML解析为JavaBean，十分方便。</p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON是JavaScript Object Notation的缩写，它去除了所有JavaScript执行代码，只保留JavaScript的对象格式。</p><p>JSON作为数据传输的格式，有几个显著的优点：</p><ul><li>JSON只允许使用UTF-8编码，不存在编码问题；</li><li>JSON只允许使用双引号作为key，特殊字符用<code>\</code>转义，格式简单；</li><li>浏览器内置JSON支持，如果把数据用JSON发送给浏览器，可以用JavaScript直接处理。</li></ul><p>JSON是轻量级的数据表示方式，常用于Web应用；</p><p>Jackson可以实现JavaBean和JSON之间的转换；</p><p>可以通过Module扩展Jackson能处理的数据类型；</p><p>可以自定义<code>JsonSerializer</code>和<code>JsonDeserializer</code>来定制序列化和反序列化。</p><h1 id="JDBC编程"><a href="#JDBC编程" class="headerlink" title="JDBC编程"></a>JDBC编程</h1><p>Java为关系数据库定义了一套标准的访问接口：JDBC（Java Database Connectivity）</p><h2 id="JDBC简介"><a href="#JDBC简介" class="headerlink" title="JDBC简介"></a>JDBC简介</h2><p>使用JDBC的好处是：</p><ul><li>各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发；</li><li>Java程序编译期仅依赖java.sql包，不依赖具体数据库的jar包；</li><li>可随时替换底层数据库，访问数据库的Java代码基本不变。</li></ul><h2 id="JDBC查询"><a href="#JDBC查询" class="headerlink" title="JDBC查询"></a>JDBC查询</h2><p>JDBC接口的<code>Connection</code>代表一个JDBC连接；</p><p>使用JDBC查询时，总是使用<code>PreparedStatement</code>进行查询而不是<code>Statement</code>；</p><p>查询结果总是<code>ResultSet</code>，即使使用聚合查询也不例外。</p><h2 id="JDBC-更新"><a href="#JDBC-更新" class="headerlink" title="JDBC 更新"></a>JDBC 更新</h2><p>使用JDBC执行<code>INSERT</code>、<code>UPDATE</code>和<code>DELETE</code>都可视为更新操作；</p><p>更新操作使用<code>PreparedStatement</code>的<code>executeUpdate()</code>进行，返回受影响的行数。</p><h2 id="JDBC事务"><a href="#JDBC事务" class="headerlink" title="JDBC事务"></a>JDBC事务</h2><p>数据库事务（Transaction）是由若干个SQL语句构成的一个<strong>操作序列</strong>，有点类似于Java的<code>synchronized</code>同步。数据库系统保证在一个事务中的所有SQL要么<strong>全部</strong>执行成功，要么全部不执行，即数据库事务具有ACID特性：</p><ul><li>Atomicity：原子性</li><li>Consistency：一致性</li><li>Isolation：隔离性</li><li>Durability：持久性</li></ul><p>JDBC提供了事务的支持，使用Connection可以开启、提交或回滚事务。</p><h2 id="JDBC-Batch"><a href="#JDBC-Batch" class="headerlink" title="JDBC Batch"></a>JDBC Batch</h2><p>使用JDBC的batch操作会大大提高执行效率，对内容相同，参数不同的SQL，要优先考虑batch操作。</p><h2 id="JDBC-连接池"><a href="#JDBC-连接池" class="headerlink" title="JDBC 连接池"></a>JDBC 连接池</h2><p>创建线程是一个昂贵的操作，如果有大量的小任务需要执行，并且频繁地创建和销毁线程，实际上会消耗大量的系统资源，往往创建和消耗线程所耗费的时间比执行任务的时间还长，所以，为了提高效率，可以用线程池。</p><p>数据库连接池是一种复用<code>Connection</code>的组件，它可以避免反复创建新连接，提高JDBC代码的运行效率；</p><p>可以配置连接池的详细参数并监控连接池。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Apache配置https</title>
    <link href="/2021/01/19/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Apache%E9%85%8D%E7%BD%AEhttps/"/>
    <url>/2021/01/19/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Apache%E9%85%8D%E7%BD%AEhttps/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><a id="more"></a><h1 id="申请免费DV证书"><a href="#申请免费DV证书" class="headerlink" title="申请免费DV证书"></a>申请免费DV证书</h1><p><a href="https://help.aliyun.com/document_detail/156645.html?spm=a2c4g.11186623.6.606.39605b2eT9S1Na" target="_blank" rel="noopener">阿里云官方文档</a></p><h2 id="申请SSL证书"><a href="#申请SSL证书" class="headerlink" title="申请SSL证书"></a>申请SSL证书</h2><ol><li><p>访问<a href="https://common-buy.aliyun.com/?spm=a2c4g.11186623.2.8.53e14802HoOdmn&commodityCode=cas_dv_public_cn&request={" ord_time":"1:year","order_num":1,"product":"free_product","certcount":"20"}" target="_blank" rel="noopener">证书资源包</a>购买页，领取阿里云免费DV证书。</p></li><li><p>申请免费版SSL证书。</p></li></ol><h2 id="下载证书并上传服务器"><a href="#下载证书并上传服务器" class="headerlink" title="下载证书并上传服务器"></a>下载证书并上传服务器</h2><p><img src="https://img2020.cnblogs.com/blog/1677222/202101/1677222-20210119194324937-2131771008.png" srcset="/img/loading.gif" alt><br>重命名文件chain.crt –&gt; ca.crt, public.crt –&gt; server.key<br>通过XShell上传至服务器，并放在<code>/usr/local/apache2/conf/key</code>下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@ECS key]# pwd<br>/usr/local/apache2/conf/key<br>[root@ECS key]# ls<br>ca.crt  server.crt  server.key<br></code></pre></td></tr></table></figure><h1 id="在Apache服务器上安装SSL证书"><a href="#在Apache服务器上安装SSL证书" class="headerlink" title="在Apache服务器上安装SSL证书"></a>在Apache服务器上安装SSL证书</h1><p><a href="https://help.aliyun.com/document_detail/98727.html?spm=a2c4g.11186623.6.636.53e14802HoOdmn" target="_blank" rel="noopener">阿里云官方文档</a></p><h2 id="配置httpd-conf"><a href="#配置httpd-conf" class="headerlink" title="配置httpd.conf"></a>配置httpd.conf</h2><p><code># vim /usr/local/apache2/conf/httpd.conf</code></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">LoadModule ssl_module modules/mod_ssl.<span class="hljs-keyword">so</span><br><span class="hljs-keyword">Include</span> <span class="hljs-keyword">conf</span>/extra/httpd-ssl.<span class="hljs-keyword">conf</span><br>#<span class="hljs-keyword">Include</span> <span class="hljs-keyword">conf</span>/extra/httpd-ahssl.<span class="hljs-keyword">conf</span><br></code></pre></td></tr></table></figure><h2 id="配置httpd-ssl-conf"><a href="#配置httpd-ssl-conf" class="headerlink" title="配置httpd-ssl.conf"></a>配置httpd-ssl.conf</h2><p><code># vim /usr/local/apache2/conf/extra/httpd-ssl.conf</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-section">&lt;VirtualHost _default_:443&gt;</span><br><span class="hljs-attribute"><span class="hljs-nomarkup">DocumentRoot</span></span> <span class="hljs-string">"/usr/local/apache2/htdocs"</span><br><span class="hljs-attribute"><span class="hljs-nomarkup">ServerName</span></span> www.oeong.com:443 # 域名<br><span class="hljs-attribute">ServerAdmin</span> oeong@foxmail.com # 邮箱<br><span class="hljs-attribute">ErrorLog</span> <span class="hljs-string">"/usr/local/apache2/logs/error_log"</span><br><span class="hljs-attribute">TransferLog</span> <span class="hljs-string">"/usr/local/apache2/logs/access_log"</span><br><br><span class="hljs-attribute">SSLCertificateFile</span> <span class="hljs-string">"/usr/local/apache2/conf/key/server.crt"</span><br><span class="hljs-attribute">SSLCertificateKeyFile</span> <span class="hljs-string">"/usr/local/apache2/conf/key/server.key"</span><br><span class="hljs-attribute">SSLCertificateChainFile</span> <span class="hljs-string">"/usr/local/apache2/conf/key/ca.crt"</span><br><br><span class="hljs-attribute">SSLEngine</span> <span class="hljs-literal">on</span><br></code></pre></td></tr></table></figure><h2 id="重启Apache"><a href="#重启Apache" class="headerlink" title="重启Apache"></a>重启Apache</h2><p><code>[root@ECS conf]# /usr/local/apache2/bin/apachectl restart</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>HTTPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL学习笔记</title>
    <link href="/2020/05/26/SQL_notes/"/>
    <url>/2020/05/26/SQL_notes/</url>
    
    <content type="html"><![CDATA[<p>学习<a href="https://www.liaoxuefeng.com/wiki/1177760294764384" target="_blank" rel="noopener">廖雪峰的SQL教程</a>所做笔记。</p><a id="more"></a><h2 id="关系数据库概述"><a href="#关系数据库概述" class="headerlink" title="关系数据库概述"></a>关系数据库概述</h2><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>什么是SQL？SQL是<strong>结构化查询语言</strong>的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还可以对数据库进行管理和维护操作。不同的数据库，都支持SQL，这样，我们通过学习SQL这一种语言，就可以操作各种不同的数据库。</p><p>本教程约定：<strong>SQL关键字总是大写，以示突出，表名和列名均使用小写</strong>。</p><h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><p>表的每一行称为记录（Record），记录是一个逻辑意义上的数据。<br>表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。</p><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>主键是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。主键也不应该允许<code>NULL</code>。</p><p>可以使用多个列作为联合主键，但联合主键并不常用。</p><h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，<code>class_id</code>仅仅是一个普通的列，只是它起到了外键的作用而已。</p><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。</p><p>一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表<code>user_info</code>和用户详细信息表<code>user_profiles</code>，大部分时候，只需要查询<code>user_info</code>表，并不需要查询<code>user_profiles</code>表，这样就提高了查询速度。</p><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>通过一个表的外键关联到另一个表，我们可以定义出一对多关系。</p><p>例如，一个老师可以对应多个班级，一个班级也可以对应多个老师，因此，班级表和老师表存在多对多关系。</p><p>多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。</p><p>索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。</p><p>如果要经常根据<code>score</code>列进行查询，就可以对<code>score</code>列创建索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> students<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">INDEX</span> idx_score (score);<br></code></pre></td></tr></table></figure><p>索引的效率取决于索引列的值是否散列，即该<strong>列的值如果越互不相同，那么索引效率越高</strong>。反过来，如果记录的列存在大量相同的值，例如<code>gender</code>列，大约一半的记录值是<code>M</code>，另一半是<code>F</code>，因此，对该列创建索引就没有意义。</p><p>可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是<strong>在插入、更新和删除记录时，需要同时修改索引</strong>，因此，索引越多，插入、更新和删除记录的速度就越慢。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>通过对数据库表创建索引，可以提高查询速度。</p><p>通过创建唯一索引，可以保证某一列的值具有唯一性。</p><p>数据库索引对于用户和应用程序来说都是透明的。</p><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><h3 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h3><p>使用SELECT查询的基本语句SELECT * FROM &lt;表名&gt;可以查询一个表的所有行和所有列的数据。</p><p>SELECT查询的结果是一个二维表。</p><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>通过<code>WHERE</code>条件查询，可以筛选出符合指定条件的记录，而不是整个表的所有记录。</p><h3 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h3><p>使用<code>SELECT *</code>表示查询表的所有列，使用<code>SELECT 列1, 列2, 列3</code>则可以仅返回指定列，这种操作称为投影。</p><p>SELECT语句可以对结果集的列进行重命名。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>使用<code>ORDER BY</code>可以对结果集进行排序；</p><p>可以对多列进行升序、倒序排序。</p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>使用<code>LIMIT  OFFSET</code>可以对结果集进行分页，每次查询返回结果集的一部分；</p><p>分页查询需要先确定每页的数量和当前页数，然后确定<code>LIMIT</code>和<code>OFFSET</code>的值。</p><h3 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h3><p>使用SQL提供的聚合查询，我们可以方便地计算总数、合计值、平均值、最大值和最小值；</p><p>聚合查询也可以添加WHERE条件。</p><h2 id="TO-BE-CONTINUED…"><a href="#TO-BE-CONTINUED…" class="headerlink" title="TO BE CONTINUED…"></a>TO BE CONTINUED…</h2>]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建网站时遇到的问题与解决方案</title>
    <link href="/2020/04/02/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2020/04/02/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>前车之鉴，后事之师。</p><a id="more"></a><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="CentOS7安装LAMP"><a href="#CentOS7安装LAMP" class="headerlink" title="CentOS7安装LAMP"></a>CentOS7安装LAMP</h2><p><a href="https://help.aliyun.com/document_detail/50774.html?spm=5176.11065259.1996646101.searchclickresult.65fe1a5640ehqG" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/50774.html?spm=5176.11065259.1996646101.searchclickresult.65fe1a5640ehqG</a></p><h3 id="安装apache"><a href="#安装apache" class="headerlink" title="安装apache"></a>安装apache</h3><p><a href="https://blog.csdn.net/u012965203/article/details/94134619" target="_blank" rel="noopener">https://blog.csdn.net/u012965203/article/details/94134619</a></p><h2 id="Linux下安装anaconda"><a href="#Linux下安装anaconda" class="headerlink" title="Linux下安装anaconda"></a>Linux下安装anaconda</h2><p><a href="https://blog.csdn.net/zaishijizhidian/article/details/81663387" target="_blank" rel="noopener">https://blog.csdn.net/zaishijizhidian/article/details/81663387</a></p><h2 id="apache配置https"><a href="#apache配置https" class="headerlink" title="apache配置https"></a>apache配置https</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@ECS key]# pwd<br>/usr/local/apache2/conf/key<br>[root@ECS key]# vim ../extra/httpd-ssl.conf<br>/usr/local/apache2/bin/apachectl restart 重启<br></code></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/63c748bad09e" target="_blank" rel="noopener">https://www.jianshu.com/p/63c748bad09e</a><br><a href="https://blog.csdn.net/qq_36431166/article/details/98631352?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/qq_36431166/article/details/98631352?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h3 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h3><p>[root@ECS ~]# mysql -u root -p    // 进入数据库<br>mysql&gt; set password for root@localhost = password(‘&lt;密码&gt;’);<br>mysql&gt; show databases;    // 显示数据库<br>mysql&gt; use &lt;数据库名&gt;;    // 选择数据库<br>mysql&gt; create database &lt;数据库名&gt;;    // 创建数据库<br>mysql&gt; drop database &lt;数据库名&gt;;    // 删除数据库</p><p>// 创建数据表<br>mysql&gt; create table &lt;数据表名&gt;(<br>    -&gt; id int not null auto_increment,<br>    -&gt; primary key(id)<br>    -&gt; )ENGINE=InnoDB DEFAULT CHARSET=utf8;<br>mysql&gt; drop table &lt;数据表名&gt;;</p><h3 id="ThinkPHP查询数据库时各种条件设置"><a href="#ThinkPHP查询数据库时各种条件设置" class="headerlink" title="ThinkPHP查询数据库时各种条件设置"></a>ThinkPHP查询数据库时各种条件设置</h3><p><a href="https://blog.csdn.net/yexudengzhidao/article/details/54943510" target="_blank" rel="noopener">https://blog.csdn.net/yexudengzhidao/article/details/54943510</a></p><h3 id="MySQL中将日期和时间从日期时间中分离出来"><a href="#MySQL中将日期和时间从日期时间中分离出来" class="headerlink" title="MySQL中将日期和时间从日期时间中分离出来"></a>MySQL中将日期和时间从日期时间中分离出来</h3><p><a href="https://cloud.tencent.com/developer/ask/66839" target="_blank" rel="noopener">https://cloud.tencent.com/developer/ask/66839</a><br><code>select DATE(dateTimeFeild) as Date, TIME(dateTimeFeild) as Time, col2, col3, FROM Table1 ...</code></p><h3 id="mysql查询特定时间段内的数据"><a href="#mysql查询特定时间段内的数据" class="headerlink" title="mysql查询特定时间段内的数据"></a>mysql查询特定时间段内的数据</h3><p><a href="https://blog.csdn.net/EightSwords/article/details/79702101" target="_blank" rel="noopener">https://blog.csdn.net/EightSwords/article/details/79702101</a><br>– 今天<br>select fullName,addedTime from t_user where to_days(addedTime) = to_days(now());   </p><h1 id="ThinkPHP"><a href="#ThinkPHP" class="headerlink" title="ThinkPHP"></a>ThinkPHP</h1><h2 id="php部署问题"><a href="#php部署问题" class="headerlink" title="php部署问题"></a>php部署问题</h2><p>php项目部署到服务器上，无需改ip地址的配置，还是127.0.0.1<br>在Loginout.php中要写入自己的ip</p><h3 id="failed-to-open-stream-Permission-denied-in-错误的解决方法"><a href="#failed-to-open-stream-Permission-denied-in-错误的解决方法" class="headerlink" title="failed to open stream:Permission denied in 错误的解决方法"></a>failed to open stream:Permission denied in 错误的解决方法</h3><p>给runtime以其下面的文件写权限</p><h3 id="Thinkphp5开启调试模式"><a href="#Thinkphp5开启调试模式" class="headerlink" title="Thinkphp5开启调试模式"></a>Thinkphp5开启调试模式</h3><p>在application/config.php中把调试模式改为true</p><h3 id="重定向和跳转要继承Controller"><a href="#重定向和跳转要继承Controller" class="headerlink" title="重定向和跳转要继承Controller"></a>重定向和跳转要继承Controller</h3><h2 id="mkdir-Permission-denied"><a href="#mkdir-Permission-denied" class="headerlink" title="mkdir() Permission denied"></a>mkdir() Permission denied</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 查看apache的用户和用户组<br>[root@ECS tp5]# ps aux | grep apache <br>[root@ECS htdocs]# chown -R daemon tp5/<br>[root@ECS htdocs]# chgrp -R daemon tp5/<br>[root@ECS tp5]# chmod -R 777 runtime/<br></code></pre></td></tr></table></figure><h2 id="thinkphp-中html标签加载js-css-img-script的路径问题"><a href="#thinkphp-中html标签加载js-css-img-script的路径问题" class="headerlink" title="thinkphp 中html标签加载js,css,img,script的路径问题"></a>thinkphp 中html标签加载js,css,img,script的路径问题</h2><p>在thinkphp中，路径中不能用”../“表示上一级，而是用正斜杠”/“表示项目根目录<br>D:\phpstudy_pro\WWW\oeong.demo\tp5\public\js\index.js<br>引用<code>&lt;script src=&quot;/tp5/public/js/index.js&quot;&gt;&lt;/script&gt;</code><br><a href="https://blog.csdn.net/luguo0816/article/details/7192482?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/luguo0816/article/details/7192482?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p><h2 id="thinkphp-更换跳转模板"><a href="#thinkphp-更换跳转模板" class="headerlink" title="thinkphp 更换跳转模板"></a>thinkphp 更换跳转模板</h2><p><a href="https://www.cnblogs.com/wenhainan/p/7481723.html" target="_blank" rel="noopener">https://www.cnblogs.com/wenhainan/p/7481723.html</a></p><h2 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h2><p><a href="https://blog.csdn.net/yexudengzhidao/article/details/54943510" target="_blank" rel="noopener">https://blog.csdn.net/yexudengzhidao/article/details/54943510</a></p><p>如果是mac或者linux环境，请确保runtime目录有可写权限</p><p>上面的目录结构和名称是可以改变的，尤其是应用的目录结构，这取决于你的入口文件和配置参数。</p><h2 id="Form-提交表单的时候-避免跳转页面"><a href="#Form-提交表单的时候-避免跳转页面" class="headerlink" title="Form 提交表单的时候 避免跳转页面"></a>Form 提交表单的时候 避免跳转页面</h2><ol><li>target参数、iframe<br><a href="https://blog.csdn.net/h2503652646/article/details/86634345" target="_blank" rel="noopener">https://blog.csdn.net/h2503652646/article/details/86634345</a></li><li>重定向<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">use</span> \<span class="hljs-title">think</span>\<span class="hljs-title">Controller</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> *** <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>&#123; <br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">$this</span>-&gt;redirect(<span class="hljs-string">"http://localhost:8080/tp5/public/index.php"</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>在vi中可以通过:/xxx进行搜索定位，n键查找下一项<br>创建软链接 <code>ln -s  &lt; source&gt;  &lt;target&gt;</code><br>cd - 返回上一次目录<br>在 /usr/local/apache2/conf/httpd.conf中找到User<br><code>chown -R &lt;user&gt;:&lt;group&gt; *</code></p><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><h2 id="下拉框设置默认值"><a href="#下拉框设置默认值" class="headerlink" title="下拉框设置默认值"></a>下拉框设置默认值</h2><p><a href="https://blog.csdn.net/qq_37117258/article/details/100551443" target="_blank" rel="noopener">https://blog.csdn.net/qq_37117258/article/details/100551443</a></p><h2 id="屏蔽广告"><a href="#屏蔽广告" class="headerlink" title="屏蔽广告"></a>屏蔽广告</h2><p>找到广告所在的div</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">#&lt;<span class="hljs-selector-tag">idname</span>&gt; &#123;<br>    <span class="hljs-attribute">display</span>: none;<br>    <span class="hljs-attribute">visibility</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="js实现点击后改变一个css"><a href="#js实现点击后改变一个css" class="headerlink" title="js实现点击后改变一个css"></a>js实现点击后改变一个css</h2><p>document.getElementById(“tbl”).className = “click”;<br>.click, td, th{border: 1px solid black;}</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>VScode格式化代码<br>Shift + Alt + F</p><h2 id="函数和类、属性命名"><a href="#函数和类、属性命名" class="headerlink" title="函数和类、属性命名"></a>函数和类、属性命名</h2><p><strong>类</strong>的命名采用驼峰法（首字母大写），例如 User、UserType，默认不需要添加后缀，例如UserController应该直接命名为User；<br><strong>函数</strong>的命名使用小写字母和下划线（小写字母开头）的方式，例如 get_client_ip；<br><strong>方法</strong>的命名使用驼峰法（首字母小写），例如 getUserName；<br><strong>属性</strong>的命名使用驼峰法（首字母小写），例如 tableName、instance；<br>以双下划线“__”打头的函数或方法作为魔术方法，例如 __call 和 __autoload；</p><h2 id="云服务器ECS与轻量应用服务器的区别"><a href="#云服务器ECS与轻量应用服务器的区别" class="headerlink" title="云服务器ECS与轻量应用服务器的区别"></a>云服务器ECS与轻量应用服务器的区别</h2><ul><li>云服务器ECS（Elastic Compute Service）是一种简单高效、处理能力可弹性伸缩的计算服务。帮助您构建更稳定、安全的应用，提升运维效率，降低IT成本，使您更专注于核心业务创新。</li><li>轻量应用服务器是面向单机应用场景的新一代计算服务，提供应用一键部署、一站式域名解析、网站发布、安全、运维、应用管理等服务。极大地优化了搭建简单应用的体验，降低了入门级用户使用云计算产品的门槛。</li></ul><p>阿里云ECS学生机配置：CPU1核、内存2GB、带宽1Mbps</p>]]></content>
    
    
    <categories>
      
      <category>WebSite</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ThinkPHP</tag>
      
      <tag>Linux</tag>
      
      <tag>WebSite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThinkPHP5.0</title>
    <link href="/2020/04/02/PHP/ThinkPHP5-0/"/>
    <url>/2020/04/02/PHP/ThinkPHP5-0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.kancloud.cn/manual/thinkphp5/118003" target="_blank" rel="noopener">ThinkPHP5.0官方手册</a></p><a id="more"></a><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>ThinkPHP是一个免费开源的，快速、简单的面向对象的轻量级PHP开发框架，是为了敏捷WEB应用开发和简化企业应用开发而诞生的。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h3><p>函数和类、属性命名</p><ul><li>类的命名采用驼峰法（首字母大写），例如 User、UserType，默认不需要添加后缀，例如UserController应该直接命名为User；</li><li>函数的命名使用小写字母和下划线（小写字母开头）的方式，例如 get_client_ip；</li><li>方法的命名使用驼峰法（首字母小写），例如 getUserName；</li><li>属性的命名使用驼峰法（首字母小写），例如 tableName、instance；</li><li>以双下划线“__”打头的函数或方法作为魔术方法，例如 __call 和 <em>\</em>autoload；</li></ul><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>如果是mac或者linux环境，请确保<code>runtime</code>目录有可写权限<br>目录结构和名称是可以改变的，尤其是应用的目录结构，这取决于你的入口文件和配置参数。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="架构总览"><a href="#架构总览" class="headerlink" title="架构总览"></a>架构总览</h3><p>ThinkPHP5.0应用基于MVC（模型-视图-控制器）的方式来组织。</p><h4 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h4><p>用户请求的PHP文件，负责处理一个请求（注意，不一定是URL请求）的生命周期，最常见的入口文件就是<code>index.php</code></p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>应用在ThinkPHP中是一个<strong>管理系统架构及生命周期的对象</strong>，由系统的 \think\App类完成，应用通常在入口文件中被调用和执行</p><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><p>每个模块拥有独立的MVC类库及配置文件，一个模块下面有多个控制器负责响应请求，而每个控制器其实就是一个独立的控制器类。</p><p>控制器主要负责请求的接收，并调用相关的模型处理，并最终通过视图输出。</p><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><p>模型类通常完成实际的业务逻辑和数据封装，并返回和格式无关的数据。</p><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>控制器调用模型类后返回的数据通过视图组装成不同格式的输出。视图根据不同的需求，来决定调用模板引擎进行内容解析后输出还是直接输出。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="入口文件-1"><a href="#入口文件-1" class="headerlink" title="入口文件"></a>入口文件</h4><p>用户发起的请求都会经过应用的入口文件，通常是 public/index.php文件。</p><h4 id="引导文件"><a href="#引导文件" class="headerlink" title="引导文件"></a>引导文件</h4><h4 id="URL访问检测"><a href="#URL访问检测" class="headerlink" title="URL访问检测"></a>URL访问检测</h4><p>应用初始化完成后，就会进行URL的访问检测，包括PATH_INFO检测和URL后缀检测。</p><h3 id="入口文件-2"><a href="#入口文件-2" class="headerlink" title="入口文件"></a>入口文件</h3><p>入口文件位置的设计是为了让应用部署更安全，public目录为web可访问目录，其他的文件都可以放到非WEB访问目录下面。</p><h3 id="URL访问"><a href="#URL访问" class="headerlink" title="URL访问"></a>URL访问</h3><p>ThinkPHP5.0在没有启用路由的情况下典型的URL访问规则是：<br><code>http://serverName/index.php（或者其它应用入口文件）/模块/控制器/操作/[参数名/参数值...]</code></p><h3 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h3><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>路由的作用是简化URL访问地址，并根据定义的路由类型做出正确的解析。</p><h3 id="域名路由"><a href="#域名路由" class="headerlink" title="域名路由"></a>域名路由</h3><p>ThinkPHP支持完整域名、子域名和IP部署的路由和绑定功能，同时还可以起到简化URL的作用。</p><h2 id="控制器-1"><a href="#控制器-1" class="headerlink" title="控制器"></a>控制器</h2><h3 id="控制器定义"><a href="#控制器定义" class="headerlink" title="控制器定义"></a>控制器定义</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">namespace</span> <span class="hljs-title">app</span>\<span class="hljs-title">index</span>\<span class="hljs-title">controller</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <br></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">index</span><span class="hljs-params">()</span><br>    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">'index'</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>控制器类文件的实际位置是<code>application\index\controller\Index.php</code></p><h3 id="控制器初始化"><a href="#控制器初始化" class="headerlink" title="控制器初始化"></a>控制器初始化</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">namespace</span> <span class="hljs-title">app</span>\<span class="hljs-title">index</span>\<span class="hljs-title">controller</span>;<br><br><span class="hljs-keyword">use</span> <span class="hljs-title">think</span>\<span class="hljs-title">Controller</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span><br></span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_initialize</span><span class="hljs-params">()</span><br>    </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">'init&lt;br/&gt;'</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span><br>    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">'hello'</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果访问<code>http://localhost/index.php/index/Index/hello</code><br>会输出</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-attribute">init<br>hello</span><br></code></pre></td></tr></table></figure><h3 id="前置操作"><a href="#前置操作" class="headerlink" title="前置操作"></a>前置操作</h3><h3 id="跳转和重定向"><a href="#跳转和重定向" class="headerlink" title="跳转和重定向"></a>跳转和重定向</h3><blockquote><p>重定向和跳转要继承Controller</p></blockquote><h4 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h4><p>系统的\think\Controller类内置了两个跳转方法<code>success</code>和<code>error</code>，用于页面跳转提示。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span> ($result) &#123;<br>    <span class="hljs-comment">//设置成功后跳转页面的地址，默认的返回页面是$_SERVER['HTTP_REFERER']</span><br>    <span class="hljs-keyword">$this</span>-&gt;success(<span class="hljs-string">'新增成功'</span>, <span class="hljs-string">'User/list'</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//错误页面的默认跳转页面是返回前一页，通常不需要设置</span><br>    <span class="hljs-keyword">$this</span>-&gt;error(<span class="hljs-string">'新增失败'</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>\think\Controller类的redirect方法可以实现页面的重定向功能。<br>$this-&gt;redirect(“<a href="http://localhost:8080/tp5/public/index.php&quot;" target="_blank" rel="noopener">http://localhost:8080/tp5/public/index.php&quot;</a>);</p><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><h3 id="请求信息"><a href="#请求信息" class="headerlink" title="请求信息"></a>请求信息</h3><p>如果要获取当前的请求信息，可以使用\think\Request类<br><code>$request = Request::instance();</code><br>或助手函数<code>$request = request();</code></p><h3 id="输入变量"><a href="#输入变量" class="headerlink" title="输入变量"></a>输入变量</h3><h4 id="获取POST变量"><a href="#获取POST变量" class="headerlink" title="获取POST变量"></a>获取POST变量</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">Request::instance()-&gt;post(<span class="hljs-string">'name'</span>); <span class="hljs-comment">// 获取某个post变量</span><br>Request::instance()-&gt;post(); <span class="hljs-comment">// 获取经过过滤的全部post变量</span><br></code></pre></td></tr></table></figure><h4 id="获取SESSION变量"><a href="#获取SESSION变量" class="headerlink" title="获取SESSION变量"></a>获取SESSION变量</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">Request::instance()-&gt;session(<span class="hljs-string">'user_id'</span>); <span class="hljs-comment">// 获取某个session变量</span><br>Request::instance()-&gt;session(); <span class="hljs-comment">// 获取全部的session变量</span><br></code></pre></td></tr></table></figure><h4 id="获取Cookie变量"><a href="#获取Cookie变量" class="headerlink" title="获取Cookie变量"></a>获取Cookie变量</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">Request::instance()-&gt;cookie(<span class="hljs-string">'user_id'</span>); <span class="hljs-comment">// 获取某个cookie变量</span><br>Request::instance()-&gt;cookie(); <span class="hljs-comment">// 获取全部的cookie变量</span><br></code></pre></td></tr></table></figure><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>支持query（查询操作）和execute（写入操作）方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">Db::query(<span class="hljs-string">'select * from think_user where id=?'</span>,[<span class="hljs-number">8</span>]);<br>Db::execute(<span class="hljs-string">'insert into think_user (id, name) values (?, ?)'</span>,[<span class="hljs-number">8</span>,<span class="hljs-string">'thinkphp'</span>]);<br></code></pre></td></tr></table></figure><h3 id="查询构造器"><a href="#查询构造器" class="headerlink" title="查询构造器"></a>查询构造器</h3><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><p>查询一个数据使用：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// table方法必须指定完整的数据表名</span><br>Db::table(<span class="hljs-string">'think_user'</span>)-&gt;where(<span class="hljs-string">'id'</span>,<span class="hljs-number">1</span>)-&gt;find();<br></code></pre></td></tr></table></figure><p>查询数据集使用：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">Db::table(<span class="hljs-string">'think_user'</span>)-&gt;where(<span class="hljs-string">'status'</span>,<span class="hljs-number">1</span>)-&gt;select();<br></code></pre></td></tr></table></figure><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><p>添加一条数据</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">$data = [<span class="hljs-string">'foo'</span> =&gt; <span class="hljs-string">'bar'</span>, <span class="hljs-string">'bar'</span> =&gt; <span class="hljs-string">'foo'</span>];<br>Db::table(<span class="hljs-string">'think_user'</span>)-&gt;insert($data);<br></code></pre></td></tr></table></figure><p>添加多条数据</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php">$data = [<br>    [<span class="hljs-string">'foo'</span> =&gt; <span class="hljs-string">'bar'</span>, <span class="hljs-string">'bar'</span> =&gt; <span class="hljs-string">'foo'</span>],<br>    [<span class="hljs-string">'foo'</span> =&gt; <span class="hljs-string">'bar1'</span>, <span class="hljs-string">'bar'</span> =&gt; <span class="hljs-string">'foo1'</span>],<br>    [<span class="hljs-string">'foo'</span> =&gt; <span class="hljs-string">'bar2'</span>, <span class="hljs-string">'bar'</span> =&gt; <span class="hljs-string">'foo2'</span>]<br>];<br>Db::name(<span class="hljs-string">'user'</span>)-&gt;insertAll($data);<br></code></pre></td></tr></table></figure><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><p><code>Db::table(&#39;think_user&#39;)-&gt;where(&#39;id&#39;, 1)-&gt;update([&#39;name&#39; =&gt; &#39;thinkphp&#39;]);</code></p><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 根据主键删除</span><br>Db::table(<span class="hljs-string">'think_user'</span>)-&gt;delete(<span class="hljs-number">1</span>);<br>Db::table(<span class="hljs-string">'think_user'</span>)-&gt;delete([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);<br><br><span class="hljs-comment">// 条件删除    </span><br>Db::table(<span class="hljs-string">'think_user'</span>)-&gt;where(<span class="hljs-string">'id'</span>,<span class="hljs-number">1</span>)-&gt;delete();<br>Db::table(<span class="hljs-string">'think_user'</span>)-&gt;where(<span class="hljs-string">'id'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-number">10</span>)-&gt;delete();<br></code></pre></td></tr></table></figure><h2 id="视图-1"><a href="#视图-1" class="headerlink" title="视图"></a>视图</h2><p>继承\think\Controller类</p><h3 id="模板渲染"><a href="#模板渲染" class="headerlink" title="模板渲染"></a>模板渲染</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 不带任何参数 自动定位当前操作的模板文件</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;fetch();<br></code></pre></td></tr></table></figure><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="包含文件"><a href="#包含文件" class="headerlink" title="包含文件"></a>包含文件</h3><p>{include file=’模版文件1,模版文件2,…’ /}</p><h3 id="内置标签"><a href="#内置标签" class="headerlink" title="内置标签"></a>内置标签</h3><p>volist标签通常用于查询数据集（select方法）的结果输出，通常模型的select方法返回的结果是一个二维数组，可以直接使用volist标签进行输出。</p><h3 id="资源文件加载"><a href="#资源文件加载" class="headerlink" title="资源文件加载"></a>资源文件加载</h3><p>传统方式的导入外部JS和CSS文件的方法是直接在模板文件使用：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">&lt;script type=<span class="hljs-string">'text/javascript'</span> src=<span class="hljs-string">'/static/js/common.js'</span>&gt;<br>&lt;link rel=<span class="hljs-string">"stylesheet"</span> type=<span class="hljs-string">"text/css"</span> href=<span class="hljs-string">"/static/css/style.css"</span> /&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP</tag>
      
      <tag>ThinkPHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP学习笔记</title>
    <link href="/2020/03/15/PHP/PHP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/03/15/PHP/PHP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>学习<a href="https://www.runoob.com/php/php-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a>所做的PHP笔记。</p><a id="more"></a><h1 id="PHP基础"><a href="#PHP基础" class="headerlink" title="PHP基础"></a>PHP基础</h1><h2 id="PHP简介"><a href="#PHP简介" class="headerlink" title="PHP简介"></a>PHP简介</h2><p>PHP（全称：PHP：Hypertext Preprocessor，即”PHP：超文本预处理器”）是一种通用开源脚本语言。<br>PHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器。</p><h3 id="PHP能做什么？"><a href="#PHP能做什么？" class="headerlink" title="PHP能做什么？"></a>PHP能做什么？</h3><ul><li>PHP 可以生成动态页面内容</li><li>PHP 可以收集表单数据</li><li>PHP 可以添加、删除、修改您的数据库中的数据</li></ul><h2 id="PHP语法"><a href="#PHP语法" class="headerlink" title="PHP语法"></a>PHP语法</h2><p>PHP 脚本以 <?php 开始，以 ?> 结束。<br>PHP 中的每个代码行都必须以分号结束。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">"Hello World!"</span>;<br><span class="hljs-meta">?&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="PHP语法-1"><a href="#PHP语法-1" class="headerlink" title="PHP语法"></a>PHP语法</h2><ol><li>定义在函数外部的就是全局变量，它的作用域从定义处一直到文件结尾。</li><li>函数内定义的变量就是局部变量，它的作用域为函数定义范围内。</li><li>函数之间存在作用域互不影响。</li><li>函数内访问全局变量需要 <code>global</code> 关键字或者使用 <code>$GLOBALS[index]</code> 数组</li><li><code>static</code> 关键字使某个局部变量不被删除。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="php"><span class="hljs-meta">&lt;?php</span><br>$x=<span class="hljs-number">5</span>;<br>$y=<span class="hljs-number">10</span>;<br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myTest</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">global</span> $x,$y;<br>    $y=$x+$y;<br>&#125;<br> <br>myTest();<br><span class="hljs-keyword">echo</span> $y; <span class="hljs-comment">// 输出 15</span><br><span class="hljs-meta">?&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="echo-和-print-语句"><a href="#echo-和-print-语句" class="headerlink" title="echo 和 print 语句"></a>echo 和 print 语句</h2><h2 id="EOF-heredoc-使用说明"><a href="#EOF-heredoc-使用说明" class="headerlink" title="EOF(heredoc) 使用说明"></a>EOF(heredoc) 使用说明</h2><p>PHP 定界符<code>EOF</code> 中是会解析 html 格式内容的，并且在双引号内的内容也有转义效果。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="php"><span class="hljs-meta">&lt;?php</span><br>$name=<span class="hljs-string">"runoob"</span>;<br>$a= <span class="hljs-string">&lt;&lt;&lt;EOF<br>&lt;h1&gt;EOF&lt;/h1&gt;<br>        "abc"<span class="hljs-subst">$name</span><br>        "123"<br>EOF;</span><br><span class="hljs-comment">// 结束需要独立一行且前后不能空格</span><br><span class="hljs-keyword">echo</span> $a;<br><span class="hljs-meta">?&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><code>var_dump()</code> 函数返回变量的数据类型和值</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="php"><span class="hljs-meta">&lt;?php</span><br>$cars=<span class="hljs-keyword">array</span>(<span class="hljs-string">"Volvo"</span>,<span class="hljs-string">"BMW"</span>,<span class="hljs-string">"Toyota"</span>); <span class="hljs-comment">// 数组</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> $color;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span><span class="hljs-params">($color=<span class="hljs-string">"green"</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">$this</span>-&gt;color = $color;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">what_color</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;color;<br>  &#125;<br>&#125;<br><span class="hljs-meta">?&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="类型比较"><a href="#类型比较" class="headerlink" title="类型比较"></a>类型比较</h2><ul><li>松散比较：使用两个等号 == 比较，只比较值，不比较类型。</li><li>严格比较：用三个等号 === 比较，除了比较值，也比较类型。</li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量值被定义后，在脚本的其他任何地方都不能被改变。<br>bool define ( string $name , mixed $value [, bool $case_insensitive = false ] )</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// true 不区分大小写的常量名</span><br>define(<span class="hljs-string">"GREETING"</span>, <span class="hljs-string">"欢迎"</span>, <span class="hljs-keyword">true</span>);<br><span class="hljs-keyword">echo</span> greeting;  <span class="hljs-comment">// 输出 "欢迎"</span><br><span class="hljs-meta">?&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="字符串变量"><a href="#字符串变量" class="headerlink" title="字符串变量"></a>字符串变量</h2><p>*<em>并置运算符 *</em>(.) 用于把两个字符串值连接起来。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="php"><span class="hljs-meta">&lt;?php</span><br>$txt1=<span class="hljs-string">"Hello world!"</span>;<br>$txt2=<span class="hljs-string">"What a nice day!"</span>;<br><span class="hljs-keyword">echo</span> $txt1 . <span class="hljs-string">" "</span> . $txt2;<br><span class="hljs-meta">?&gt;</span></span><br></code></pre></td></tr></table></figure><p>strlen() 函数返回字符串的长度（字节数）。</p><p>strpos() 函数用于在字符串内查找一个字符或一段指定的文本。<br><code>echo strpos(&quot;Hello world!&quot;,&quot;world&quot;);</code></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>运算符优先级中，or 和 ||，&amp;&amp; 和 and 都是逻辑运算符，效果一样，但是其优先级却不一样。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?php<br>// 优先级： &amp;&amp;  &gt;  =  &gt;  <span class="hljs-keyword">and</span><br>// 优先级： ||  &gt;  =  &gt;  <span class="hljs-keyword">or</span><br> <br><span class="hljs-variable">$a</span> = <span class="hljs-number">3</span>;<br><span class="hljs-variable">$b</span> =<span class="hljs-built_in"> false</span>;<br><span class="hljs-variable">$c</span> = <span class="hljs-variable">$a</span> <span class="hljs-keyword">or</span> <span class="hljs-variable">$b</span>;<br>var_dump(<span class="hljs-variable">$c</span>);          // 这里的 <span class="hljs-variable">$c</span> 为 int 值<span class="hljs-number">3</span>，而不是<span class="hljs-built_in"> boolean</span> 值<span class="hljs-built_in"> true</span><br><span class="hljs-variable">$d</span> = <span class="hljs-variable">$a</span> || <span class="hljs-variable">$b</span>;<br>var_dump(<span class="hljs-variable">$d</span>);          //这里的 <span class="hljs-variable">$d</span> 就是<span class="hljs-built_in"> boolean</span> 值<span class="hljs-built_in"> true</span> <br>?&gt;<br></code></pre></td></tr></table></figure><h2 id="If…Else"><a href="#If…Else" class="headerlink" title="If…Else"></a>If…Else</h2><h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="php"><span class="hljs-meta">&lt;?php</span><br>$cars=<span class="hljs-keyword">array</span>(<span class="hljs-string">"Volvo"</span>,<span class="hljs-string">"BMW"</span>,<span class="hljs-string">"Toyota"</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">"I like "</span> . $cars[<span class="hljs-number">0</span>] . <span class="hljs-string">", "</span> . $cars[<span class="hljs-number">1</span>] . <span class="hljs-string">" and "</span> . $cars[<span class="hljs-number">2</span>] . <span class="hljs-string">".&lt;br&gt;"</span>;<br><span class="hljs-keyword">echo</span> count($cars);<span class="hljs-comment">// 数组长度</span><br><br><span class="hljs-comment">// 关联数组</span><br>$age=<span class="hljs-keyword">array</span>(<span class="hljs-string">"Peter"</span>=&gt;<span class="hljs-string">"35"</span>,<span class="hljs-string">"Ben"</span>=&gt;<span class="hljs-string">"37"</span>,<span class="hljs-string">"Joe"</span>=&gt;<span class="hljs-string">"43"</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">"&lt;br&gt;Peter is "</span> . $age[<span class="hljs-string">'Peter'</span>] . <span class="hljs-string">" years old."</span>;<br><span class="hljs-meta">?&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><p>sort() - 对数组进行升序排列<br>rsort() - 对数组进行降序排列<br>asort() - 根据关联数组的值，对数组进行升序排列<br>ksort() - 根据关联数组的键，对数组进行升序排列</p><h2 id="超级全局变量"><a href="#超级全局变量" class="headerlink" title="超级全局变量"></a>超级全局变量</h2><p>超级全局变量在PHP 4.1.0之后被启用, 是PHP系统中自带的变量，在一个脚本的全部作用域中都可用。<br><code>$GLOBALS</code> 是PHP的一个超级全局变量组，在一个PHP脚本的全部作用域中都可以访问。<br>$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。</p><h3 id="REQUEST"><a href="#REQUEST" class="headerlink" title="$_REQUEST"></a>$_REQUEST</h3><p><code>$_REQUEST</code> 用于收集HTML表单提交的数据。<br>当用户通过点击 “Submit” 按钮提交表单数据时, 表单数据将发送至<form>标签中 action 属性中指定的脚本文件。</form></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- $_SERVER['PHP_SELF'] 获取 当前执行脚本的文件名 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"&lt;?php echo $_SERVER['PHP_SELF'];?&gt;"</span>&gt;</span> <br>Name: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"fname"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br> <br><span class="php"><span class="hljs-meta">&lt;?php</span> <br>$name = $_REQUEST[<span class="hljs-string">'fname'</span>]; <br><span class="hljs-keyword">echo</span> $name; <br><span class="hljs-meta">?&gt;</span></span><br> <br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>$_POST</code>、<code>$_GET</code>同样被广泛应用于收集表单数据。</p><h2 id="While-循环"><a href="#While-循环" class="headerlink" title="While 循环"></a>While 循环</h2><h2 id="For-循环"><a href="#For-循环" class="headerlink" title="For 循环"></a>For 循环</h2><h3 id="foreach-循环"><a href="#foreach-循环" class="headerlink" title="foreach 循环"></a>foreach 循环</h3><p>冒泡排序</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="php"><span class="hljs-meta">&lt;?php</span><br>$arr = <span class="hljs-keyword">array</span>(<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> ($i=count($arr)<span class="hljs-number">-1</span>; $i&gt;=<span class="hljs-number">0</span>; $i--) &#123;<br><span class="hljs-keyword">for</span> ($j= <span class="hljs-number">0</span>; $j&lt;$i; $j++) &#123;<br><span class="hljs-keyword">if</span>($arr[$j] &gt; $arr[$j+<span class="hljs-number">1</span>]) &#123;<br>$temp = $arr[$j];<br>$arr[$j] = $arr[$j+<span class="hljs-number">1</span>];<br>$arr[$j+<span class="hljs-number">1</span>] = $temp;<br>&#125;<br>&#125;<br>&#125;<br>print_r($arr[<span class="hljs-number">4</span>]);</span><br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">($x, $y)</span> </span>&#123;<br><span class="hljs-keyword">return</span> $x + $y;<br>&#125;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">'14 + 12 = '</span> . add(<span class="hljs-number">14</span>, <span class="hljs-number">12</span>);</span><br></code></pre></td></tr></table></figure><h2 id="魔法常量"><a href="#魔法常量" class="headerlink" title="魔法常量"></a>魔法常量</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">'该文件位于 " '</span>  . <span class="hljs-keyword">__FILE__</span> . <span class="hljs-string">' " &lt;br&gt;'</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_print</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">'类名为：'</span>  . <span class="hljs-keyword">__CLASS__</span> . <span class="hljs-string">"&lt;br&gt;"</span>;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">'函数名为：'</span> . <span class="hljs-keyword">__FUNCTION__</span> ;<br>    &#125;<br>&#125;<br>$t = <span class="hljs-keyword">new</span> test();<br>$t-&gt;_print();<br><span class="hljs-meta">?&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="命名空间-namespace"><a href="#命名空间-namespace" class="headerlink" title="命名空间(namespace)"></a>命名空间(namespace)</h2><p>PHP 命名空间可以解决以下两类问题：</p><ul><li>用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。</li><li>为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。</li></ul><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h1 id="PHP表单"><a href="#PHP表单" class="headerlink" title="PHP表单"></a>PHP表单</h1><h2 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h2><p><code>&lt;form method=&quot;post&quot; action=&quot;&lt;?php echo htmlspecialchars($_SERVER[&quot;PHP_SELF&quot;]);?&gt;&quot;&gt;</code><br><code>$_SERVER[&quot;PHP_SELF&quot;]</code>是超级全局变量，返回当前正在执行脚本的文件名，与 document root相关。所以，<code>$_SERVER[&quot;PHP_SELF&quot;]</code> 会发送表单数据到当前页面，而不是跳转到不同的页面。<br>htmlspecialchars() 函数把一些预定义的字符转换为 HTML 实体。<br>预定义的字符是：</p><ul><li>&amp; （和号） 成为 &amp;</li><li>“ （双引号） 成为 &quot;</li><li>‘ （单引号） 成为 &#039;</li><li>&lt; （小于） 成为 &lt;</li><li>&gt; （大于） 成为 &gt;</li></ul><p><code>$_SERVER[&quot;PHP_SELF&quot;]</code> 变量有可能会被黑客使用！可以通过 htmlspecialchars() 函数来避免被利用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// 定义变量并默认设置为空值</span><br>$name = $email = $gender = $comment = $website = <span class="hljs-string">""</span>;<br><span class="hljs-comment">// 通过$_SERVER["REQUEST_METHOD"]来检测表单是否被提交</span><br><span class="hljs-keyword">if</span> ($_SERVER[<span class="hljs-string">"REQUEST_METHOD"</span>] == <span class="hljs-string">"POST"</span>)<br>&#123;<br>   $name = test_input($_POST[<span class="hljs-string">"name"</span>]);<br>   $gender = test_input($_POST[<span class="hljs-string">"gender"</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test_input</span><span class="hljs-params">($data)</span><br></span>&#123;<br>   $data = trim($data);  <span class="hljs-comment">// 去除用户输入数据中不必要的字符 (如：空格，tab，换行)。</span><br>   $data = stripslashes($data);  <span class="hljs-comment">// 去除用户输入数据中的反斜杠 (\)</span><br>   $data = htmlspecialchars($data);  <span class="hljs-comment">// 把一些预定义的字符转换为 HTML 实体。</span><br>   <span class="hljs-keyword">return</span> $data;<br>&#125;<br><span class="hljs-meta">?&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="必须字段"><a href="#必须字段" class="headerlink" title="必须字段"></a>必须字段</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// 定义变量并默认设为空值</span><br>$nameErr = $name = <span class="hljs-string">""</span>;<br><span class="hljs-keyword">if</span> ($_SERVER[<span class="hljs-string">"REQUEST_METHOD"</span>] == <span class="hljs-string">"POST"</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">empty</span>($_POST[<span class="hljs-string">"name"</span>])) &#123;<br>    $nameErr = <span class="hljs-string">"名字是必需的。"</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    $name = test_input($_POST[<span class="hljs-string">"name"</span>]);<br>  &#125;<br>&#125;<br><span class="hljs-meta">?&gt;</span></span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"&lt;?php echo htmlspecialchars($_SERVER['PHP_SELF']);?&gt;"</span>&gt;</span> <br>   名字: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"error"</span>&gt;</span>* <span class="php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">echo</span> $nameErr;<span class="hljs-meta">?&gt;</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Submit"</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="验证邮件和URL"><a href="#验证邮件和URL" class="headerlink" title="验证邮件和URL"></a>验证邮件和URL</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">empty</span>($_POST[<span class="hljs-string">"name"</span>])) &#123;<br>  $nameErr = <span class="hljs-string">"Name is required"</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br> $name = test_input($_POST[<span class="hljs-string">"name"</span>]);<br> <span class="hljs-comment">// 检测名字是否只包含字母跟空格</span><br> <span class="hljs-keyword">if</span> (!preg_match(<span class="hljs-string">"/^[a-zA-Z ]*$/"</span>,$name)) &#123;<br> $nameErr = <span class="hljs-string">"只允许字母和空格"</span>; <br> &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="GET-变量"><a href="#GET-变量" class="headerlink" title="$_GET 变量"></a>$_GET 变量</h2><p>预定义的<code>$_GET</code> 变量用于收集来自 <code>method=&quot;get&quot;</code>的表单中的值。</p><p>从带有 GET 方法的表单发送的信息，对任何人都是可见的（会显示在浏览器的地址栏），并且对发送信息的量也有限制。</p><h2 id="POST-变量"><a href="#POST-变量" class="headerlink" title="$_POST 变量"></a>$_POST 变量</h2><p>预定义的 <code>$_POST</code> 变量用于收集来自 <code>method=&quot;post&quot;</code>的表单中的值。</p><p>从带有 POST 方法的表单发送的信息，对任何人都是不可见的（不会显示在浏览器的地址栏），并且对发送信息的量也没有限制。</p><h1 id="PHP高级教程"><a href="#PHP高级教程" class="headerlink" title="PHP高级教程"></a>PHP高级教程</h1><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$sites =<span class="hljs-built_in"> array<br></span>(<br>    array(<span class="hljs-string">"Volvo"</span>,100,96),<br>    <span class="hljs-string">"taobao"</span>=&gt;array<br>    (<br>        <span class="hljs-string">"淘宝"</span>,<br>        <span class="hljs-string">"http://www.taobao.com"</span><br>    )<br>);<br></code></pre></td></tr></table></figure><h2 id="date-函数"><a href="#date-函数" class="headerlink" title="date() 函数"></a>date() 函数</h2><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?php<br>date_default_timezone_set(<span class="hljs-string">'PRC'</span>); <br><span class="hljs-built_in">echo</span> <span class="hljs-built_in">date</span>(<span class="hljs-string">"Y/m/d"</span>) . <span class="hljs-string">"&lt;br&gt;"</span>;<br><span class="hljs-built_in">echo</span> <span class="hljs-built_in">date</span>(<span class="hljs-string">"Y.m.d"</span>) . <span class="hljs-string">"&lt;br&gt;"</span>;<br><span class="hljs-built_in">echo</span> <span class="hljs-built_in">date</span>(<span class="hljs-string">"Y-m-d H:i:s"</span>);<br>?&gt;<br></code></pre></td></tr></table></figure><h2 id="包含文件"><a href="#包含文件" class="headerlink" title="包含文件"></a>包含文件</h2><p>include 和 require 语句用于在执行流中插入写在其他文件中的有用的代码。<br>处理错误方式不同：</p><ul><li>require 生成一个致命错误（E_COMPILE_ERROR），在错误发生后脚本会停止执行。</li><li>include 生成一个警告（E_WARNING），在错误发生后脚本会继续执行。<br><code>&lt;?php include &#39;header.php&#39;; ?&gt;</code></li></ul><h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><p>fopen()、fclose()、feof()</p><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>允许用户上传文件是一个巨大的安全风险。请仅仅允许可信的用户执行文件上传操作。<br><a href="https://www.cnblogs.com/54chensongxia/p/11662252.html#2409458956" target="_blank" rel="noopener">https://www.cnblogs.com/54chensongxia/p/11662252.html#2409458956</a></p><h3 id="上传限制"><a href="#上传限制" class="headerlink" title="上传限制"></a>上传限制</h3><p>用户只能上传 .gif、.jpeg、.jpg、.png 文件，文件大小必须小于 200 kB</p><h3 id="保存被上传的文件"><a href="#保存被上传的文件" class="headerlink" title="保存被上传的文件"></a>保存被上传的文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// 允许上传的图片后缀</span><br>$allowedExts = <span class="hljs-keyword">array</span>(<span class="hljs-string">"gif"</span>, <span class="hljs-string">"jpeg"</span>, <span class="hljs-string">"jpg"</span>, <span class="hljs-string">"png"</span>);<br>$temp = explode(<span class="hljs-string">"."</span>, $_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"name"</span>]);<br><span class="hljs-keyword">echo</span> $_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"size"</span>];<br>$extension = end($temp);     <span class="hljs-comment">// 获取文件后缀名</span><br><span class="hljs-keyword">if</span> ((($_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"type"</span>] == <span class="hljs-string">"image/gif"</span>)<br>|| ($_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"type"</span>] == <span class="hljs-string">"image/jpeg"</span>)<br>|| ($_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"type"</span>] == <span class="hljs-string">"image/jpg"</span>)<br>|| ($_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"type"</span>] == <span class="hljs-string">"image/pjpeg"</span>)<br>|| ($_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"type"</span>] == <span class="hljs-string">"image/x-png"</span>)<br>|| ($_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"type"</span>] == <span class="hljs-string">"image/png"</span>))<br>&amp;&amp; ($_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"size"</span>] &lt; <span class="hljs-number">204800</span>)   <span class="hljs-comment">// 小于 200 kb</span><br>&amp;&amp; in_array($extension, $allowedExts))<br>&#123;<br>    <span class="hljs-keyword">if</span> ($_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"error"</span>] &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">"错误：: "</span> . $_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"error"</span>] . <span class="hljs-string">"&lt;br&gt;"</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">"上传文件名: "</span> . $_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"name"</span>] . <span class="hljs-string">"&lt;br&gt;"</span>;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">"文件类型: "</span> . $_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"type"</span>] . <span class="hljs-string">"&lt;br&gt;"</span>;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">"文件大小: "</span> . ($_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"size"</span>] / <span class="hljs-number">1024</span>) . <span class="hljs-string">" kB&lt;br&gt;"</span>;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">"文件临时存储的位置: "</span> . $_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"tmp_name"</span>] . <span class="hljs-string">"&lt;br&gt;"</span>;<br>        <br>        <span class="hljs-comment">// 判断当期目录下的 upload 目录是否存在该文件</span><br>        <span class="hljs-comment">// 如果没有 upload 目录，你需要创建它，upload 目录权限为 777</span><br>        <span class="hljs-keyword">if</span> (file_exists(<span class="hljs-string">"upload/"</span> . $_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"name"</span>]))<br>        &#123;<br>            <span class="hljs-keyword">echo</span> $_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"name"</span>] . <span class="hljs-string">" 文件已经存在。 "</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// 如果 upload 目录不存在该文件则将文件上传到 upload 目录下</span><br>            move_uploaded_file($_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"tmp_name"</span>], <span class="hljs-string">"upload/"</span> . $_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"name"</span>]);<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">"文件存储在: "</span> . <span class="hljs-string">"upload/"</span> . $_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"name"</span>];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"非法的文件格式"</span>;<br>&#125;<br><span class="hljs-meta">?&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>cookie 常用于<strong>识别用户</strong>。cookie 是一种服务器留在用户计算机上的小文件。每当同一台计算机通过浏览器请求页面时，这台计算机将会发送 cookie。通过 PHP，您能够创建并取回 cookie 的值。</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>session 变量用于存储关于用户会话（session）的信息，或者更改用户会话（session）的设置。Session 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的。</p><h2 id="Email"><a href="#Email" class="headerlink" title="Email"></a>Email</h2><p>PHP 允许您从脚本直接发送电子邮件。</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>在 PHP 中，默认的错误处理很简单。一条错误消息会被发送到浏览器，这条消息带有文件名、行号以及描述错误的消息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span>(!file_exists(<span class="hljs-string">"welcome.txt"</span>)) &#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">"文件不存在"</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    $file=fopen(<span class="hljs-string">"welcome.txt"</span>,<span class="hljs-string">"r"</span>);<br>&#125;<br><span class="hljs-meta">?&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常用于在指定的错误发生时改变脚本的正常流程。</p><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>PHP 过滤器用于验证和过滤来自非安全来源的数据，比如用户的输入。</p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>json_encode: 对变量进行 JSON 编码<br>json_decode: 对 JSON 格式的字符串进行解码，转换为 PHP 变量</p><h1 id="PHP数据库"><a href="#PHP数据库" class="headerlink" title="PHP数据库"></a>PHP数据库</h1><h2 id="MySQL简介"><a href="#MySQL简介" class="headerlink" title="MySQL简介"></a>MySQL简介</h2><p>MySQL 是一种在 Web、服务器 上使用的数据库系统。</p><h2 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h2><h3 id="实例-MySQLi-面向对象"><a href="#实例-MySQLi-面向对象" class="headerlink" title="实例 (MySQLi - 面向对象)"></a>实例 (MySQLi - 面向对象)</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>$servername = <span class="hljs-string">"localhost"</span>;<br>$username = <span class="hljs-string">"username"</span>;<br>$password = <span class="hljs-string">"password"</span>;<br> <br><span class="hljs-comment">// 创建连接</span><br>$conn = <span class="hljs-keyword">new</span> mysqli($servername, $username, $password);<br> <br><span class="hljs-comment">// 检测连接</span><br><span class="hljs-keyword">if</span> ($conn-&gt;connect_error) &#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">"连接失败: "</span> . $conn-&gt;connect_error);<br>&#125; <br><span class="hljs-keyword">echo</span> <span class="hljs-string">"连接成功"</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 创建数据库</span><br>$sql = <span class="hljs-string">"CREATE DATABASE myDB"</span>;<br><span class="hljs-keyword">if</span> ($conn-&gt;query($sql) === <span class="hljs-keyword">TRUE</span>) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"数据库创建成功"</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"Error creating database: "</span> . $conn-&gt;error;<br>&#125;<br> <br>$conn-&gt;close();<br></code></pre></td></tr></table></figure><h2 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 使用 sql 创建数据表</span><br>$sql = <span class="hljs-string">"CREATE TABLE MyGuests (<br>id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY, <br>firstname VARCHAR(30) NOT NULL,<br>lastname VARCHAR(30) NOT NULL,<br>email VARCHAR(50),<br>reg_date TIMESTAMP<br>)"</span>;<br> <br><span class="hljs-keyword">if</span> ($conn-&gt;query($sql) === <span class="hljs-keyword">TRUE</span>) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"Table MyGuests created successfully"</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"创建数据表错误: "</span> . $conn-&gt;error;<br>&#125;<br> <br>$conn-&gt;close();<br></code></pre></td></tr></table></figure><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>预处理语句对于防止 MySQL 注入是非常有用的。<br>预处理语句用于执行多个相同的 SQL 语句，并且执行效率更高。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>$servername = <span class="hljs-string">"localhost"</span>;<br>$username = <span class="hljs-string">"username"</span>;<br>$password = <span class="hljs-string">"password"</span>;<br>$dbname = <span class="hljs-string">"myDB"</span>;<br> <br><span class="hljs-comment">// 创建连接</span><br>$conn = <span class="hljs-keyword">new</span> mysqli($servername, $username, $password, $dbname);<br> <br><span class="hljs-comment">// 检测连接</span><br><span class="hljs-keyword">if</span> ($conn-&gt;connect_error) &#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">"连接失败: "</span> . $conn-&gt;connect_error);<br>&#125;<br> <br><span class="hljs-comment">// 预处理及绑定</span><br>$stmt = $conn-&gt;prepare(<span class="hljs-string">"INSERT INTO MyGuests (firstname, lastname, email) VALUES (?, ?, ?)"</span>);<br>$stmt-&gt;bind_param(<span class="hljs-string">"sss"</span>, $firstname, $lastname, $email);<br> <br><span class="hljs-comment">// 设置参数并执行</span><br>$firstname = <span class="hljs-string">"John"</span>;<br>$lastname = <span class="hljs-string">"Doe"</span>;<br>$email = <span class="hljs-string">"john@example.com"</span>;<br>$stmt-&gt;execute();<br> <br>$firstname = <span class="hljs-string">"Julie"</span>;<br>$lastname = <span class="hljs-string">"Dooley"</span>;<br>$email = <span class="hljs-string">"julie@example.com"</span>;<br>$stmt-&gt;execute();<br> <br><span class="hljs-keyword">echo</span> <span class="hljs-string">"新记录插入成功"</span>;<br> <br>$stmt-&gt;close();<br>$conn-&gt;close();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><code>$stmt-&gt;bind_param(&quot;sss&quot;, $firstname, $lastname, $email);</code><br>bind_param函数绑定了 SQL 的参数，且告诉数据库参数的值。 “sss” 参数列处理其余参数的数据类型。s 字符告诉数据库该参数为字符串。</p><p>参数有以下四种类型:</p><p>i - integer（整型）<br>d - double（双精度浮点型）<br>s - string（字符串）<br>b - BLOB（binary large object:二进制大对象）<br>每个参数都需要指定类型。通过告诉数据库参数的数据类型，可以降低 SQL 注入的风险。</p><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>$servername = <span class="hljs-string">"localhost"</span>;<br>$username = <span class="hljs-string">"username"</span>;<br>$password = <span class="hljs-string">"password"</span>;<br>$dbname = <span class="hljs-string">"myDB"</span>;<br> <br><span class="hljs-comment">// 创建连接</span><br>$conn = <span class="hljs-keyword">new</span> mysqli($servername, $username, $password, $dbname);<br><span class="hljs-comment">// Check connection</span><br><span class="hljs-keyword">if</span> ($conn-&gt;connect_error) &#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">"连接失败: "</span> . $conn-&gt;connect_error);<br>&#125; <br> <br>$sql = <span class="hljs-string">"SELECT id, firstname, lastname FROM MyGuests"</span>;<br>$result = $conn-&gt;query($sql);<br> <br><span class="hljs-keyword">if</span> ($result-&gt;num_rows &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 输出数据</span><br>    <span class="hljs-keyword">while</span>($row = $result-&gt;fetch_assoc()) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">"id: "</span> . $row[<span class="hljs-string">"id"</span>]. <span class="hljs-string">" - Name: "</span> . $row[<span class="hljs-string">"firstname"</span>]. <span class="hljs-string">" "</span> . $row[<span class="hljs-string">"lastname"</span>]. <span class="hljs-string">"&lt;br&gt;"</span>;<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"0 结果"</span>;<br>&#125;<br>$conn-&gt;close();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>crontab定时任务</title>
    <link href="/2020/03/13/%E6%9C%8D%E5%8A%A1%E7%AB%AF/crontab%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <url>/2020/03/13/%E6%9C%8D%E5%8A%A1%E7%AB%AF/crontab%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>Linux的crond定时任务是周期性执行任务的守护进程。</p><a id="more"></a><ol><li><p>安装<br> <code>yum -y install crontab</code></p></li><li><p>启动crond服务<br> <code>service crond start</code><br> 查看状态<code>service crond status</code></p></li><li><p>使用<code>crontab -e</code>进行定时任务的编辑<br> 格式: <code>分 时 日 月 周 [用户] command</code><br> 这里我写入<code>0 * * * * /root/anaconda3/bin/python3 /root/*.py</code>, 表示每天每小时0分时自动执行<code>python3 /root/*.py</code>命令。<br> 注意: 设置好运行命令的<strong>绝对路径</strong>和被执行文件的<strong>绝对路径</strong>，因为crontab本身不具备平时运行的环境变量。</p></li><li><p>使用<code>crontab -l</code>查看设置好的定时任务</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习笔记</title>
    <link href="/2020/02/26/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux_notes/"/>
    <url>/2020/02/26/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux_notes/</url>
    
    <content type="html"><![CDATA[<p>整理了一些Linux的常用知识，方便之后使用时查阅。</p><a id="more"></a><p><code>[root@localhost ~]#</code>的含义</p><ol><li>用户名：root</li><li>主机名：localhost</li><li>当前路径：~当前用户的home目录</li><li>权限标志位：#代表root，$代表普通用户</li></ol><h2 id="vi操作"><a href="#vi操作" class="headerlink" title="vi操作"></a>vi操作</h2><ul><li>可以编辑文件 <code>vi &lt;file&gt;</code></li><li>插入内容 <code>p、P</code></li><li>复制 <code>[n]yy</code></li><li>删除行，删除词 <code>[n]dd、dw、x</code></li><li>撤销 <code>u</code></li><li>跳转某一行 <code>[n]G</code></li><li>跳转行的开头<code>0</code>、末尾<code>$</code></li><li>通过:/xxx进行搜索定位，n键查找下一项<br><code>vi /etc/hostname</code> 改主机名<br><code>:wq</code>   强制性写入文件并退出。即使文件没有被修改也强制写入，并更新文件的修改时间。<br><code>:x</code>    写入文件并退出。仅当文件被修改时才写入，并更新文件修改时间，否则不会更新文件修改时间。</li></ul><h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><p>文件和文件夹的创建删除<br><code>mkdir -p &lt;dir/subdir&gt;</code>  创建多级目录<br><code>rm -r &lt;file&gt;</code>   删除多级文件<br><code>mv &lt;old&gt; &lt;new&gt;</code>  移动和文件更名<br><code>pwd</code> 查看当前绝对路径<br><code>cp &lt;file&gt; &lt;file&gt;.bak</code>  复制、备份文件</p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><p>cat，more，less，grep，wc –l<br>cd - 返回上一次目录<br>more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读</p><p>文件的打包和解压： tar cvfz以及对应的tar xvfz<br>c ：创建一个新归档；x ： 从归档中抽取文件。<br>v ：显示文件的归档进度；z ：使用 gzip 来压缩 tar 文件。<br>f ：当与 -c 选项一起使用时，创建的 tar 文件使用该选项指定的文件名；当与 -x 选项<br>一起使用时，则解除该选项指定的归档。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$ tar cvfz share<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> /usr/local/share/<br>$ tar xvfz share<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> -C ./tmp<br></code></pre></td></tr></table></figure><p>打包指的是将多个文件和目录集中存储在一个文件中；<br>而压缩则指的是利用算法对文件进行处理，从而达到缩减占用磁盘空间的目的。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">echo  <span class="hljs-comment">// 用于字符串的输出</span><br>ls -l f*  <span class="hljs-comment">// 查看虚拟机上以f开头的设备文件</span><br><span class="hljs-keyword">find</span> &lt;dir&gt; -name &lt;文件名&gt; <span class="hljs-number">2</span>&gt;<span class="hljs-regexp">/dev/</span><span class="hljs-keyword">null</span>  <span class="hljs-comment">// 查找文件</span><br><span class="hljs-keyword">grep</span> &lt;查找内容&gt; &lt;文件名&gt;  <span class="hljs-comment">// 搜索文件内容</span><br><span class="hljs-keyword">find</span> . | <span class="hljs-keyword">grep</span> passwd<br>ls | <span class="hljs-keyword">grep</span> *.txt<br>tail -n &lt;<span class="hljs-keyword">file</span>&gt;<span class="hljs-comment">// 查看某一文件后n行</span><br></code></pre></td></tr></table></figure><p>创建软链接<br><code>ln -s &lt;source&gt; &lt;target&gt;</code><br>如<code>ln -s /root/htdocs/cqcq/application/index/controller/ ~/controller</code><br>注意，删除软链接用<code>rm -rf ~/controller</code>，而不是<code>rm -rf ~/controller/</code></p><h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h3><p>Ubuntu用<code>apt-get</code>，Centos用<code>yum</code>。<br>加上<code>-y</code>遇到询问时自动yes。</p><h2 id="重定向和管道"><a href="#重定向和管道" class="headerlink" title="重定向和管道"></a>重定向和管道</h2><p>重定向的符号有两个：&gt;或&gt;&gt;。<br>两者的区别是：<br>前者会先清空文件，然后再写入内容；<br>后者会将重定向的内容追加到现有文件的尾部。</p><p>能够将任意命令的运行结果重定向到文件中。例如<code>ls –l &gt; tmp.txt</code></p><p><strong>管道</strong>：</p><ul><li>把一个程序的输出直接连接到另一个程序的输入。</li><li>通过管道将两个命令拼接起来。</li></ul><p>最典型的比如<code>ls –l | wc –l</code>计算数量。<br><code>cat &lt;file&gt; | wc -l</code>统计file的行数，file的内容输出连接到wc -l的输入。</p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>创建用户，修改用户密码</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">sudo adduser &lt;<span class="hljs-keyword">new</span><span class="hljs-type">user</span>&gt;     <br>sudo passwd &lt;<span class="hljs-keyword">new</span><span class="hljs-type">user</span>&gt;<br></code></pre></td></tr></table></figure><p>su — Switch User<br>切换到指定用户，并且在该用户的家目录中创建文件，再退出这个用户。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">su newuser <br>touch &lt;file&gt;<br><span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure><p>用su来切换root用户和普通用户，注意切换用户后还在原来的路径上<br>改主机名：<code>hostnamectl set-hostname &lt;newname&gt;</code></p><p>可以使用chmod为文件增加可执行权限。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">chmod +x &lt;<span class="hljs-keyword">file</span>&gt;  <span class="hljs-comment">// 加操作权限</span><br>chmod <span class="hljs-number">777</span> &lt;<span class="hljs-keyword">file</span>&gt;  <span class="hljs-comment">// 8进制加满权限</span><br></code></pre></td></tr></table></figure><p><code>chown -R &lt;user&gt;:&lt;group&gt; *</code></p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>编译.c程序，并且将其放在后台进程运行。<br>ps命令用于显示当前进程 (process) 的状态。<br><code>ps -ef</code>   // 显示所有命令，连带命令行<br><code>kill &lt;id&gt;</code>  // 杀死进程<br>后台进程的启动是用户在输入命令行后加上“&amp;”字符，常用于进程耗时长、用户不着急得到结果的场合。<br>PPID：父进程的进程号。TTY：启动进程的终端号。<br>NI：nice的优先级。PRI：进程的优先级。<br>PRI -&gt; 进程的优先级，大部分系统都是数字越低优先级越高，进程就优先运行 。</p><p>在shell上启动了两个test_loop程序（使用<code>test_loop &amp;</code>），这两个程序都是shell（bash）“生”出来的，即属于shell的子进程。<br>BASH是SHELL的一种，是大多数LINUX发行版默认的SHELL。</p><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>Shell俗称壳（用来区别于内核），是指“提供使用者使用界面”的软件，就是一个<strong>命令行解释器</strong>。</p><p>定义简单变量并且打印，可以运行脚本。<br><code>chmod + x &lt;file.sh&gt;</code><br>If条件判断，字符串是否相等的比较</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">result=$(…)<br><span class="hljs-keyword">if</span> [ “<span class="hljs-variable">$result</span>” = “<span class="hljs-variable">$1</span>” ]; <span class="hljs-keyword">then</span><br><span class="hljs-keyword">elif</span> [ “” = “” ]; <span class="hljs-keyword">then</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>读入清单，批量创建清单上的文件目录</p><p>shell中，<br>== 可用于判断变量是否相等。<br>= 除了可用于判断变量是否相等外，还可以表示赋值。<br>= 与 == 在 [ ] 中表示判断(字符串比较)时是等价的。</p><h2 id="Linux目录"><a href="#Linux目录" class="headerlink" title="Linux目录"></a>Linux目录</h2><p>/boot：存放Linux内核、引导配置等<strong>启动</strong>文件。<br>/dev：存放硬盘、键盘、鼠标、光驱等各种<strong>设备</strong>文件。<br>/etc：存放各种<strong>配置</strong>文件、配置目录。<br>/home：存放普通用户的默认工作文件夹（即宿主目录、家目录）。<br>/var：存放日志文件、用户邮箱目录、进程运行数据等<strong>变化</strong>的文档。<br>/tmp：存放系统运行过程中使用的一些<strong>临时</strong>文件。</p><h2 id="QUESTION"><a href="#QUESTION" class="headerlink" title="QUESTION"></a>QUESTION</h2><ol><li><p>可执行文件前为什么要加<code>./</code>？<br>“./“表示当前目录下的可执行文件。<br>若要在任意目录下访问。</p><ol><li><code>chmod +x xx.sh</code>加上写权限。</li><li>在<code>~/.bashrc</code>中将当前目录加入到<code>export PATH=$PATH:</code>后。</li></ol></li><li><p>FTP是什么？<br>FTP就是文件传输协议。用于互联网双向传输，控制文件下载空间在服务器复制文件从本地计算机或本地上传文件复制到服务器上的空间。使用Xshell6中的Xftp6。</p></li><li><p>如何将静态页面部署到服务器上？<br>在服务器中安装<code>nginx</code>，使用<code>/etc/init.d/nginx start</code>启动，把<code>index.html</code>放在<code>/usr/share/nginx/html/</code>之下。</p></li><li><p><code>yum install</code>的<code>-y</code>参数是什么意思？<br>遇到询问时自动yes。</p></li><li><p>如何看自己的Linux服务器是多少位的？<br><code>getconf LONG_BIT</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git分支进行多终端工作</title>
    <link href="/2020/02/18/Hexo/git%E5%88%86%E6%94%AF%E8%BF%9B%E8%A1%8C%E5%A4%9A%E7%BB%88%E7%AB%AF%E5%B7%A5%E4%BD%9C/"/>
    <url>/2020/02/18/Hexo/git%E5%88%86%E6%94%AF%E8%BF%9B%E8%A1%8C%E5%A4%9A%E7%BB%88%E7%AB%AF%E5%B7%A5%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>最近把原本部署在GitHub上的hexo同时部署到码云上，速度快到飞起。<br>可做对比，我的<a href="https://hongchenglong.github.io" target="_blank" rel="noopener">GitHub Pages</a>像乌龟一样慢吞吞，我的<a href="https://hongchenglong.gitee.io" target="_blank" rel="noopener">Gitee Pages</a>像兔子一样敏捷。</p><meta name="referrer" content="no-referrer"><a id="more"></a><blockquote><p>使用hexo，如果换了电脑怎么更新博客？</p></blockquote><p>一个分支<strong>hexo</strong>用来存放Hexo生成的网站<strong>原始的文件</strong>，另一个分支<strong>master</strong>用来存放生成的<strong>静态网页</strong>。</p><p>我以操作码云为例。</p><ol><li>上传分支<br>新建一个hexo分支，点击<strong>管理</strong>，并设为<strong>默认</strong>分支。<br><img src="https://img2018.cnblogs.com/blog/1677222/202002/1677222-20200218154619708-1227810824.png" srcset="/img/loading.gif" alt></li></ol><p><img src="https://img2018.cnblogs.com/blog/1677222/202002/1677222-20200218154951236-1568229660.png" srcset="/img/loading.gif" alt></p><ol start="2"><li>克隆仓库到本地<br><code>git clone git@gitee.com:hongchenglong/Hongchenglong.git</code></li><li>将博客源文件全部复制过来，除了<code>.deploy_git</code>，因为<code>hexo d</code>上传部署到github的其实是hexo编译后的文件，是用来生成网页的，即<code>.deploy_git</code>里面的文件。</li></ol><p>在<code>.gitignore</code>中加入以下文件，这些文件在别的电脑上需要重新输入命令安装 。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-selector-class">.DS_Store</span><br>Thumbs<span class="hljs-selector-class">.db</span><br>db<span class="hljs-selector-class">.json</span><br>*<span class="hljs-selector-class">.log</span><br>node_modules/<br>public/<br>.deploy*/<br></code></pre></td></tr></table></figure><p>注意，如果之前克隆过theme中的主题文件，那么应该把主题文件中的<code>.git</code>文件夹删掉，因为<strong>git不能嵌套上传</strong>。</p><ol start="4"><li><p>上传源文件到码云上</p> <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">git <span class="hljs-keyword">add</span> .<br>git commit –m <span class="hljs-string">"xxxx"</span><br>git <span class="hljs-keyword">push</span><br></code></pre></td></tr></table></figure></li><li><p>发布博客<code>hexo g -d</code></p></li><li><p>最后手动更新部署<span style="color:red">master</span>分支</p></li></ol><p><img src="https://img2018.cnblogs.com/blog/1677222/202002/1677222-20200218161451693-906408523.png" srcset="/img/loading.gif" alt></p><p>参考知乎回答：<a href="https://www.zhihu.com/question/21193762/answer/489124966" target="_blank" rel="noopener">https://www.zhihu.com/question/21193762/answer/489124966</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo学习笔记</title>
    <link href="/2020/02/16/Hexo/Hexo_notes/"/>
    <url>/2020/02/16/Hexo/Hexo_notes/</url>
    
    <content type="html"><![CDATA[<p>记录我在使用Hexo时遇到的问题和解决方法。</p><blockquote><p>Hexo is a fast, simple &amp; powerful blog framework.</p></blockquote><a id="more"></a><h2 id="如何上传文章"><a href="#如何上传文章" class="headerlink" title="如何上传文章"></a>如何上传文章</h2><p>在你博客站点文件夹下右键空白处，选择<code>Git Bash Here</code></p><ol><li><code>hexo new post &quot;&quot;</code>然后在<code>./source/_posts</code>里找到并编辑。</li><li><code>hexo g</code> (hexo generate)，用于生成静态文件</li><li><code>hexo s</code> (hexo server)，用于启动服务器，主要用来本地预览；完成后打开浏览器输入 <code>localhost:4000</code></li><li><code>hexo d</code> (hexo deploy)，用于将本地文件发布到github等git仓库上</li><li>2、4步简写 <code>hexo g -d</code></li><li><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></li></ol><h2 id="显示不出分类、标签问题"><a href="#显示不出分类、标签问题" class="headerlink" title="显示不出分类、标签问题"></a>显示不出分类、标签问题</h2><p>在<code>./source/tags/index.md</code>中添加<code>type: tags</code>字段。<br><code>categories</code>同理。<br>参考博客：<a href="https://blog.csdn.net/Wonz5130/article/details/84666519" target="_blank" rel="noopener">https://blog.csdn.net/Wonz5130/article/details/84666519</a></p><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>npm 出现 <code>operation not permitted, mkdir...</code>问题<br>解决办法：以管理员身份运行cmd输入<code>npm -v</code>，然后在git bash中就没问题了。</p><h2 id="主题加载不出"><a href="#主题加载不出" class="headerlink" title="主题加载不出"></a>主题加载不出</h2><p>我是因为配置文件url配错了，改成原有的配置就OK了。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-string">url:</span> <span class="hljs-string">http:</span><span class="hljs-comment">//yoursite.com</span><br><span class="hljs-string">root:</span> /<br></code></pre></td></tr></table></figure><h2 id="图片加载不出"><a href="#图片加载不出" class="headerlink" title="图片加载不出"></a>图片加载不出</h2><p>我是引用cnblog的图片链接，刚刚上传那会还能显示图片，过几天就发现图片加载不出。<br>解决方法：<br>在文章头部加上<code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;</code>，解决防盗链问题。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Hexo学习笔记</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">&lt;meta</span> <span class="hljs-string">name="referrer"</span> <span class="hljs-string">content="no-referrer"/&gt;</span><br></code></pre></td></tr></table></figure><p>参考博客：</p><ul><li><a href="https://qsh5.cn/595.html" target="_blank" rel="noopener">https://qsh5.cn/595.html</a></li><li><a href="https://blog.csdn.net/mqdxiaoxiao/article/details/96770756" target="_blank" rel="noopener">https://blog.csdn.net/mqdxiaoxiao/article/details/96770756</a></li></ul><h2 id="hexo同时部署到码云Gitee"><a href="#hexo同时部署到码云Gitee" class="headerlink" title="hexo同时部署到码云Gitee"></a>hexo同时部署到码云Gitee</h2><p>如何创建一个首页访问地址不带二级目录的 pages，如hongchenglong.gitee.io？<br><strong>需要建立一个与自己个性地址同名的项目</strong>，<br>我的<strong>个性地址</strong>就是<code>https://gitee.com/hongchenglong</code>里的<code>hongchenglong</code><br>参考码云帮助文档：<a href="http://git.mydoc.io/?t=154714&amp;tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">http://git.mydoc.io/?t=154714&amp;tdsourcetag=s_pctim_aiomsg</a><br>码云的速度很快，缺点是每次部署都要去码云Pages手动<strong>更新</strong></p><h2 id="设置网站的图标Favicon"><a href="#设置网站的图标Favicon" class="headerlink" title="设置网站的图标Favicon"></a>设置网站的图标Favicon</h2><p><a href="https://www.jianshu.com/p/82c1d33420ba" target="_blank" rel="noopener">https://www.jianshu.com/p/82c1d33420ba</a></p><h2 id="hexo在添加新文章的时候添加categories"><a href="#hexo在添加新文章的时候添加categories" class="headerlink" title="hexo在添加新文章的时候添加categories"></a>hexo在添加新文章的时候添加categories</h2><p>修改<code>/scaffolds/post.md</code>，这是文章模板</p><h2 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h2><ol><li>语句含义<br><code>home: / || home</code>中的<code>|| home</code>表示会到自带库里找到home这个图标并展示。</li><li>改成中文<br>主目录下的配置文件<code>_config.yml</code>中修改language的值，改成<code>language: zh-CN</code></li><li>如果修改过文件内容，需要通过如下命令清除已经生成的静态文件，重新生成！<br><code>hexo clean</code></li><li>部署到Gitee上，每次修改都要去码云Pages手动<strong>更新</strong>master分支</li><li>初始化一个Hexo，<code>hexo init blog</code></li><li>多标签，<code>tags: [标签1,标签2,标签3]</code></li><li>写新博客前记得加上<code>&lt;!-- more --&gt;</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习笔记</title>
    <link href="/2020/02/02/Git_notes/"/>
    <url>/2020/02/02/Git_notes/</url>
    
    <content type="html"><![CDATA[<p>学习<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰的Git教程</a>所做笔记。</p><p><a href="https://backlog.com/git-tutorial/cn/intro/intro1_1.html" target="_blank" rel="noopener">猴子都能懂的GIT入门</a>、<a href="http://git-scm.com" target="_blank" rel="noopener">Git的官方网站</a></p><p>外国网友制作的<a href="https://gitee.com/liaoxuefeng/learn-java/raw/master/teach/git-cheatsheet.pdf" target="_blank" rel="noopener">Git Cheat Sheet</a></p><meta name="referrer" content="no-referrer"><a id="more"></a><h1 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h1><p>Git是目前世界上最先进的<strong>分布式版本控制系统</strong>。由Linus使用C写成。</p><h2 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a>版本库</h2><p>版本库又名仓库，英文名<strong>repository</strong>。<br>初始化一个Git仓库，使用<code>git init</code>命令。<br>添加文件到Git仓库，分两步：</p><ol><li>使用命令<code>git add</code>，注意，可反复多次使用，添加多个文件；</li><li>使用命令<code>git commit -m &quot;&lt;message&gt;&quot;</code>，完成。(-m后面输入的是本次提交的说明)</li></ol><p>注意：</p><ul><li>目录名尽量不使用中文。</li><li>强烈建议使用标准的UTF-8编码。</li><li>版本控制系统是没法跟踪Word文件的改动。</li><li><code>.git</code>目录是Git来跟踪管理版本库的，尽量不要去改动。</li></ul><h1 id="时光机回溯"><a href="#时光机回溯" class="headerlink" title="时光机回溯"></a>时光机回溯</h1><ul><li>要随时掌握工作区的状态，使用<code>git status</code>命令。</li><li>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</li><li><code>git diff</code>查看文件在工作目录与暂存区的差别。</li></ul><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><ul><li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard</code>。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li></ul><h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p>工作区（Working Directory）：在电脑里能看到的目录。<br>版本库（Repository）：隐藏目录<code>.git</code>。<br>其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><p><img src="https://img2018.cnblogs.com/blog/1677222/202002/1677222-20200214213914797-1652178625.png" srcset="/img/loading.gif" alt="img"></p><p>文件往Git版本库里添加的时候，是分两步执行的：<br>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到<strong>暂存区</strong>；<br>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到<strong>当前分支</strong>。<br><strong>需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</strong></p><h2 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h2><p>为什么Git比其他版本控制系统设计得优秀，因为<strong>Git跟踪并管理的是修改</strong>，而非文件。<br>每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中。</p><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><ul><li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout --</code>。</li><li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD</code>，就回到了场景1，第二步按场景1操作。</li><li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，使用命令<code>git reset --hard</code>，不过前提是没有推送到远程库。</li></ul><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>想要在github上面删除，但又不想在本地删除</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-symbol">$</span> git rm -r --cached &lt;<span class="hljs-keyword">file</span>&gt;  # --cached不会删除本地的<span class="hljs-keyword">file</span><br><span class="hljs-symbol">$</span> git commit -m <span class="hljs-string">'delete &lt;file&gt;'</span><br><span class="hljs-symbol">$</span> git push -u origin master<br></code></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><code>git checkout --</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</li><li>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</li></ul><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><p>本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p><ol><li>创建SSH Key。<code>$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></li><li>打开<code>git bash</code>，输入<code>cat ~/.ssh/id_rsa.pub</code>即可查看ssh公钥。</li><li>“Add SSH Key”，在Key文本框里粘贴id_rsa.pub文件的内容。</li></ol><h3 id="何谓公钥"><a href="#何谓公钥" class="headerlink" title="何谓公钥"></a>何谓公钥</h3><ol><li>很多服务器都是需要认证的，ssh认证是其中的一种。在客户端生成公钥，把生成的公钥添加到服务器，你以后连接服务器就不用每次都输入用户名和密码了。</li><li>很多git服务器都是用ssh认证方式，你需要把你生成的公钥发送给代码仓库管理员，让他给你添加到服务器上，你就可以通过ssh自由地拉取和提交代码了。</li></ol><h3 id="为什么GitHub需要SSH-Key呢？"><a href="#为什么GitHub需要SSH-Key呢？" class="headerlink" title="为什么GitHub需要SSH Key呢？"></a>为什么GitHub需要SSH Key呢？</h3><p>因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><ul><li>要关联一个远程库，使用命令<code>git remote add origin git@github.com:&lt;server-name&gt;/&lt;repo-name&gt;.git</code>；</li><li>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</li><li>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；(远程库的名字就是origin，这是Git默认的叫法)</li><li>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作。</li></ul><h2 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h2><ul><li>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。</li><li>Git支持多种协议，包括<code>https</code>，但通过<code>ssh</code>支持的原生<code>git</code>协议速度最快。</li></ul><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="创建于合并分支"><a href="#创建于合并分支" class="headerlink" title="创建于合并分支"></a>创建于合并分支</h2><p><img src="https://img2018.cnblogs.com/blog/1677222/202002/1677222-20200215032332010-1516736742.png" srcset="/img/loading.gif" alt="img"></p><ul><li>查看分支：<code>git branch</code></li><li>创建分支：<code>git branch</code></li><li>切换分支：<code>git checkout</code>或者<code>git switch</code></li><li>创建+切换分支：<code>git checkout -b</code>或者<code>git switch -c</code></li><li>合并某分支到当前分支：<code>git merge</code></li><li>删除分支：<code>git branch -d</code></li><li>删除远程分支：<code>git push origin --delete</code></li></ul><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p><img src="https://img2018.cnblogs.com/blog/1677222/202002/1677222-20200215033101385-1093798650.png" srcset="/img/loading.gif" alt="img"></p><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。<br>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。<br>用<code>git log --graph</code>命令可以看到分支合并图。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br><span class="hljs-section">本地代码<br>=======</span><br>远程仓库代码<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; commmit id<br></code></pre></td></tr></table></figure><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，==分割线上方是本地数据库的内容，下方是远程数据库的编辑内容。</p><h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><p><img src="https://img2018.cnblogs.com/blog/1677222/202002/1677222-20200215033530403-1782330777.png" srcset="/img/loading.gif" alt="img"></p><p>Git分支十分强大，在团队开发中应该充分应用。<br>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p><h2 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h2><ul><li>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</li><li>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场；</li><li>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</li></ul><h2 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h2><ul><li>开发一个新feature，最好新建一个分支；</li><li>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D</code>强行删除。</li></ul><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。可以用<code>git branch</code>命令看看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch<br>* master<br></code></pre></td></tr></table></figure><p>现在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -b dev origin/dev<br></code></pre></td></tr></table></figure><p>因此，多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to origin/</code>。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><p><code>git diff a b</code>，基于a来看b有什么变化。如<code>-hello</code>，表示基于a分支，b少了<code>hello</code>。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>远程库信息，使用<code>git remote -v</code>；</li><li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li><li>从本地推送分支，使用<code>git push origin</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</li><li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li><li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li><li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li></ul><h2 id="Rebase-变基"><a href="#Rebase-变基" class="headerlink" title="Rebase(变基)"></a>Rebase(变基)</h2><ul><li><code>git rebase</code>操作可以把本地未push的分叉提交历史整理成直线；</li><li>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</li></ul><h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。<br>tag是一个让人容易记住的有意义的名字，如v1.0，它跟某个commit绑在一起。</p><h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><ul><li>命令<code>git tag</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</li><li>命令<code>git tag -a  -m &quot;blablabla...&quot;</code>可以指定标签信息；</li><li>命令<code>git tag</code>可以查看所有标签。</li></ul><h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2><ul><li>命令<code>git push origin</code>可以推送一个本地标签；</li><li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li><li>命令<code>git tag -d</code>可以删除一个本地标签；</li><li>命令<code>git push origin: refs/tags/</code>可以删除一个远程标签。</li></ul><h1 id="使用GitHub"><a href="#使用GitHub" class="headerlink" title="使用GitHub"></a>使用GitHub</h1><p>点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：<br><code>git clone git@github.com:/bootstrap.git</code><br>一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。</p><p>当你提交一个 Pull Request 的时候，你做的事情是 请求（request） 另一个开发者（比如项目维护者）来 拉取（pull） 你仓库中的一个分支到他们的仓库。</p><p>你的仓库会被默认设置为<strong>源仓库</strong>（head fork），被询问指定源分支（compare）、目标仓库（base fork）和目标分支（base）。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>在GitHub上，可以任意Fork开源仓库；</li><li>自己拥有Fork后的仓库的读写权限；</li><li>可以推送pull request给官方仓库来贡献代码。</li></ul><h1 id="使用Gitee"><a href="#使用Gitee" class="headerlink" title="使用Gitee"></a>使用Gitee</h1><p>如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——Gitee（gitee.com）。<br>用<code>git remote -v</code>查看远程库信息。<br>由于远程库不能同名，要先删除已有的GitHub远程库。<code>git remote rm origin</code><br>再分别关联GitHub和Gitee：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote add github git@github.com:&lt;server-name&gt;/&lt;repo-name&gt;.git<br>$ git remote add gitee git@gitee.com:&lt;server-name&gt;/&lt;repo-name&gt;.git<br></code></pre></td></tr></table></figure><p>或修改远程仓库名:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote rename origin github<br></code></pre></td></tr></table></figure><p>之后推送，使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push github master<br>$ git push gitee master<br></code></pre></td></tr></table></figure><h1 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h1><p><code>$ git config --global color.ui true</code>让Git显示颜色</p><h2 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h2><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">/*<br><span class="hljs-addition">!.gitignore</span><br></code></pre></td></tr></table></figure><p>忽略根目录下所有文件，除了<code>.gitignore</code></p><ul><li>忽略某些文件时，需要编写<code>.gitignore</code>；</li><li><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理！</li></ul><h2 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h2><p>用st表示status：<code>$ git config --global alias.st status</code><br>很多人都用co表示checkout，ci表示commit，br表示branch：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global alias.co checkout<br>$ git config --global alias.ci commit<br>$ git config --global alias.br branch<br></code></pre></td></tr></table></figure><p>配置一个git last，让其显示最后一次提交信息：<br><code>$ git config --global alias.last &#39;log -1&#39;</code><br><code>--global</code>参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</p><h2 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h2><h1 id="使用Source-Tree"><a href="#使用Source-Tree" class="headerlink" title="使用Source Tree"></a>使用Source Tree</h1><h1 id="QUESTION"><a href="#QUESTION" class="headerlink" title="QUESTION"></a>QUESTION</h1><p><a href="https://gitee.com/help/articles/4110#article-header0" target="_blank" rel="noopener">Git的基本概念/常用命令及实例</a></p><p><a href="https://blog.csdn.net/qq1332479771/article/details/56087333" target="_blank" rel="noopener">Git Fork后与源作者同步更新</a></p><p><a href="https://gitee.com/help/articles/4194" target="_blank" rel="noopener">如何解决代码冲突</a></p><p><a href="https://blog.csdn.net/ShuSheng0007/article/details/80791849" target="_blank" rel="noopener">实际项目中如何使用Git做分支管理</a></p><p><a href>git merge：删除我要保留的文件！</a><br>切换到dev分支时，删除master分支想保留的文件，需注意，修改master分支中的文件，以便与dev主干中的删除发生合并冲突。</p><p><span style="color:red">删除时，需注意<code>.gitignore</code>里写的文件</span>。</p><p><a href="https://www.jianshu.com/p/80542dc3164e" target="_blank" rel="noopener">git diff 命令详解</a></p><p>github提交代码却没有显示绿格子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config user.email<br>$ git config --global user.email <span class="hljs-string">"oeong@foxmail.com"</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/1998/09/29/hello-world/"/>
    <url>/1998/09/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
