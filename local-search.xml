<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>精读论文——《Deep Residual Learning for Image Recognition》</title>
    <link href="/2022/02/08/DeepLearning/ResNet/"/>
    <url>/2022/02/08/DeepLearning/ResNet/</url>
    
    <content type="html"><![CDATA[<p>为了解决深度学习的退化问题，作者提出了深度残差学习框架，让网络层去拟合残差映射。</p><a id="more"></a><h1 id="Deep-Residual-Learning-for-Image-Recognition"><a href="#Deep-Residual-Learning-for-Image-Recognition" class="headerlink" title="Deep Residual Learning for Image Recognition"></a>Deep Residual Learning for Image Recognition</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>更深层的神经网络更难训练。作者提出了一个残差学习框架，对输入层的残差函数进行学习。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>DCNN在图像分类上带来一系列突破。但是随着神经网络层数越深，训练误差越大，因此测试误差越大。</p><img src="https://gitee.com/oeong/picgo/raw/master/images/20220202190314.png" alt="image-20220202190303077" style="zoom: 80%;"><p><code>Is learning better networks as easy as stacking more layers?</code> 堆叠更多的层数以后网络是否学习效果更好？但是堆叠更多的层后往往会遇到<code>vanishing/exploding gradients</code>问题，会从一开始就阻止收敛。好在这个问题可以通过<code>normalized initialization and intermediate normalization layers</code>来解决。</p><p>当网络开始收敛时，往往会出现退化<code>degradation</code>现象。随着网络深度的增加，准确率趋近饱和，然后迅速下降。意外的是，这不是由于过拟合<code>overfitting</code>造成的，更深的模型反而会有更高的训练误差。</p><p>为了==解决深度学习的退化问题==，作者提出了深度残差学习框架，让网络层去拟合残差映射。如果我们想要得到的映射为 $\mathcal{H}(\mathbf{x})$，则我们让添加的非线性网络层去拟合残差映射 $\mathcal{F}(\mathbf{x}):=\mathcal{H}(\mathbf{x})-\mathbf{x}$，则原始的映射就可以写成 $\mathcal{F}(\mathbf{x})+\mathbf{x}$。残差映射的实现可以通过图2所示的连接块实现，跳跃连接是一个<strong>恒等映射</strong>，没有引入额外的参数和计算复杂度，整个网络很容易实现。</p><img src="https://gitee.com/oeong/picgo/raw/master/images/20220202194810.png" alt="image-20220202194803965" style="zoom:80%;"><p>在<code>ImageNet</code>、<code>CIFAR-10</code>、<code>COCO</code>数据集上，大量的实验结果表明作者设计的<code>残差学习框架</code>的通用性，一方面不仅使得网络更容易优化，另一方面随着网络深度的增加，网络复杂度并没有明显增加，准确率却会提高很多。</p><h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><h3 id="Residual-Representations"><a href="#Residual-Representations" class="headerlink" title="Residual Representations."></a>Residual Representations.</h3><p>在图像识别中，VLAD是由相对于字典的残差向量编码的表示，并且费舍尔向量可以被表示为VLAD的概率版本。</p><h3 id="Shortcut-Connections"><a href="#Shortcut-Connections" class="headerlink" title="Shortcut Connections."></a>Shortcut Connections.</h3><p>训练多层感知器(MLP)的早期实践是添加从网络输入到输出的线性层。</p><h2 id="3-Deep-Residual-Learning"><a href="#3-Deep-Residual-Learning" class="headerlink" title="3. Deep Residual Learning"></a>3. Deep Residual Learning</h2><h3 id="3-1-Residual-Learning"><a href="#3-1-Residual-Learning" class="headerlink" title="3.1. Residual Learning"></a>3.1. Residual Learning</h3><h3 id="3-2-Identity-Mapping-by-Shortcuts"><a href="#3-2-Identity-Mapping-by-Shortcuts" class="headerlink" title="3.2. Identity Mapping by Shortcuts"></a>3.2. Identity Mapping by Shortcuts</h3><h3 id="3-3-Network-Architectures"><a href="#3-3-Network-Architectures" class="headerlink" title="3.3. Network Architectures"></a>3.3. Network Architectures</h3><h4 id="Plain-Network"><a href="#Plain-Network" class="headerlink" title="Plain Network."></a>Plain Network.</h4><h4 id="Residual-Network"><a href="#Residual-Network" class="headerlink" title="Residual Network."></a>Residual Network.</h4><p>网络设计原则为：对于相同的输出特征图尺寸，卷积层具有相同数量的卷积核；如果特征图尺寸减半，则卷积核数量加倍，以便保持每层的时间复杂度。通过步长为2的卷积层直接执行下采样。下面以<code>ResNet-34</code>为例进行介绍：</p><p>第一个卷积层，卷积核大小为 7 × 7，卷积核个数为64，步长为2；<br>三个残差连接块，每一个连接块由两层卷积网络组成，卷积核大小为 3 × 3，卷积核个数为64；<br>四个残差连接块，每一个连接块由两层卷积网络组成，卷积核大小为 3 × 3，卷积核个数为128；<br>六个残差连接块，每一个连接块由两层卷积网络组成，卷积核大小为 3 × 3，卷积核个数为256；<br>三个残差连接块，每一个连接块由两层卷积网络组成，卷积核大小为 3 × 3，卷积核个数为512；<br>最后一个全连接层，整个网络包含卷积层和全连接层，共 1+(3+4+6+3)*2+1 = 34层。</p><p><img src="https://gitee.com/oeong/picgo/raw/master/images/20220208175344.png" alt="image-20220208175331741"></p><p>从表1可以看到，<code>ResNet-18</code>和<code>ResNet-34</code>具有相同的残差连接块，每个连接块包含两个卷积层。而<code>ResNet-50/101/152</code>的每个连接块包含3个卷积层。作者把这种连接块称为<code>bottleneck</code>（如下图所示），这里主要使用了1 × 1 的卷积核，主要是用于<strong>匹配特征图维度</strong>以及从实践出发能够承担的起训练时间。</p><img src="https://gitee.com/oeong/picgo/raw/master/images/20220208175643.png" alt="image-20220208175641450" style="zoom:80%;"><h3 id="3-4-Implementation"><a href="#3-4-Implementation" class="headerlink" title="3.4. Implementation"></a>3.4. Implementation</h3><p>作者参考<code>AlexNet</code>和<code>VGG</code>来进行训练。首先对图像的短边进行尺度扩大，扩大到 [256, 480]，然后和AlexNet一样，随机选择 224 × 224 大小的图案。作者在这里使用到了<code>batch normalization</code> (BN) 技术；初始化权重并从零开始训练。梯度下降使用了<code>SGD</code>，<code>mini-batch</code>大小为256，总共进行了 $60\times10^4$ 次迭代。为了得到最好的实验结果，作者在多个尺度上进行评估，然后取平均分。</p><h2 id="4-Experiments"><a href="#4-Experiments" class="headerlink" title="4. Experiments"></a>4. Experiments</h2><h3 id="4-1-ImageNet-Classification"><a href="#4-1-ImageNet-Classification" class="headerlink" title="4.1. ImageNet Classification"></a>4.1. ImageNet Classification</h3><p>首先评估了<code>plain-18/34</code>两个网络，从表2可以看到，<code>plain-34</code>网络比<code>plain-18</code>有更高的错误率，从图4左图也可以看到，在训练过程中，出现了退化现象，随着网络深度的增加，训练误差反而变大。作者在论文中解释到：退化现象应该不是梯度消失引起的，因为整个训练使用了BN来训练，也查验了反向传播时梯度幅值也是正常的，作者怀疑可能是因为更深的网络有着更低的收敛速度，影响着训练误差的减小，这个问题未来会进一步研究。</p><p>接着是ResNet-18/34两个网络的评估，从表2和图4右图可以观察到三个现象：1. 网络越深，训练误差反而越小，退化问题可以通过残差学习得到解决；2. 与plain-34网络相比，训练误差下降了3.5%，随着网络深度的不断增加，网络性能进一步提高；3. 与palin-18/34网络相比，残差网络收敛速度更快。</p><img src="https://gitee.com/oeong/picgo/raw/master/images/20220208185250.png" alt="image-20220208185249741" style="zoom:80%;"><p>然后是<code>恒等跳跃连接和投影跳跃连接</code>的对比，可以看到三种连接都有助于提高网络性能，但是为了不增加网络结构的复杂度，作者这里主要选择恒等跳跃连接进行后续的实验。</p><p>下面是ResNet-50/101/152网络的评估，首先可以看到，尽管网络深度不断增加，但是复杂度依然低于VGG-16/19。随着网络深度的不断增加，错误率不断下降，同时在训练过程中也没有出现退化现象，在单个模型上取得了4.49%的错误率，在ImageNet2015比赛上，通过集成6个不同的模型，取得了3.57%的错误率。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p><strong>残差结构与传统结构的本质区别在哪？输出是否一致呢？</strong></p><p>plain Net：building block的映射F(x)拟合H(x)，即F(x) := H(x)</p><p>Res Net：加入了skip connection 结构，此时 building block 的任务：F(x) := H(x)-x</p><p><strong>残差结构为什么比传统结构更好优化？</strong></p><p>提升了对梯度与损失的相关性，进而使网络的学习能力增强，解决退化问题。</p><p>比如把5映射到5.1，那么引入残差前是F’(5)=H(5)=5.1，引入残差后是H(5)=F(5)+5=5.1, F(5)=0.1。这里的F’和F都表示网络参数映射，引入残差后的映射对输出的变化更敏感。</p><p>比如输出从5.1变到5.2，映射F’的输出增加了1/51=2%，而对于残差结构输出从5.1到5.2，映射F是从0.1到0.2，增加了100%。明显后者输出变化对权重的调整作用更大，所以效果更好。<strong>训练残差的思想是去掉相同的主体部分，从而突出微小的变化，残差网络可以看做是差分放大器。</strong></p><p><strong>为什么残差网络可以进一步解决梯度消失？</strong></p><p>反向传播时，由于层数过深，很容易出现梯度问题。ResNet将BP过程中梯度相乘变成相加，便解决了梯度问题。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><p><code>ResNet</code>论文链接为：<a href="http://xxx.itp.ac.cn/pdf/1512.03385.pdf">https://arxiv.org/abs/1512.03385</a></p></li><li><p><a href="https://blog.csdn.net/cg129054036/article/details/120934900">https://blog.csdn.net/cg129054036/article/details/120934900</a></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Deep Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习入门</title>
    <link href="/2022/01/07/DeepLearning/deep-learning/"/>
    <url>/2022/01/07/DeepLearning/deep-learning/</url>
    
    <content type="html"><![CDATA[<p>深度学习是机器学习的一个分支，用于建立、模拟人脑进行分析学习的神经网络，并模仿人脑的机制来解释数据。</p><a id="more"></a><h2 id="1-深度学习基础"><a href="#1-深度学习基础" class="headerlink" title="1 深度学习基础"></a>1 深度学习基础</h2><p>人工智能包含机器学习，而机器学习又包含深度学习</p><ul><li><p>人工智能是指拥有人的智能，能做出<strong>与人类智能相似反应</strong>的智能机器</p></li><li><p>机器学习可以被定义为<strong>从数据中总结经验</strong>，找出某种规律或者模型，利用这些经验、规律或者模型来解决实际问题。</p></li><li><p>深度学习是机器学习的一个分支。源于对人工神经网络（ANN）的研究，其动机在于建立、模拟人脑进行分析学习的<strong>神经网络</strong>，<strong>模仿人脑的机制来解释</strong>图像、声音和文本等<strong>数据</strong>。</p></li></ul><p>为什么以神经网络为核心的深度学习直到近几年才得到如此迅速的发展呢?</p><ol><li><p>大数据的涌现。机器学习一样，深度学习也是基于数据的学习，数据量越大，训练的模型就越准确。</p></li><li><p>计算机硬件水平提高。</p></li><li><p>算法的改进。</p></li></ol><h2 id="2-PyTorch"><a href="#2-PyTorch" class="headerlink" title="2 PyTorch"></a>2 PyTorch</h2><h3 id="2-1-PyTorch概述"><a href="#2-1-PyTorch概述" class="headerlink" title="2.1 PyTorch概述"></a>2.1 PyTorch概述</h3><p>PyTorch可以拆分成两部分：Py和Torch。Py就是Python，Torch是一个有大量机器学习算法支持的科学计算框架。可以把PyTorch看成是支持GPU运算的Numpy，且可以用来搭建和训练深度神经网络。</p><p>torch就是PyTorch的核心库，torchvision包是服务于PyTorch深度学习框架的，用来生成图片、视频数据集、一些流行的模型类和预训练模型。</p><h3 id="2-2-张量"><a href="#2-2-张量" class="headerlink" title="2.2 张量"></a>2.2 张量</h3><p>张量（tensor）是PyTorch里基础的运算单位，即多维数组。类似Numpy的数组，但是张量可以在GPU上运算。</p><p>PyTorch中的张量与NumPy数组可以互相转化，而且两者共享内存位置，如果一个发生改变，另一个也随之改变。</p><p><strong>新建的张量默认保存在CPU里</strong>，如果安装了GPU版本的PyTorch，就可以将张量移动到GPU里。</p><p>反向传播求导数，自动求导(autograd)模块可以为张量自动提供微分，<code>tensor.requires_grad=True</code></p><h3 id="2-3-torch-nn和torch-optim"><a href="#2-3-torch-nn和torch-optim" class="headerlink" title="2.3 torch.nn和torch.optim"></a>2.3 torch.nn和torch.optim</h3><p>PyTorch中，训练神经网络离不开两个重要的包：torch.nn和torch.optim。</p><ul><li><p>torch.nn是专门为神经网络设计的模块化接口，构建于自动求导模块的基础上，可用来定义和运行神经网络。</p></li><li><p>torch.optim是一个实现了各种优化算法的库，包括最简单的梯度下降（Gradient Descent，GD）、随机梯度下降（<strong>Stochastic</strong> Gradient Descent，SGD）及其他更复杂的优化算法。</p></li></ul><p>损失函数用于计算每个实例的输出与真实样本的标签是否一致，并评估差距的大小。最简单的是均方误差<code>nn.MSELoss()</code>。</p><h3 id="2-4-线性回归"><a href="#2-4-线性回归" class="headerlink" title="2.4 线性回归"></a>2.4 线性回归</h3><p>线性回归一般用于数值预测，线性回归算法就是要找出这样一条拟合线或拟合面，能够<strong>最大限度地拟合真实的数据分布</strong>。</p><p>代价函数是所有样本损失函数的平均。代价函数与损失函数的唯一区别，前者针对整个训练集，后者针对单个样本。</p><p>如何最小化代价函数J呢？最简单的方法就是使用梯度下降算法，其核心思想是在函数曲线上的<strong>某一点</strong>，函数沿梯度方向具有<strong>最大的变化率</strong>，那么<strong>沿着负梯度方向移动会不断逼近最小值</strong>，这样一个迭代的过程可以最终实现代价函数的最小化目标。</p><p><strong>通过model.eval()函数将模型由训练模式变为测试模式</strong></p><p>.detach()用于停止对张量的梯度跟踪</p><h2 id="3-TensorFlow"><a href="#3-TensorFlow" class="headerlink" title="3 TensorFlow"></a>3 TensorFlow</h2><h3 id="3-1-TensorFlow概述"><a href="#3-1-TensorFlow概述" class="headerlink" title="3.1 TensorFlow概述"></a>3.1 TensorFlow概述</h3><p>TensorFlow也可以拆分成两部分：Tensor+Flow。Tensor即张量，可以在GPU中运行的多维数组；Flow是流，TensorFlow是一个<strong>采用数据流图进行数值计算</strong>的开源软件库。</p><p>TensorFlow的基本原理是基于图运算，而且可以将一个计算图划分成多个子图，然后在多个CPU或者GPU上并行地执行。</p><p>可移植性、可视化（TensorBoard）</p><p>如果安装GPU版本的TensorFlow，计算机中需要有一块NVIDIA的GPU显卡并安装了显卡驱动。在安装TensorFlow之前，需要提前安装CUDA和CUDNN。</p><h3 id="3-2-张量"><a href="#3-2-张量" class="headerlink" title="3.2 张量"></a>3.2 张量</h3><p>TensorFlow中，张量的数学运算和普通计算是不同的，<strong>保存的是计算过程</strong>而非计算结果，需要<strong>在会话中计算结果</strong>。</p><h3 id="3-3-数据流图"><a href="#3-3-数据流图" class="headerlink" title="3.3 数据流图"></a>3.3 数据流图</h3><p>TensorFlow是一个采用数据流图进行数值计算的深度学习框架</p><p>使用tf.constant()创建的张量都是常量，一旦创建后其中的值就不能改变了</p><p>tf.Variable创建变量</p><h3 id="3-4-会话"><a href="#3-4-会话" class="headerlink" title="3.4 会话"></a>3.4 会话</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">init = tf.global_variables_initializer()  <span class="hljs-comment"># 定义全局初始化节点</span><br><span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess:￼<br>init.<span class="hljs-built_in">run</span>()<span class="hljs-comment"># 初始化所有变量</span><br><span class="hljs-literal">result</span> = f.eval()<br></code></pre></td></tr></table></figure><p>一个TensorFlow程序通常可以分成两部分：第一部分用来<strong>构建一个数据流图</strong>，称为构建阶段；第二部分用来<strong>执行这个图</strong>，称为执行阶段。</p><p>从外部传入数据，例如训练集，那就需要使用TensorFlow中的占位符来表示，写成<code>tf.placeholder()</code>。</p><h3 id="3-5-线性回归"><a href="#3-5-线性回归" class="headerlink" title="3.5 线性回归"></a>3.5 线性回归</h3><p>均方误差（Mean Squared Error, MSE）均方误差是各数据偏离真实值的距离平方和的平均数，也即<strong>误差平方和的平均数</strong>。</p><p>均方误差（MSE）定义为其损失函数，使用tf.reduce_mean()来计算均方误差</p><p>loss = tf.reduce_mean(tf.square(y_hat - y))</p><h3 id="3-6-TensorBoard"><a href="#3-6-TensorBoard" class="headerlink" title="3.6 TensorBoard"></a>3.6 TensorBoard</h3><p>TensorBoard是TensorFlow的可视化工具，它可以通过TensorFlow程序运行过程中输出的日志文件对TensorFlow程序的运行状态进行可视化。</p><p>通过TensorBoard，我们可以查看模型的<strong>数据流图、损失函数随迭代次数的变化</strong>等。</p><h2 id="4-神经网络基础知识"><a href="#4-神经网络基础知识" class="headerlink" title="4 神经网络基础知识"></a>4 神经网络基础知识</h2><h3 id="4-1-感知机"><a href="#4-1-感知机" class="headerlink" title="4.1 感知机"></a>4.1 感知机</h3><p>感知机是一种最简单的线性二分类模型，是神经网络的基础。</p><p>神经元计算所有<strong>输入信号的加权和</strong>之后，与固定偏置参数b做比较。当输入信号的加权和大于这个阈值时，神经元通路打开，输出为1，否则输出为0。</p><p>将偏置b移到不等式左边。因为b是常数，变换正负号对最终得到的值并无影响。</p><h3 id="4-2-多层感知机"><a href="#4-2-多层感知机" class="headerlink" title="4.2 多层感知机"></a>4.2 多层感知机</h3><p>对于稍微复杂一点的逻辑电路，线性感知机是无法处理的，此时就需要使用多层感知机MLP。</p><p><strong>感知机无法处理异或问题</strong>，无法在二维平面上找到一条直线进行完全正确的分类</p><p>异或门可以由与门和或门搭建</p><p>两层感知机可实现对非线性异或逻辑的划分，得到的分类线不再是一条直线，而是一条曲线</p><p>通过叠加感知机能够进行非线性的表示，神经网络就是由多层感知机发展并优化而来的</p><h3 id="4-3-逻辑回归"><a href="#4-3-逻辑回归" class="headerlink" title="4.3 逻辑回归"></a>4.3 逻辑回归</h3><p>感知机是神经网络的基础，多层感知机MLP与神经网络非常相似。</p><p>阶跃函数(大于0为正，小于0为负)有个缺点，既<strong>在s=0处是不可导的，无法计算梯度</strong>，也就无法使用梯度下降算法来确定模型参数wi和b。</p><p>使用Sigmoid函数代替阶跃函数，不仅让函数连续，可利用梯度下降算法，而且引入了概率来表示预测为正类的把握有多大。</p><p>最大化问题转换为最小化问题。最终的目标，即最小化-log(P(y|x))。通常把-log(P(y|x))称为损失函数</p><p>交叉熵损失，实际反映了真实标签y与预测值￼之间的差距</p><img src="https://gitee.com/oeong/picgo/raw/master/images/20220119000630.png" alt="image-20220111082848154" style="zoom:33%;"><p>代价函数：所有损失函数的均值</p><img src="https://gitee.com/oeong/picgo/raw/master/images/20220119000634.png" alt="image-20220111082731335" style="zoom:33%;"><p><strong>逻辑回归的目标就是最小化代价函数J，并计算出此时对应的模型参数w和b。</strong></p><p>梯度下降，下山的方向就是梯度的负方向。梯度就是某一个函数在该点处的方向导数沿着该方向取得的最大值，即函数在当前位置的导数。</p><h2 id="5-神经网络"><a href="#5-神经网络" class="headerlink" title="5 神经网络"></a>5 神经网络</h2><p><strong>神经网络是多层感知机MLP与逻辑回归结合和优化的模型，MLP用于拟合函数，逻辑回归用于更新权重。</strong></p><h3 id="5-1-基本结构"><a href="#5-1-基本结构" class="headerlink" title="5.1 基本结构"></a>5.1 基本结构</h3><p>之所以称之为两层神经网络，是因为一般不把输入层考虑在内。</p><p><strong>神经元是一个非线性单元</strong>，它的结构类似于一个逻辑回归模型，<strong>由线性单元和非线性单元组成</strong>。</p><p>z=$w_1x_1$+$w_2x_2$+$b$表示线性运算，a=g(z)表示非线性运算。</p><h3 id="5-2-前向传播"><a href="#5-2-前向传播" class="headerlink" title="5.2 前向传播"></a>5.2 前向传播</h3><p>前向传播过程，即神经网络从输入层到输出层的计算过程。</p><h3 id="5-3-激活函数"><a href="#5-3-激活函数" class="headerlink" title="5.3 激活函数"></a>5.3 激活函数</h3><p>神经元包含了非线性计算，用g(•)来表示</p><p>单个神经元实现的功能就相当于逻辑回归。</p><p>ReLU（Rectified Linear Unit，<strong>修正线性单元</strong>），z&gt;0时梯度恒为1</p><p>Leaky ReLU函数与ReLU函数的区别仅在于当z≤0时，<strong>a不恒为0，而是有一个较小的梯度</strong>，此处为0.01，不唯一。这样做的好处是始终保持梯度不为0。</p><p>对于隐藏层的激活函数，一般来说，tanh函数要比Sigmoid函数的表现更好一些</p><p>而对于输出层的激活函数，因为二分类问题的输出取值为{0, 1}，所以一般会选择Sigmoid作为激活函数。就是<strong>当激活值|z|很大的时候，激活函数的斜率（梯度）很小</strong></p><p>在隐藏层，<strong>选择ReLU作为激活函数能够保证z&gt;0时梯度始终为1</strong>，从而提高神经网络梯度下降算法的运算速度。存在梯度为0的缺点，实际应用中，这个缺点的影响不是很大。</p><p>如果所有隐藏层都使用线性激活函数，只有输出层使用非线性激活函数，那么整个神经网络的结构就类似于一个简单的逻辑回归模型，相当于只使用一个神经元。</p><h3 id="5-4-反向传播"><a href="#5-4-反向传播" class="headerlink" title="5.4 反向传播"></a>5.4 反向传播</h3><p>神经网络经过前向传播之后，接下来就可以计算其损失函数。<strong>反向传播是对神经网络输出层、隐藏层的参数W和b计算偏导数的过程。</strong></p><p>点乘要求参与运算的两个量两必须是维数相同，是对应元素的相乘。</p><p>矩阵相乘要求内维相同，也即前一个矩阵的列的维数等于后一个矩阵的行的维数。</p><h3 id="5-5-更新参数"><a href="#5-5-更新参数" class="headerlink" title="5.5 更新参数"></a>5.5 更新参数</h3><p>神经网络完成反向传播之后，得到了各层的参数梯度$d_W$和$d_b$。需要根据梯度下降算法对参数W和b进行更新。</p><p>经过前向传播、反向传播、更新参数之后，神经网络的一次训练就完成了。经过N次迭代训练，参数W和b会不断更新，并接近全局最优解。</p><h3 id="5-6-初始化"><a href="#5-6-初始化" class="headerlink" title="5.6 初始化"></a>5.6 初始化</h3><p>神经网络中的参数W不能初始化为0，b可以。</p><p>隐藏层3个神经元完全对称，效果相同。这样的话，隐藏层设置多个神经元就没有任何意义了</p><p>神经网络的权重系数W一般不会初始化为零，可以进行随机初始化。但是，偏置项系数b一般可以初始化为零，并不会影响神经网络的训练效果</p><h2 id="6-深层神经网络"><a href="#6-深层神经网络" class="headerlink" title="6 深层神经网络"></a>6 深层神经网络</h2><p>与逻辑回归相比，神经网络可以实现非线性分类，效果非常好。</p><h3 id="6-1-深层神经网络的优势"><a href="#6-1-深层神经网络的优势" class="headerlink" title="6.1 深层神经网络的优势"></a>6.1 深层神经网络的优势</h3><p>即便是单隐藏层神经网络，只要隐藏层有足够多的神经元，神经网络的宽度足够大，那么该神经网络复杂度就高，就能拟合任意复杂的函数</p><p>并不是神经网络越宽越好，神经网络的强大能力主要由于神经网络足够“深”</p><p>神经网络的输入是一张图片，从计算机的角度来看，即一个个像素值。第一层主要从原始图片中提取一些<strong>边缘信息</strong>。第二层将前一层得到的边缘信息进行整合，提取面部的一些<strong>局部特征</strong>。</p><p>实际应用中，我们还是要尽量选择层数较少的神经网络，这样能够有效避免发生过拟合</p><h3 id="6-2-符号标记"><a href="#6-2-符号标记" class="headerlink" title="6.2 符号标记"></a>6.2 符号标记</h3><p>假设神经网络是L层。这里的L为隐藏层和输出层的层数之和，即隐藏层为L-1层。</p><p>Z[l]表示该层线性输出，A[l]表示该层非线性输出</p><h3 id="6-3-前向传播与反向传播"><a href="#6-3-前向传播与反向传播" class="headerlink" title="6.3 前向传播与反向传播"></a>6.3 前向传播与反向传播</h3><p>输出层L中dA[L]的计算公式由交叉熵损失得到</p><img src="https://gitee.com/oeong/picgo/raw/master/images/20220111081038.png" alt="image-20220111081026715" style="zoom:40%;"><img src="https://gitee.com/oeong/picgo/raw/master/images/20220111081037.png" alt="image-20220111080942612" style="zoom:50%;"><h3 id="6-4-多分类函数Softmax"><a href="#6-4-多分类函数Softmax" class="headerlink" title="6.4 多分类函数Softmax"></a>6.4 多分类函数Softmax</h3><p>二分类模型的输出层只有一个神经元，而多分类模型的输出层有多个神经元。</p><p>二分类使用Sigmoid函数，将Z[L]映射到预测概率上。</p><p>多分类使用Softmax函数，将Z[L]映射到区间[0,1]，将其看成概率，各神经元输出概率之和为1。</p><h3 id="6-5-深层神经网络的Python实现"><a href="#6-5-深层神经网络的Python实现" class="headerlink" title="6.5 深层神经网络的Python实现"></a>6.5 深层神经网络的Python实现</h3><p>在<strong>浅层</strong>神经网络中，隐藏层的激活函数选择<strong>tanh</strong>函数，但如果是深层神经网络，隐藏层的激活函数一般选择ReLU函数。</p><p>使用tanh函数，当|Z|很大的时候，激活函数的斜率（梯度）很小。因此，在这个区域内，梯度下降算法会运行得比较慢。而ReLU激活函数在Z&gt;0时梯度始终为1，从而提高梯度下降算法的运算速度。</p><p>参数初始化，权重W随机；前向传播，z=g(Wx+b)，在输出层计算损失；反向传播，对损失loss分别求w和b的偏导，一次性得到所有的梯度，使用梯度下降的思想更新权重W=W-lr*dW</p><h2 id="7-优化神经网络"><a href="#7-优化神经网络" class="headerlink" title="7 优化神经网络"></a>7 优化神经网络</h2><h3 id="7-1-正则化"><a href="#7-1-正则化" class="headerlink" title="7.1 正则化"></a>7.1 正则化</h3><p>欠拟合、适拟合和过拟合</p><p>虽然<strong>预测值与样本实际值完全吻合</strong>，但是该模型在训练样本之外的数据上拟合的效果可能很差，该模型很可能<strong>把噪声也学习了</strong>，这种情况称为过拟合</p><p>欠拟合和过拟合分别对应高偏差和高方差</p><p>偏差度量了算法的期望预测与真实结果的偏离程度；方差度量了训练集的变化导致学习性能的变化，描述了数据扰动造成的影响；噪声则表示任何学习算法的泛化能力的下界</p><p>误差 = 偏差 + 方差 + 噪声</p><p>验证集用来验证不同算法的表现情况，以便从中选择最好的算法模型。</p><p>为了避免发生过拟合，通常需要采取一些方法提高模型的泛化能力。</p><p><strong>正则化就是指在代价函数后加上一个正则化项，正则化项也叫惩罚项。</strong></p><p>L2正则化就是在代价函数后面加上神经网络各层的权重参数<strong>W所有元素的二次方和</strong>。</p><p><strong>一般只对权重参数W进行正则化而不对偏置参数b进行正则化</strong>，原因是一般W的维度很大，而b只是一个常数。</p><p>神经网络模型之所以发生过拟合，是因为参数W普遍比较大。</p><p>L1正则化就是在代价函数后面加上神经网络各层的权重参数W所有元素的<strong>绝对值之和</strong>。</p><p>对于L2正则化来说，限定区域是圆，得到的解w1或w2为0的概率很小，很大概率是非零的；对于L1正则化来说，限定区域是正方形。</p><p>Dropout正则化，顾名思义，是指在深层神经网络的训练过程中，按照一定的概率将每层的神经元暂时从神经网络中丢弃。</p><h3 id="7-2-梯度优化"><a href="#7-2-梯度优化" class="headerlink" title="7.2 梯度优化"></a>7.2 梯度优化</h3><p>批量梯度下降（Batch Gradient Descent，BGD）</p><p>批量是指整个训练集里包含的所有样本。</p><p>随机梯度下降（Stochastic Gradient Descent，SGD）</p><p>小批量梯度下降（Mini-Batch Gradient Descent，MBGD）</p><p>每次epoch训练之前，最好随机打乱所有训练样本</p><p>从性能上来说，小批量梯度下降不比批量梯度下降差，而且小批量梯度下降的运算速度更快一些。<strong>小批量梯度下降</strong>结合了批量梯度下降和随机梯度下降的优点。</p><p>Adam实际上是把动量梯度下降和RMSprop结合起来的一种算法。</p><p>梯度下降算法中的学习率α决定了梯度下降每次更新参数的尺度大小，俗称步进长度。</p><h2 id="8-卷积神经网络"><a href="#8-卷积神经网络" class="headerlink" title="8 卷积神经网络"></a>8 卷积神经网络</h2><h3 id="8-1-为什么选择卷积神经网络"><a href="#8-1-为什么选择卷积神经网络" class="headerlink" title="8.1 为什么选择卷积神经网络"></a>8.1 为什么选择卷积神经网络</h3><p>传统神经网络结构存在以下两个缺点。</p><ol><li><p>输入层维度过大；</p></li><li><p>不符合图像特征提取的机制。</p></li></ol><p>拉伸成一维特征，作为神经网络的输入层，将图片的各个像素点独立开来，<strong>忽略了各个像素点之间的区域性联系</strong>。</p><h3 id="8-2-卷积神经网络的基本结构"><a href="#8-2-卷积神经网络的基本结构" class="headerlink" title="8.2 卷积神经网络的基本结构"></a>8.2 卷积神经网络的基本结构</h3><p>卷积神经网络最基本的结构有三种，分别是卷积层、池化层、全连接层。</p><h3 id="8-3-卷积层"><a href="#8-3-卷积层" class="headerlink" title="8.3 卷积层"></a>8.3 卷积层</h3><p>卷积层（convolutional layer），顾名思义，它实现的是对图片的卷积操作。</p><p>卷积运算的具体操作步骤为：已知原图像和模板图像，首先，将模板图像在原图像中移动；然后，每到一个位置，将原图像与模板图像定义域相交的元素进行<strong>乘积且求和</strong>，得出新的图像点；最后，遍历原图像所有像素点，得到卷积后的图像，整个卷积运算完成。这里的模板图像又称<strong>卷积核</strong>。</p><p>点积(dot product)，也叫点乘。 点积的代数定义:对应元素相乘再求和，结果是一个数</p><p>边缘检测（edge detection）是图像处理中最常用的算法之一，其目的是检测图片中包含的边缘信息</p><p>为了解决图片缩小的问题，可以使用填充的方法，即<strong>对原始图片的尺寸进行扩展</strong>，扩展区域补零</p><p>填充之后，原始图片尺寸扩展为(n+2p)×(n+2p)，卷积核尺寸为f×f，则卷积运算后的图片尺寸为(n+2p-f+1)×(n+2p-f+1)。</p><p>步幅表示卷积核在原图片中每次移动的步长。</p><p>二维平面卷积，针对的是单通道图片。三维卷积运算的基本原理与二维卷积相同，只是增加了一个维度。三维卷积运算需要使用3个卷积核</p><p>1层卷积层提取的是人脸的边缘、线条、轮廓等浅层特征；第2层卷积层提取的是人脸的一些器官，如眼镜、鼻子、耳朵等；第3层卷积层提取的是人脸的整体面部轮廓</p><p>卷积神经网络不同的卷积层会根据网络深浅提取不同层次的特征</p><h3 id="8-4-池化层"><a href="#8-4-池化层" class="headerlink" title="8.4 池化层"></a>8.4 池化层</h3><p>在卷积神经网络中用于减小尺寸，提高运算速度，也能减小噪声的影响，让各特征更具有健壮性。</p><p><strong>最大池化</strong>的做法就是选择一个类似于卷积核的<strong>滤波器算子</strong>，在上一层输出矩阵上滑动；然后，每到一个位置，计算两者定义域相交元素的最大值，作为新的图像点；最后，遍历原图片所有像素点，得到最大池化之后的图片。</p><p>最大池化有两个参数需要注意：一个是滤波器算子（滑动窗）的<strong>尺寸f</strong>，另外一个是滤波器算子每次移动的<strong>步幅s</strong>。</p><p>平均池化就是在滤波器算子滑动区域计算平均值，优点是顾及每一个像素。</p><p>实际应用中，最大池化比平均池化更常用一些。</p><h3 id="8-5-全连接层"><a href="#8-5-全连接层" class="headerlink" title="8.5 全连接层"></a>8.5 全连接层</h3><p>全连接层实际上就是传统的前馈神经元网络结构，一般出现在卷积神经网络的末端，输出层之前。</p><p>单个神经元（二分类）用sigmoid，多个神经元（多分类）用softmax，输出的是预测的概率值。</p><p>卷积层类比眼睛，提取局部特征，全连接层类比大脑，把之前按所有的局部特征重新通过权值矩阵组装成完整的图。</p><p>卷积神经网络的强大之处其实就在于其卷积层强大的特征提取能力</p><h3 id="8-6-卷积神经网络模型"><a href="#8-6-卷积神经网络模型" class="headerlink" title="8.6 卷积神经网络模型"></a>8.6 卷积神经网络模型</h3><p><img src="https://gitee.com/oeong/picgo/raw/master/images/20220117170817.png" alt="image-20220117170814301"></p><p>在卷积层CONV1中，使用的<strong>卷积核</strong>尺寸f=5，卷积核的个数为6个，步幅s=1，则该层输出的尺寸为32-5+1=28，维度为28×28×6。包含的参数个数为(5×5×3+1)×6=456，因为每个卷积核有5×5×3=75个参数，还有1个偏置参数，6个卷积核。</p><p>在池化层POOL1中，使用的<strong>滤波器算子</strong>尺寸f=2，滤波器算子个数为6个，步幅s=2，则该层输出的尺寸为28÷2=14，维度为14×14×6。包含的参数为0，因为池化层没有参数。</p><h3 id="8-7-典型的卷积神经网络模型"><a href="#8-7-典型的卷积神经网络模型" class="headerlink" title="8.7 典型的卷积神经网络模型"></a>8.7 典型的卷积神经网络模型</h3><ul><li>LeNet-5</li></ul><p>卷积层→池化层→卷积层→池化层→全连接层→全连接层→输出层</p><img src="https://gitee.com/oeong/picgo/raw/master/images/20220117163557.png" alt="image-20220117163555524" style="zoom:80%;"><ul><li>AlexNet</li></ul><p>由5个卷积层和3个全连接层组成</p><p>卷积层→池化层→卷积层→池化层→<strong>卷积层→卷积层→卷积层</strong>→池化层→全连接层→全连接层→输出层</p><img src="https://gitee.com/oeong/picgo/raw/master/images/20220117163519.png" alt="image-20220117163457116" style="zoom:80%;"><h2 id="9-循环神经网络"><a href="#9-循环神经网络" class="headerlink" title="9 循环神经网络"></a>9 循环神经网络</h2><p>循环神经网络是一类以序列数据为输入，在序列的演进方向进行递归且所有节点（循环单元）按链式连接的递归神经网络。</p><h3 id="9-1-为什么选择循环神经网络"><a href="#9-1-为什么选择循环神经网络" class="headerlink" title="9.1 为什么选择循环神经网络"></a>9.1 为什么选择循环神经网络</h3><p>使用传统的前馈神经网络解决序列信号问题存在两个困难：</p><ol><li><p>不同样本的输入序列长度或输出序列长度可能不同，即无法确定两句话包含的单词数目一样，这就造成<strong>模型难以统一</strong></p></li><li><p>无法共享序列不同x&lt;t&gt;​之间的特征。如“张三”表示人名，那么句子其他位置出现的“张三”很可能也是人名</p></li></ol><h3 id="9-2-循环神经网络的基本结构"><a href="#9-2-循环神经网络的基本结构" class="headerlink" title="9.2 循环神经网络的基本结构"></a>9.2 循环神经网络的基本结构</h3><p>输入序列中的每个元素x&lt;t&gt;都是一维向量。最常用的方法就是使用独热编码进行处理。每个单词就由维度为10001×的向量组成。该向量对应词汇表顺序，相应单词对应位置数值为1，其他位置数值全为0。每个单词经过独热编码之后，就成了一维向量，向量长度与单词表的长度相同。</p><p>模型中的a&lt;t&gt;是记忆单元，是当前层的输出，同时也作为下一层的输入</p><h3 id="9-3-模型参数"><a href="#9-3-模型参数" class="headerlink" title="9.3 模型参数"></a>9.3 模型参数</h3><p>循环神经网络模型包含三类权重系数，分别是$W_{ax}$、$W_{aa}$、$W_{ya}$，同时包含两类偏置系数，分别是$b_a$、$b_y$</p><p>不同元素在<strong>同一位置共享权重</strong>系数和偏置系数，这样做的目的是让模型参数与序列信号长度无关。</p><p>如果是分类问题，则一般使用交叉熵损失；如果是回归问题，则一般使用均方误差。</p><h3 id="9-4-梯度消失"><a href="#9-4-梯度消失" class="headerlink" title="9.4 梯度消失"></a>9.4 梯度消失</h3><p>序列信号可能存在跨度很大的依赖关系，某个单词可能与它距离较远。由于跨度很大，普通的循环神经网络容易出现梯度消失，因此很难捕捉到它们之间的依赖，容易造成语法错误。</p><h3 id="9-5-GRU"><a href="#9-5-GRU" class="headerlink" title="9.5 GRU"></a>9.5 GRU</h3><p>GRU(Gated Recurrent Unit)，解决梯度消失问题。</p><p>$Г_u$和$Г_r$都是门控单元，取值范围为[0,1]。$Г_u$=0时，代表记忆值越小，代表“记住”得越明显。</p><p>•表示矩阵相乘，而*表示矩阵对应元素相乘。</p><h3 id="9-6-LSTM"><a href="#9-6-LSTM" class="headerlink" title="9.6 LSTM"></a>9.6 LSTM</h3><p>长短期记忆模型（Long Short-Term Memory）</p><img src="https://gitee.com/oeong/picgo/raw/master/images/20220117165846.png" alt="image-20220117165845085" style="zoom:50%;"><p>LSTM是循环神经网络模型的一个优秀的变种，继承了大部分循环神经网络模型的特性，同时解决了神经网络反向传播过程中容易发生的<strong>梯度消失</strong>问题。具体到语言处理任务中，LSTM非常适合处理与时间序列高度相关的问题，如机器翻译、对话生成、编解码等。</p><h3 id="9-7-多种循环神经网络模型"><a href="#9-7-多种循环神经网络模型" class="headerlink" title="9.7 多种循环神经网络模型"></a>9.7 多种循环神经网络模型</h3><ul><li><p>双向循环神经网络（Bidirectional RNN，BRNN）</p></li><li><p>深度循环神经网络（Deep RNN）</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Deep Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>conda</title>
    <link href="/2021/12/10/Python/conda/"/>
    <url>/2021/12/10/Python/conda/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer">conda是一个通用的包管理器，即任何语言的包都可以用其进行管理，同时也是环境管理器。    <a id="more"></a><p><strong>conda是一个通用的包管理器</strong>，即任何语言的包都可以用其进行管理，同时也是环境管理器。    </p><ul><li><a href="https://conda.io/projects/conda/en/latest/user-guide/getting-started.html">https://conda.io/projects/conda/en/latest/user-guide/getting-started.html</a></li><li><a href="https://blog.csdn.net/weixin_34381687/article/details/92060466">https://blog.csdn.net/weixin_34381687/article/details/92060466</a></li></ul><h2 id="管理conda"><a href="#管理conda" class="headerlink" title="管理conda"></a>管理conda</h2><p>更新conda<br><code>conda update conda</code></p><h2 id="管理环境"><a href="#管理环境" class="headerlink" title="管理环境"></a>管理环境</h2><p>列出环境<br><code>conda info -e</code></p><p>创建环境<br><code>conda create -n python27 python=2.7</code></p><p>删除环境<br><code>conda remove -n python27 --all</code></p><p>切换环境</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">conda <span class="hljs-built_in">activate</span> python27<br>conda <span class="hljs-built_in">deactivate</span><br></code></pre></td></tr></table></figure><h2 id="管理Python"><a href="#管理Python" class="headerlink" title="管理Python"></a>管理Python</h2><p>切换环境，检查版本</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">activate</span> python27<br>python <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><h2 id="管理包"><a href="#管理包" class="headerlink" title="管理包"></a>管理包</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 检查pip安装</span><br><span class="hljs-attribute">conda</span> list<br><span class="hljs-comment"># 安装</span><br><span class="hljs-attribute">conda</span> install numpy<br><span class="hljs-attribute">pip</span> install matplotlib==<span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">3</span> --trusted-host pypi.douban.com --user<br></code></pre></td></tr></table></figure><p>更换Jupyter Notebook内核Python版本</p><ul><li><a href="https://www.cnblogs.com/shanger/p/12006322.html">https://www.cnblogs.com/shanger/p/12006322.html</a></li><li><a href="https://blog.csdn.net/taijiedi13/article/details/59483763">https://blog.csdn.net/taijiedi13/article/details/59483763</a></li><li><a href="https://ipython.readthedocs.io/en/stable/install/kernel_install.html#kernel-install">https://ipython.readthedocs.io/en/stable/install/kernel_install.html#kernel-install</a></li></ul><p>当conda install找不到包时，可以使用该环境下的pip</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">(CertifiableBayesianInference) C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\T</span>470&gt;D:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\T</span>470<span class="hljs-symbol">\A</span>naconda3<span class="hljs-symbol">\e</span>nvs<span class="hljs-symbol">\C</span>ertifiableBayesianInference<span class="hljs-symbol">\S</span>cripts<span class="hljs-symbol">\p</span>ip install tensorflow-probability==0.15.0<br></code></pre></td></tr></table></figure><p>指定豆瓣源</p><p><code>-i https://pypi.douban.com/simple</code></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ul><li>pip与conda的区别？</li></ul><p>pip是Python官方认可的包管理器。</p><p><strong>conda是一个通用的包管理器</strong>，即任何语言的包都可以用其进行管理，同时也是环境管理器。    </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hutool</title>
    <link href="/2021/09/30/Java/hutool/"/>
    <url>/2021/09/30/Java/hutool/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer">Hutool是一个小而全的Java工具类库，通过静态方法封装，降低相关API的学习成本，提高工作效率，使Java拥有函数式语言般的优雅，让Java语言也可以“甜甜的”。<a id="more"></a><h1 id="Hutool"><a href="#Hutool" class="headerlink" title="Hutool"></a>Hutool</h1><blockquote><p>A set of tools that keep Java sweet.</p></blockquote><p>Hutool是一个Java工具包类库，对文件、流、加密解密、转码、正则、线程、XML等JDK方法进行封装，组成各种Util工具类。</p><ul><li><a href="https://www.hutool.cn/">官网</a></li><li><a href="https://apidoc.gitee.com/dromara/hutool/">API</a></li></ul><h2 id="Validator"><a href="#Validator" class="headerlink" title="Validator"></a>Validator</h2><p>字段验证器（验证器），分两种类型的验证：</p><ul><li>isXXX：通过返回boolean值判断是否满足给定格式。</li><li>validateXXX：通过抛出异常ValidateException检查是否满足给定格式。</li></ul><p>主要验证字段非空、是否为满足指定格式等（如是否为Email、电话等）</p><table><thead><tr><th>方法</th><th align="center">描述</th></tr></thead><tbody><tr><td>isCitizenId(CharSequence value)</td><td align="center">验证是否为身份证号码（支持18位、15位和港澳台的10位）</td></tr><tr><td>isEmail(CharSequence value)</td><td align="center">验证是否为可用邮箱地址</td></tr><tr><td>isEmpty(Object value)</td><td align="center">验证是否为空，对于String类型判定是否为empty(null 或 “”)</td></tr><tr><td>isMobile(CharSequence value)</td><td align="center">验证是否为手机号码（中国）</td></tr></tbody></table><h2 id="PhoneUtil"><a href="#PhoneUtil" class="headerlink" title="PhoneUtil"></a>PhoneUtil</h2><p>电话号码工具类，包括：</p><ul><li>手机号码</li><li>400、800号码</li><li>座机号码</li></ul><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>isMobile(CharSequence value)</td><td>验证是否为手机号码（中国）</td></tr><tr><td>isPhone(CharSequence value)</td><td>验证是否为座机号码+手机号码（CharUtil中国）+ 400 + 800电话 + 手机号号码（香港）</td></tr></tbody></table><h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><p>RSA公钥/私钥/签名加密解密</p><p>罗纳德·李维斯特（Ron [R]ivest）、阿迪·萨莫尔（Adi [S]hamir）和伦纳德·阿德曼（Leonard [A]dleman）</p><p>由于非对称加密速度极其缓慢，一般文件不使用它来加密而是使用对称加密，<br>非对称加密算法可以用来对对称加密的密钥加密，这样保证密钥的安全也就保证了数据的安全</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>decrypt(byte[] bytes, KeyType keyType)</td><td>解密</td></tr><tr><td>encrypt(byte[] data, KeyType keyType)</td><td>加密</td></tr></tbody></table><p>byte[]转String，通过构造方法String(byte bytes[])</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SVN</title>
    <link href="/2021/02/10/%E5%B7%A5%E5%85%B7/SVN/"/>
    <url>/2021/02/10/%E5%B7%A5%E5%85%B7/SVN/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer">Subversion(SVN) 是一个开源的版本控制系统, 也就是说 Subversion 管理着随时间改变的数据。<a id="more"></a><p>Subversion(SVN) 是一个开源的版本控制系统, 也就是说 Subversion 管理着随时间改变的数据。</p><ul><li><strong>repository（源代码库）:</strong>源代码统一存放的地方</li><li><strong>Checkout（提取）:</strong>当你手上没有源代码的时候，你需要从repository checkout一份</li><li><strong>Commit（提交）:</strong>当你已经修改了代码，你就需要Commit到repository。原子提交</li><li><strong>Update (更新):</strong>当你已经Checkout了一份源代码， Update一下你就可以和Repository上的源代码同步，你手上的代码就会有最新的变更</li></ul><p>服务端 <a href="https://www.visualsvn.com/downloads/">https://www.visualsvn.com/downloads/</a> </p><p>客户端 <a href="https://tortoisesvn.net/downloads.html">https://tortoisesvn.net/downloads.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript</title>
    <link href="/2021/02/09/JavaScript/"/>
    <url>/2021/02/09/JavaScript/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer">JavaScript 是互联网上最流行的脚本语言，这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。<a id="more"></a><p>为什么起名叫JavaScript？原因是当时Java语言非常红火，所以网景公司希望<strong>借Java的名气来推广</strong>，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。</p><p>JavaScript语言是在10天时间内设计出来的，虽然语言的设计者水平非常NB，但谁也架不住“时间紧，任务重”，所以，JavaScript有很多设计缺陷</p><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p>JavaScript<strong>严格区分大小写</strong>，如果弄错了大小写，程序将报错或者运行不正常。</p><h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><p>JavaScript不区分整数和浮点数，统一用<strong>Number</strong>表示。</p><p><strong>比较运算符</strong></p><p>第一种是<code>==</code>比较，它会<strong>自动转换数据类型</strong>再比较，很多时候，会得到非常诡异的结果；</p><p>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回<code>false</code>，如果一致，再比较。</p><p>由于JavaScript这个设计缺陷，不要使用<code>==</code>比较，始终坚持使用<code>===</code>比较。</p><p>这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言，Java是静态语言。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>; <span class="hljs-comment">// a的值是整数123</span><br>a = <span class="hljs-string">&#x27;ABC&#x27;</span>; <span class="hljs-comment">// a变为字符串</span><br></code></pre></td></tr></table></figure><p>alert()</p><p>console.log()</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>多行字符串：反引号``</p><p>模板字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;world&quot;</span>;<br><span class="hljs-keyword">var</span> message = <span class="hljs-string">`hello <span class="hljs-subst">$&#123;name&#125;</span>`</span>; <span class="hljs-comment">// 反引号</span><br></code></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>JavaScript的<code>Array</code>可以包含任意数据类型，并通过索引来访问每个元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>];<br>arr.length = <span class="hljs-number">2</span>; <span class="hljs-comment">// arr变为[1, 2]</span><br></code></pre></td></tr></table></figure><p>indexOf</p><p>slice: 对应String的<code>substring()</code></p><p>push和pop: <code>pop()</code>则把<code>Array</code>的最后一个元素删除掉</p><p>unshift和shift: 如果要往<code>Array</code>的头部添加若干元素，使用<code>unshift()</code>方法，<code>shift()</code>方法则把<code>Array</code>的第一个元素删掉</p><p>sort</p><p>reverse</p><p>splice</p><p><code>splice()</code>方法是修改<code>Array</code>的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;Microsoft&#x27;</span>, <span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;Yahoo&#x27;</span>, <span class="hljs-string">&#x27;AOL&#x27;</span>, <span class="hljs-string">&#x27;Excite&#x27;</span>, <span class="hljs-string">&#x27;Oracle&#x27;</span>];<br><span class="hljs-comment">// 从索引2开始删除3个元素,然后再添加两个元素:</span><br>arr.splice(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Facebook&#x27;</span>); <span class="hljs-comment">// 返回删除的元素 [&#x27;Yahoo&#x27;, &#x27;AOL&#x27;, &#x27;Excite&#x27;]</span><br></code></pre></td></tr></table></figure><p>concat: 拼接Array</p><p>join：把当前<code>Array</code>的每个元素都用指定的字符串连接起来，然后返回连接后的字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.join(<span class="hljs-string">&#x27;-&#x27;</span>); <span class="hljs-comment">// &#x27;A-B-C-1-2-3&#x27;</span><br><br>alert(<span class="hljs-string">`欢迎<span class="hljs-subst">$&#123;arr.slice(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)&#125;</span>和<span class="hljs-subst">$&#123;arr[<span class="hljs-number">3</span>]&#125;</span>同学！`</span>);<br></code></pre></td></tr></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>JavaScript的对象是动态类型，可以自由地给一个对象添加或删除属性</p><p>检测<code>xiaoming</code>是否拥有某一属性，可以用<code>in</code>操作符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xiaoming = &#123;<br>    name: <span class="hljs-string">&#x27;小明&#x27;</span><br>&#125;;<br><span class="hljs-keyword">delete</span> xiaoming.age;<br><span class="hljs-string">&#x27;toString&#x27;</span> <span class="hljs-keyword">in</span> xiaoming<br></code></pre></td></tr></table></figure><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p><code>for ... in</code>对<code>Array</code>的循环得到的是<code>String</code>而不是<code>Number</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> arr) &#123;<br>    <span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;</span><br>    <span class="hljs-built_in">console</span>.log(arr[i]); <span class="hljs-comment">// &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Map和Set"><a href="#Map和Set" class="headerlink" title="Map和Set"></a>Map和Set</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-number">95</span>], [<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">75</span>], [<span class="hljs-string">&#x27;Tracy&#x27;</span>, <span class="hljs-number">85</span>]]);<br><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;3&#x27;</span>]);<br></code></pre></td></tr></table></figure><h2 id="iterable"><a href="#iterable" class="headerlink" title="iterable"></a>iterable</h2><p>遍历<code>Array</code>可以采用下标循环，遍历<code>Map</code>和<code>Set</code>就无法使用下标。为了统一集合类型，ES6标准引入了新的<code>iterable</code>类型，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x <span class="hljs-keyword">of</span> arr)<br>    <br>arr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element, index, array</span>)</span><br></code></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。</p><h2 id="函数定义和调用"><a href="#函数定义和调用" class="headerlink" title="函数定义和调用"></a>函数定义和调用</h2><p><code>function abs(x)&#123;&#125;</code>等价于<code>var abs = function(x)&#123;&#125;;</code></p><p>arguments</p><p>它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。</p><p>JavaScript引擎有一个在行末自动添加分号;的机制</p><h2 id="变量作用域与解构赋值"><a href="#变量作用域与解构赋值" class="headerlink" title="变量作用域与解构赋值"></a>变量作用域与解构赋值</h2><p>全局作用域</p><p>不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象<code>window</code>，全局作用域的变量被绑定到<code>window</code>的一个属性。如<code>window.alert()</code></p><p>名字空间</p><p>全局变量会绑定到<code>window</code>上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。</p><p>减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 唯一的全局变量MYAPP:</span><br><span class="hljs-keyword">var</span> MYAPP = &#123;&#125;;<br><br><span class="hljs-comment">// 其他变量:</span><br>MYAPP.name = <span class="hljs-string">&#x27;myapp&#x27;</span>;<br>MYAPP.version = <span class="hljs-number">1.0</span>;<br><br><span class="hljs-comment">// 其他函数:</span><br>MYAPP.foo = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;foo&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>解构赋值：直接对多个变量同时赋值</p><p><code>let [x, [y, z]] = [&#39;hello&#39;, [&#39;JavaScript&#39;, &#39;ES6&#39;]];</code></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>在一个对象中绑定函数，称为这个对象的方法。</p><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么<strong>一个函数就可以接收另一个函数作为参数</strong>，这种函数就称之为高阶函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y, f</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> f(x) + f(y);<br>&#125;<br><span class="hljs-keyword">var</span> x = add(-<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-built_in">Math</span>.abs); <span class="hljs-comment">// 11</span><br></code></pre></td></tr></table></figure><p>map/reduce</p><p>map是对数组的每个元素分别计算。</p><p>Array的<code>reduce()</code>把一个函数作用在这个<code>Array</code>的<code>[x1, x2, x3...]</code>上，这个函数必须接收两个参数，<code>reduce()</code>把结果继续和<strong>序列的下一个元素</strong>做<strong>累积</strong>计算。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)<br></code></pre></td></tr></table></figure><p>filter</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>];<br><span class="hljs-keyword">var</span> r = arr.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>;  <span class="hljs-comment">// 保留奇数</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>sort</p><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p><code>every()</code>方法可以判断数组的所有元素是否满足测试条件。</p><p><code>find()</code>方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回undefined</p><p><code>findIndex()</code>返回符合条件的第一个元素的索引</p><p><code>forEach()</code>和<code>map()</code>类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。<code>forEach()</code>常用于遍历数组，因此，传入的函数不需要返回值。<code>arr.forEach(console.log);</code></p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java面经</title>
    <link href="/2021/02/09/Java/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
    <url>/2021/02/09/Java/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><a id="more"></a><h1 id="Java-SE"><a href="#Java-SE" class="headerlink" title="Java SE"></a>Java SE</h1><h2 id="Java基础（一）"><a href="#Java基础（一）" class="headerlink" title="Java基础（一）"></a>Java基础（一）</h2><h3 id="Java和PHP的区别？"><a href="#Java和PHP的区别？" class="headerlink" title="Java和PHP的区别？"></a>Java和PHP的区别？</h3><p>PHP专注于Web开发，在Web后台开发PHP优于Java；Java比较全面，在数据库访问方面强于PHP。</p><p>Java适合于开发大型的应用系统，应用的前景比较广阔，系统易维护、可复用性较好。</p><h3 id="简单描述一下正则表达式及其用途。"><a href="#简单描述一下正则表达式及其用途。" class="headerlink" title="简单描述一下正则表达式及其用途。"></a>简单描述一下正则表达式及其用途。</h3><p>在编写处理字符串的程序时，经常需要<strong>查找符合某些复杂规则的字符串</strong>。正则表达式就是用于描述这些规则的工具。</p><h3 id="Java中是如何支持正则表达式操作的？"><a href="#Java中是如何支持正则表达式操作的？" class="headerlink" title="Java中是如何支持正则表达式操作的？"></a>Java中是如何支持正则表达式操作的？</h3><p>Java中的<code>String</code>类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java中可以用<code>Pattern</code>类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作，如compile。</p><h3 id="比较一下Java和JavaSciprt？"><a href="#比较一下Java和JavaSciprt？" class="headerlink" title="比较一下Java和JavaSciprt？"></a>比较一下Java和JavaSciprt？</h3><p>Java与JavaScript是两个公司开发的不同的两个产品。</p><ul><li>面向对象和基于对象</li></ul><p>Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；</p><p>JavaScript是基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，用来制作与网络无关的，与用户交互作用的复杂软件。</p><ul><li>编译和解释</li></ul><p>Java的源代码在执行之前，必须经过编译；</p><p>JavaScript无需编译，由浏览器解释执行。</p><ul><li>强类型和弱类型变量</li></ul><p>Java采用强类型变量检查，即所有变量在编译之前必须作声明；</p><p>JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，在运行时检查推断其数据类型。</p><h3 id="Java中如何跳出当前的多重嵌套循环？"><a href="#Java中如何跳出当前的多重嵌套循环？" class="headerlink" title="Java中如何跳出当前的多重嵌套循环？"></a>Java中如何跳出当前的多重嵌套循环？</h3><p>在最外层循环前加一个标记如A，然后用<code>break A</code>，可以跳出多重循环，类似goto。</p><h3 id="amp-和-amp-amp-的区别？"><a href="#amp-和-amp-amp-的区别？" class="headerlink" title="&amp;和&amp;&amp;的区别？"></a>&amp;和&amp;&amp;的区别？</h3><p>&amp;运算符有两种用法：(1)按位与&amp;；(2)逻辑与&amp;&amp;。</p><p>&amp;&amp;运算符是<strong>短路与</strong>运算。如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。</p><h3 id="int和Integer有什么区别？"><a href="#int和Integer有什么区别？" class="headerlink" title="int和Integer有什么区别？"></a>int和Integer有什么区别？</h3><p>Java是一个近乎纯洁的面向对象编程语言，==为了编程的方便引入了基本数据类型==，但是为了能够将这些基本数据类型当成==对象==操作，Java为每一个基本数据类型都引入了对应的==包装类型==（wrapper class），<strong>int的包装类就是Integer</strong>，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以<strong>相互转换</strong>。</p><h3 id="在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，请你讲讲如何输出一个某种编码的字符串？"><a href="#在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，请你讲讲如何输出一个某种编码的字符串？" class="headerlink" title="在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，请你讲讲如何输出一个某种编码的字符串？"></a>在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，请你讲讲如何输出一个某种编码的字符串？</h3><p><code>String str = new String(&quot;字符串&quot;.getBytes(&quot;ISO-8859-1&quot;), &quot;GBK&quot;);</code></p><h3 id="String和StringBuffer的区别"><a href="#String和StringBuffer的区别" class="headerlink" title="String和StringBuffer的区别"></a>String和StringBuffer的区别</h3><p>String类为不可变对象，每次操作String都会建立新的对象来保存新的值。</p><p>StringBuffer是可变对象，实例化后，只对这一个对象操作。</p><h3 id="String是最基本的数据类型吗"><a href="#String是最基本的数据类型吗" class="headerlink" title="String是最基本的数据类型吗?"></a>String是最基本的数据类型吗?</h3><p>基本数据类型包括byte、short、int、long、float、double、char、boolean。</p><p>java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类。</p><h2 id="Java基础（二）"><a href="#Java基础（二）" class="headerlink" title="Java基础（二）"></a>Java基础（二）</h2><h3 id="请你谈谈大O符号-big-O-notation-并给出不同数据结构的例子"><a href="#请你谈谈大O符号-big-O-notation-并给出不同数据结构的例子" class="headerlink" title="请你谈谈大O符号(big-O notation)并给出不同数据结构的例子"></a>请你谈谈大O符号(big-O notation)并给出不同数据结构的例子</h3><p>大O符号表示一个程序运行时所需要的渐进时间复杂度上界。</p><h3 id="请你讲讲数组-Array-和列表-ArrayList-的区别？什么时候应该使用Array而不是ArrayList？"><a href="#请你讲讲数组-Array-和列表-ArrayList-的区别？什么时候应该使用Array而不是ArrayList？" class="headerlink" title="请你讲讲数组(Array)和列表(ArrayList)的区别？什么时候应该使用Array而不是ArrayList？"></a>请你讲讲数组(Array)和列表(ArrayList)的区别？什么时候应该使用Array而不是ArrayList？</h3><p>Array和ArrayList的不同点：<br>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。<br>Array大小是固定的，ArrayList的大小是动态变化的。<br>ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。</p><p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p><h3 id="请你解释什么是值传递和引用传递？"><a href="#请你解释什么是值传递和引用传递？" class="headerlink" title="请你解释什么是值传递和引用传递？"></a>请你解释什么是值传递和引用传递？</h3><p>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.<br>引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身。所以对引用对象进行操作会同时改变原对象。</p><h3 id="请你讲讲Java支持的数据类型有哪些？什么是自动拆装箱？"><a href="#请你讲讲Java支持的数据类型有哪些？什么是自动拆装箱？" class="headerlink" title="请你讲讲Java支持的数据类型有哪些？什么是自动拆装箱？"></a>请你讲讲Java支持的数据类型有哪些？什么是自动拆装箱？</h3><p>基本数据类型包括byte、short、int、long、float、double、boolean、char。</p><p>自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。</p><h3 id="请你解释为什么会出现4-0-3-6-0-40000001这种现象？"><a href="#请你解释为什么会出现4-0-3-6-0-40000001这种现象？" class="headerlink" title="请你解释为什么会出现4.0-3.6=0.40000001这种现象？"></a>请你解释为什么会出现4.0-3.6=0.40000001这种现象？</h3><p>2进制的小数无法精确的表达10进制小数，计算机在计算10进制小数的过程中要先转换为2进制进行计算，这个过程中出现了误差。</p><h3 id="请你讲讲一个十进制的数在内存中是怎么存的？"><a href="#请你讲讲一个十进制的数在内存中是怎么存的？" class="headerlink" title="请你讲讲一个十进制的数在内存中是怎么存的？"></a>请你讲讲一个十进制的数在内存中是怎么存的？</h3><p>补码的形式。</p><h3 id="Lamda表达式的优缺点。"><a href="#Lamda表达式的优缺点。" class="headerlink" title="Lamda表达式的优缺点。"></a>Lamda表达式的优缺点。</h3><p>优点：1. 简洁。2. 非常容易并行计算。3. 可能代表未来的编程趋势。</p><p>缺点：1. 若不用并行计算，很多时候计算速度没有比传统的 for 循环快。（并行计算有时需要预热才显示出效率优势）2. 不容易调试。3. 若其他程序员没有学过 lambda 表达式，代码不容易让其他语言的程序员看懂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br>(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y) -&gt; x + y <br></code></pre></td></tr></table></figure><h3 id="java8的新特性，请简单介绍一下"><a href="#java8的新特性，请简单介绍一下" class="headerlink" title="java8的新特性，请简单介绍一下"></a>java8的新特性，请简单介绍一下</h3><p>Lambda 表达式：Lambda允许把函数作为一个方法的参数</p><p>方法引用：可以直接引用已有Java类或对象（实例）的方法或构造器。</p><p>默认方法：一个在接口里面有了一个实现的方法。</p><h3 id="说明符号“-”比较的是什么？"><a href="#说明符号“-”比较的是什么？" class="headerlink" title="说明符号“==”比较的是什么？"></a>说明符号“==”比较的是什么？</h3><p><code>==</code>对比两个对象基于内存引用，如果两个对象的引用完全相同（指向同一个对象）时，<code>==</code>操作将返回true，否则返回false。</p><p><code>==</code>如果两边是基本类型，就是比较数值是否相等。</p><h3 id="解释Object若不重写hashCode-的话，hashCode-如何计算出来的？"><a href="#解释Object若不重写hashCode-的话，hashCode-如何计算出来的？" class="headerlink" title="解释Object若不重写hashCode()的话，hashCode()如何计算出来的？"></a>解释Object若不重写hashCode()的话，hashCode()如何计算出来的？</h3><p>Object 的 hashcode 方法是本地方法，用C\C++实现的，该方法直接返回对象的 内存地址。</p><h3 id="介绍一下map的分类和常见的情况"><a href="#介绍一下map的分类和常见的情况" class="headerlink" title="介绍一下map的分类和常见的情况"></a>介绍一下map的分类和常见的情况</h3><p>java为数据结构中的映射定义了一个接口java.util.Map;它有四个实现类,分别是HashMap、Hashtable、 LinkedHashMap和TreeMap.</p><p><code>Map</code>主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重复。</p><p><code>Hashmap</code>是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。</p><p><code>Hashtable</code>与 HashMap类似,它继承自Dictionary类，不同的是:它不允许记录的键或者值为空;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢。</p><p><code>LinkedHashMap</code>是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。</p><p><code>TreeMap</code>实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。</p><h3 id="自增变量"><a href="#自增变量" class="headerlink" title="自增变量"></a>自增变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>        i = i++;<br>        <span class="hljs-keyword">int</span> j = i++;<br>        <span class="hljs-keyword">int</span> k = i + ++i * i++;<br>        System.out.println(<span class="hljs-string">&quot;i=&quot;</span> + i); <span class="hljs-comment">// 4</span><br>        System.out.println(<span class="hljs-string">&quot;j=&quot;</span> + j); <span class="hljs-comment">// 1</span><br>        System.out.println(<span class="hljs-string">&quot;k=&quot;</span> + k); <span class="hljs-comment">// 11 2+3*3</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>Singleton：单例设计模式，即某个类在整个系统中只能有一个实例对象可被获取和使用的代码模式</p><ol><li>某个类只能有一个实例<br>构造器私有化</li><li>他必须自行创建实例<br>自行创建，并且用静态变量保存</li><li>必须自行向整个系统提供这个实例<ul><li>直接暴露(public)</li><li>用静态变量的get方法</li></ul></li></ol><p>饿汉式 直接实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton1</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1、构造器私有化</span><br><span class="hljs-comment">     * 2、自行创建，并且用静态变量保存</span><br><span class="hljs-comment">     * 3、向外提供实例</span><br><span class="hljs-comment">     * 4、强调这是一个单例，我们可以用final修改</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton1</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton1 INSTANCE = <span class="hljs-keyword">new</span> Singleton1();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>懒汉式 单线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton4</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1、构造器私有化</span><br><span class="hljs-comment">     * 2、用一个静态变量保存这个唯一的实例</span><br><span class="hljs-comment">     * 3、提供一个静态方法，获取这个实例对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> Singleton4 instance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton4</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton4 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>                instance = <span class="hljs-keyword">new</span> Singleton4();<br>            &#125;<br>            <span class="hljs-keyword">return</span> instance;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法参数传递机制"><a href="#方法参数传递机制" class="headerlink" title="方法参数传递机制"></a>方法参数传递机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>        String str = <span class="hljs-string">&quot;hello&quot;</span>;<br>        Integer num = <span class="hljs-number">200</span>;<br>        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>        MyData my = <span class="hljs-keyword">new</span> MyData(); <span class="hljs-comment">// 10</span><br><br>        change(i,str,num,arr,my);<br><br>        System.out.println(<span class="hljs-string">&quot;i= &quot;</span> + i); <span class="hljs-comment">// 1</span><br>        System.out.println(<span class="hljs-string">&quot;str= &quot;</span> + str); <span class="hljs-comment">// hello</span><br>        System.out.println(<span class="hljs-string">&quot;num= &quot;</span> + num); <span class="hljs-comment">// 200</span><br>        System.out.println(<span class="hljs-string">&quot;arr= &quot;</span> + Arrays.toString(arr)); <span class="hljs-comment">// 2,2,3,4,5</span><br>        System.out.println(<span class="hljs-string">&quot;my.a= &quot;</span> + my.a); <span class="hljs-comment">// 11</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> j, String s, Integer n, <span class="hljs-keyword">int</span>[] a, MyData m)</span> </span>&#123;<br>        j += <span class="hljs-number">1</span>;<br>        s += <span class="hljs-string">&quot;world&quot;</span>;<br>        n += <span class="hljs-number">1</span>;<br>        a[<span class="hljs-number">0</span>] += <span class="hljs-number">1</span>;<br>        m.a += <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyData</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实参给形参赋值：</p><p>基本数据类型：数据值</p><p>引用数据类型：地址值 特殊类型：String、包装类对象具有不变性</p><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">byte</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">float</span> <span class="hljs-keyword">double</span> <span class="hljs-keyword">char</span> <span class="hljs-keyword">boolean</span><br><span class="hljs-number">8</span> <span class="hljs-number">16</span>    <span class="hljs-number">32</span>   <span class="hljs-number">64</span>  <span class="hljs-number">32</span>  <span class="hljs-number">64</span>  <span class="hljs-number">16</span>   <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="递归与迭代"><a href="#递归与迭代" class="headerlink" title="递归与迭代"></a>递归与迭代</h3><blockquote><p>有 n 步台阶，一次只能上 1 步或者 2 步，共有多少种走法？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Step</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>        System.out.println(iteration(<span class="hljs-number">40</span>)); <br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis(); <br>        System.out.println(end - start);<br>    &#125;<br><br>    <span class="hljs-comment">// 递归实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">recursion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123;<br>          <span class="hljs-keyword">return</span> n;<br>      &#125;<br>      <span class="hljs-keyword">return</span> recursion(n - <span class="hljs-number">2</span>) + recursion( n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 迭代实现</span><br>    <span class="hljs-comment">// one 最后走一步 的走法 有：1 1 1, 2 1</span><br>    <span class="hljs-comment">// two 最后走两步 的走法 有：1 2</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">iteration</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-keyword">int</span> two = <span class="hljs-number">1</span>; <span class="hljs-comment">// 一层台阶，有 1 走法, n 的前两层台阶的走法</span><br>        <span class="hljs-keyword">int</span> one = <span class="hljs-number">2</span>; <span class="hljs-comment">// 二层台阶，有 2 走法, n 的前一层台阶的走法</span><br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录一共有多少中走法</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>                sum = two + one;<br>                two = one;<br>                one = sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>递归</strong> 当 n 等于 1 或者 2 时，走法就等于 n，从第三层台阶开始，每一层台阶为前两层台阶走法之和。</li><li><strong>迭代</strong> 用 one、two 这两个变量来存储 n 的最后走一步和最后走两步，从第三层开始走，用 sum 来保存前两次的走法的次数，sum = two + one; 然后 two 移到 one，one 移到 sum 循环迭代。</li></ol><p>总结：<br>1）方法调用自身称为递归，利用变量的原值推出新值称为迭代。<br>2）递归<br>优点：大问题转化为小问题，可以减少代码量，同时代码精简，可读性好；<br>缺点：递归调用浪费了空间，而且递归太深容易造成堆栈的溢出。<br>3）迭代<br>优点：代码运行效率好，因为时间复杂度为 O(n)，而且没有额为空间的开销；<br>缺点：代码不如递归简洁。</p><h3 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 成员变量和局部变量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Exam6</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s; <span class="hljs-comment">// 成员变量，类变量</span><br>    <span class="hljs-keyword">int</span> i; <span class="hljs-comment">// 成员变量，实例变量</span><br>    <span class="hljs-keyword">int</span> j; <span class="hljs-comment">// 成员变量，实例变量</span><br><br>    &#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 非静态代码块中的局部变量</span><br>        i++;<br>        j++;<br>        s++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> j)</span> </span>&#123; <span class="hljs-comment">// 局部变量</span><br>        j++;<br>        i++;<br>        s++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; <span class="hljs-comment">// 局部变量</span><br>        Exam6 obj1 = <span class="hljs-keyword">new</span> Exam6(); <span class="hljs-comment">// 局部变量</span><br>        Exam6 obj2 = <span class="hljs-keyword">new</span> Exam6(); <span class="hljs-comment">// 局部变量</span><br><br>        obj1.test(<span class="hljs-number">10</span>);<br>        obj1.test(<span class="hljs-number">20</span>);<br>        obj2.test(<span class="hljs-number">30</span>);<br><br>        System.out.println(obj1.i + <span class="hljs-string">&quot;,&quot;</span> + obj1.j + <span class="hljs-string">&quot;,&quot;</span> + obj1.s); <span class="hljs-comment">// 2 1 5</span><br>        System.out.println(obj2.i + <span class="hljs-string">&quot;,&quot;</span> + obj2.j + <span class="hljs-string">&quot;,&quot;</span> + obj2.s); <span class="hljs-comment">// 1 1 5</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h4><p>1）就近原则<br>2）变量的分类</p><ul><li>成员变量：类变量、实例变量</li><li>局部变量</li></ul><p>3）非静态代码块的执行：每次创建实例对象都会执行<br>4）方法的调用规则：调用一次执行一次</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>1）声明的位置<br>局部变量：方法体 { } 中、代码块 { } 中、形参<br>成员变量：类中的<strong>方法外</strong></p><ul><li><strong>类变量 ：有 static 修饰</strong></li><li>实例变量：没有 static 修饰</li></ul><p>2）修饰符<br>局部变量：final<br>成员变量：public、protected、private、final、static、volatile、transient</p><p>3）值存储的位置<br>局部变量：栈<br>实例变量：堆<br>类变量：方法区</p><p>4）作用域<br>局部变量：声明处开始，到所属的 } 结束<br>实例变量：在当前类中 <code>this.</code>（有时this. 可以省略），在其他类中 “对象名. ” 访问<br>类变量：在当前类中 <code>类名.</code>（有时类名. 可以省略），在其它类中 “类名.” 或 “对象名.” 访问</p><p>5）生命周期<br>局部变量：每一个线程，每一次调用执行都是新的生命周期<br>实例变量：随着对象的创建而初始化，随着对象的被回收而消亡，每一个对象的实例变量都是独立的<br>类变量：随着类的初始化而初始化，随着类的卸载而消亡，该类的所有对象的类变量是共享的</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="Java里面的final关键字是怎么用的？"><a href="#Java里面的final关键字是怎么用的？" class="headerlink" title="Java里面的final关键字是怎么用的？"></a>Java里面的final关键字是怎么用的？</h3><p>当用final修饰一个类时，表明这个类不能被继承；如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</p><h3 id="关于Synchronized和lock"><a href="#关于Synchronized和lock" class="headerlink" title="关于Synchronized和lock"></a>关于Synchronized和lock</h3><p>synchronized(同步)是Java的关键字，当它用来修饰一个方法或代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。</p><p>Lock是一个接口。</p><h3 id="介绍一下volatile？"><a href="#介绍一下volatile？" class="headerlink" title="介绍一下volatile？"></a>介绍一下volatile？</h3><p>volatile关键字是用来保证有序性和可见性的。</p><h3 id="请你介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？"><a href="#请你介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？" class="headerlink" title="请你介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？"></a>请你介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？</h3><p>…</p><h2 id="面向对象（一）"><a href="#面向对象（一）" class="headerlink" title="面向对象（一）"></a>面向对象（一）</h2><h3 id="若对一个类不重写，它的equals-方法是如何比较的？"><a href="#若对一个类不重写，它的equals-方法是如何比较的？" class="headerlink" title="若对一个类不重写，它的equals()方法是如何比较的？"></a>若对一个类不重写，它的equals()方法是如何比较的？</h3><p>比较对象的地址。</p><h3 id="解释hashCode-和equals-方法有什么联系？"><a href="#解释hashCode-和equals-方法有什么联系？" class="headerlink" title="解释hashCode()和equals()方法有什么联系？"></a>解释hashCode()和equals()方法有什么联系？</h3><p>➀相等的对象必须具有相等的哈希码（散列码）。</p><p>➁如果两个对象的hashCode相同，它们并不一定相同。</p><h3 id="什么是构造函数？什么是构造函数重载？什么是复制构造函数？"><a href="#什么是构造函数？什么是构造函数重载？什么是复制构造函数？" class="headerlink" title="什么是构造函数？什么是构造函数重载？什么是复制构造函数？"></a>什么是构造函数？什么是构造函数重载？什么是复制构造函数？</h3><p>构造函数，即构造方法，用于创建对象时初始化对象。与类同名，无返回值。</p><p>构造函数重载：可以为一个类创建多个构造函数，每个构造函数必须有它自己唯一的参数列表。</p><p>…</p><h3 id="方法重载-Overloading-和方法覆盖-Overriding-是什么意思？"><a href="#方法重载-Overloading-和方法覆盖-Overriding-是什么意思？" class="headerlink" title="方法重载(Overloading)和方法覆盖(Overriding)是什么意思？"></a>方法重载(Overloading)和方法覆盖(Overriding)是什么意思？</h3><p>方法重载：同一个类里面两个或者是多个方法的<strong>方法名相同但是参数不同</strong>的情况。</p><p>方法覆盖（重写）是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，返回类型和参数列表。覆盖者可能不会限制它所覆盖的方法的访问。</p><h3 id="请说明Query接口的list方法和iterate方法有什么区别？"><a href="#请说明Query接口的list方法和iterate方法有什么区别？" class="headerlink" title="请说明Query接口的list方法和iterate方法有什么区别？"></a>请说明Query接口的list方法和iterate方法有什么区别？</h3><p>…</p><h3 id="面向对象的”六原则一法则”"><a href="#面向对象的”六原则一法则”" class="headerlink" title="面向对象的”六原则一法则”"></a>面向对象的”六原则一法则”</h3><ol><li>单一职责原则：一个类只做它该做的事情。</li><li>开闭原则：软件实体应当对扩展开放，对修改关闭。</li><li>依赖倒转原则：面向接口编程。</li><li>里氏替换原则：任何时候都可以用子类型替换掉父类型。</li><li>接口隔离原则：接口要小而专，绝不能大而全。</li><li>合成聚合复用原则：优先使用聚合或合成关系复用代码。</li><li>迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。</li></ol><h3 id="如何通过反射获取和设置对象私有字段的值？"><a href="#如何通过反射获取和设置对象私有字段的值？" class="headerlink" title="如何通过反射获取和设置对象私有字段的值？"></a>如何通过反射获取和设置对象私有字段的值？</h3><p>…</p><h3 id="说明重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#说明重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="说明重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>说明重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h3><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p><p>重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写（覆盖）发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。</p><p>重载对返回类型没有特殊的要求。</p><h3 id="两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，该说法是否正确，为什么？"><a href="#两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，该说法是否正确，为什么？" class="headerlink" title="两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，该说法是否正确，为什么？"></a>两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，该说法是否正确，为什么？</h3><p>不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。</p><p>当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。</p><h3 id="内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？"><a href="#内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？" class="headerlink" title="内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？"></a>内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？</h3><p>一个内部类对象可以访问创建它的外部类对象的内容。</p><p>类如果不是static的，那么它可以访问创建它的外部类对象的所有属性内部类；如果是static的，即为nested class，那么它只可以访问创建它的外部类对象的所有static属性一般普通类。</p><h3 id="Java语言如何进行异常处理，关键字：throws-throw-try-catch-finally分别代表什么意义？在try块中可以抛出异常吗？"><a href="#Java语言如何进行异常处理，关键字：throws-throw-try-catch-finally分别代表什么意义？在try块中可以抛出异常吗？" class="headerlink" title="Java语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？"></a>Java语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？</h3><p>一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。</p><p>用try来指定一块预防所有”异常”的程序。紧跟在try程序后面，应包含一个catch子句来指定你想要捕捉的”异常”的类型。throw语句用来明确地抛出一个”异常”。throws用来标明一个成员函数可能抛出的各种”异常”。finally为确保一段代码不管发生什么”异常”都被执行一段代码。</p><h3 id="说明Java的接口和C-的虚类的相同和不同处。"><a href="#说明Java的接口和C-的虚类的相同和不同处。" class="headerlink" title="说明Java的接口和C++的虚类的相同和不同处。"></a>说明Java的接口和C++的虚类的相同和不同处。</h3><p>…</p><h3 id="判断当一个对象被当作参数传递给一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#判断当一个对象被当作参数传递给一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="判断当一个对象被当作参数传递给一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?"></a>判断当一个对象被当作参数传递给一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</h3><p>???</p><p>值传递。Java只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。</p><p>Java永远只有值传递，引用传递其实也是一个值传递，传递是一个地址的副本，</p><h2 id="面向对象（二）"><a href="#面向对象（二）" class="headerlink" title="面向对象（二）"></a>面向对象（二）</h2><h3 id="interface和abstract-class有什么区别"><a href="#interface和abstract-class有什么区别" class="headerlink" title="interface和abstract class有什么区别?"></a>interface和abstract class有什么区别?</h3><ol><li><p>相同点<br>两者都是抽象类，都不能实例化。</p><p>interface实现类及abstrct class的子类都必须要实现已经声明的抽象方法。</p></li><li><p>不同点</p><p>interface需要实现，要用implements，而abstract class需要继承，要用extends。</p><p>一个类可以实现多个interface，但一个类只能继承一个abstract class。</p><p>interface强调特定功能的实现，而abstract class强调所属关系。</p><p>尽管interface实现类及abstrct class的子类都必须要实现相应的抽象方法，但实现的形式不同。interface中的每一个方法都是抽象方法，都只是声明的 (declaration, 没有方法体)，实现类必须要实现。而abstract class的子类可以有选择地实现。</p></li></ol><h3 id="Override和Overload的区别，Overloaded的方法是否可以改变返回值的类型"><a href="#Override和Overload的区别，Overloaded的方法是否可以改变返回值的类型" class="headerlink" title="Override和Overload的区别，Overloaded的方法是否可以改变返回值的类型?"></a>Override和Overload的区别，Overloaded的方法是否可以改变返回值的类型?</h3><p>方法的重写Override和重载Overload是Java多态性的不同表现。重写Override是父类与子类之间多态性的一种表现，重载Overload是一个类中多态性的一种表现。</p><p>重写是子类对父类方法的重新实现, 返回类型和参数列表都不能改变。<br>重载(overloading) 是在一个类里面，方法名相同，而参数不同。返回类型可以相同也可以不同。</p><h3 id="final-finally-finalize的区别"><a href="#final-finally-finalize的区别" class="headerlink" title="final, finally, finalize的区别"></a>final, finally, finalize的区别</h3><p>final 用于声明属性，方法和类，分别表示属性不可变，方法不可重写，类不可继承。<br>finally 是异常处理语句结构的一部分，表示总是执行。<br>finalize 是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。</p><h3 id="面向对象的特征有哪些方面"><a href="#面向对象的特征有哪些方面" class="headerlink" title="面向对象的特征有哪些方面"></a>面向对象的特征有哪些方面</h3><ol><li>封装<br> 封装，即把过程和数据包围起来，对数据的访问只能通过已定义的界面。如私有变量，用set，get方法获取。封装保证了模块具有较好的独立性，使得程序维护修改较为容易。</li><li>继承<br> 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。</li><li>多态<br> 多态性是指允许不同类的对象对同一消息作出响应。</li><li>抽象<br> 抽象，即忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。</li></ol><h3 id="Comparable和Comparator2个接口的作用和区别"><a href="#Comparable和Comparator2个接口的作用和区别" class="headerlink" title="Comparable和Comparator2个接口的作用和区别"></a>Comparable和Comparator2个接口的作用和区别</h3><p>作用：都是用来实现集合中元素的比较和排序</p><p>…</p><h2 id="面向对象（三）"><a href="#面向对象（三）" class="headerlink" title="面向对象（三）"></a>面向对象（三）</h2><p>…</p><h2 id="集合（一）"><a href="#集合（一）" class="headerlink" title="集合（一）"></a>集合（一）</h2><h3 id="请说明List、Map、Set三个接口存取元素时，各有什么特点"><a href="#请说明List、Map、Set三个接口存取元素时，各有什么特点" class="headerlink" title="请说明List、Map、Set三个接口存取元素时，各有什么特点"></a>请说明List、Map、Set三个接口存取元素时，各有什么特点</h3><p>List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。</p><h3 id="阐述ArrayList、Vector、LinkedList的存储性能和特性"><a href="#阐述ArrayList、Vector、LinkedList的存储性能和特性" class="headerlink" title="阐述ArrayList、Vector、LinkedList的存储性能和特性"></a>阐述ArrayList、Vector、LinkedList的存储性能和特性</h3><p>…</p><h3 id="请判断List、Set、Map是否继承自Collection接口？"><a href="#请判断List、Set、Map是否继承自Collection接口？" class="headerlink" title="请判断List、Set、Map是否继承自Collection接口？"></a>请判断List、Set、Map是否继承自Collection接口？</h3><p>List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素，List是线性结构的容器，适用于按数值索引访问元素的情形。</p><h3 id="常用集合类以及主要方法？"><a href="#常用集合类以及主要方法？" class="headerlink" title="常用集合类以及主要方法？"></a>常用集合类以及主要方法？</h3><p>List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。List 适用于按数值索引访问元素的情形。</p><p>Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作”键”和”值”），其中每个键映射到一个值。</p><h3 id="Collection-和-Collections的区别"><a href="#Collection-和-Collections的区别" class="headerlink" title="Collection 和 Collections的区别"></a>Collection 和 Collections的区别</h3><p>Collection是集合类的上级接口，继承与他的接口主要有Set 和List.<br>Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</p><h3 id="HashMap和Hashtable的区别？"><a href="#HashMap和Hashtable的区别？" class="headerlink" title="HashMap和Hashtable的区别？"></a>HashMap和Hashtable的区别？</h3><p>HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：<br>HashMap允许键和值是null，而Hashtable不允许键或者值是null。<br>HashMap不是同步的，Hashtable是同步的。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。<br>HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。</p><h1 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h1><h2 id="Web编程基础"><a href="#Web编程基础" class="headerlink" title="Web编程基础"></a>Web编程基础</h2><h3 id="JAVA应用服务器都有哪些？"><a href="#JAVA应用服务器都有哪些？" class="headerlink" title="JAVA应用服务器都有哪些？"></a>JAVA应用服务器都有哪些？</h3><p>Web服务器：Tomcat、Jetty</p><p>Java EE服务器：Bea Weblogic、JBoss</p><h3 id="在什么情况下会使用assert？"><a href="#在什么情况下会使用assert？" class="headerlink" title="在什么情况下会使用assert？"></a>在什么情况下会使用assert？</h3><p>assertion (断言)在软件开发中是一种常用的调试方式。</p><p>assertion检查通常在开发和测试时开启。在实现中，assertion就是在程序中的一条语句，它对一个 boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true。</p><h3 id="1分钟之内只能处理1000个请求，你怎么实现，手撕代码"><a href="#1分钟之内只能处理1000个请求，你怎么实现，手撕代码" class="headerlink" title="1分钟之内只能处理1000个请求，你怎么实现，手撕代码?"></a>1分钟之内只能处理1000个请求，你怎么实现，手撕代码?</h3><p>限流的几种方法：计数器，滑动窗口、漏桶法、令牌桶</p><h3 id="如何在链接里不输入项目名称的情况下启动项目？"><a href="#如何在链接里不输入项目名称的情况下启动项目？" class="headerlink" title="如何在链接里不输入项目名称的情况下启动项目？"></a>如何在链接里不输入项目名称的情况下启动项目？</h3><p>在taomcat配置虚拟目录。</p><h3 id="JSP中的静态包含和动态包含的有哪些区别？"><a href="#JSP中的静态包含和动态包含的有哪些区别？" class="headerlink" title="JSP中的静态包含和动态包含的有哪些区别？"></a>JSP中的静态包含和动态包含的有哪些区别？</h3><p>静态包含是通过JSP的include指令包含页面，动态包含是通过JSP标准动作<a href="jsp:forward">jsp:forward</a>包含页面。</p><p>静态包含是编译时包含，动态包含是运行时包含。</p><h3 id="表达式语言（EL）的隐式对象以及该对象的作用"><a href="#表达式语言（EL）的隐式对象以及该对象的作用" class="headerlink" title="表达式语言（EL）的隐式对象以及该对象的作用"></a>表达式语言（EL）的隐式对象以及该对象的作用</h3><p>EL的隐式对象包括：pageContext、initParam（访问上下文参数）、param（访问请求参数）</p><h3 id="JSP有哪些内置对象？以及这些对象的作用分别是什么？"><a href="#JSP有哪些内置对象？以及这些对象的作用分别是什么？" class="headerlink" title="JSP有哪些内置对象？以及这些对象的作用分别是什么？"></a>JSP有哪些内置对象？以及这些对象的作用分别是什么？</h3><p>JSP有9个内置对象：</p><ul><li>request：封装客户端的请求，其中包含来自GET或POST请求的参数；</li><li>response：封装服务器对客户端的响应；</li><li>pageContext：通过该对象可以获取其他对象；</li><li>session：封装用户会话的对象；</li><li>application：封装服务器运行环境的对象；</li><li>application：封装服务器运行环境的对象；</li><li>out：输出服务器响应的输出流对象；</li><li>config：Web应用的配置对象；</li><li>page：JSP页面本身（相当于Java程序中的this）；</li><li>exception：封装页面抛出异常的对象。</li></ul><h3 id="说说weblogic中一个Domain的缺省目录结构-比如要将一个简单的helloWorld-jsp放入何目录下-然后在浏览器上就可打入主机？"><a href="#说说weblogic中一个Domain的缺省目录结构-比如要将一个简单的helloWorld-jsp放入何目录下-然后在浏览器上就可打入主机？" class="headerlink" title="说说weblogic中一个Domain的缺省目录结构?比如要将一个简单的helloWorld.jsp放入何目录下,然后在浏览器上就可打入主机？"></a>说说weblogic中一个Domain的缺省目录结构?比如要将一个简单的helloWorld.jsp放入何目录下,然后在浏览器上就可打入主机？</h3><p>…</p><h3 id="JSP有哪些动作-这些动作的作用又分别是什么"><a href="#JSP有哪些动作-这些动作的作用又分别是什么" class="headerlink" title="JSP有哪些动作? 这些动作的作用又分别是什么?"></a>JSP有哪些动作? 这些动作的作用又分别是什么?</h3><p>JSP 共有以下6种基本动作<br>jsp:include：在页面被请求的时候引入一个文件。<br>jsp:forward：把请求转到一个新的页面。<br>jsp:useBean：寻找或者实例化一个JavaBean。<br>jsp:setProperty：设置JavaBean的属性。<br>jsp:getProperty：输出某个JavaBean的属性。<br>jsp:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记。</p><h3 id="详细说明一下Request对象的主要方法是什么？"><a href="#详细说明一下Request对象的主要方法是什么？" class="headerlink" title="详细说明一下Request对象的主要方法是什么？"></a>详细说明一下Request对象的主要方法是什么？</h3><p>setAttribute(String name,Object)：设置名字为name的request的参数值<br>getAttribute(String name)：返回由name指定的属性值<br>getAttributeNames()：返回request对象所有属性的名字集合，结果是一个枚举的实例<br>removeAttribute(String name)：删除请求中的一个属性</p><h3 id="JSP四种会话跟踪技术分别是什么？"><a href="#JSP四种会话跟踪技术分别是什么？" class="headerlink" title="JSP四种会话跟踪技术分别是什么？"></a>JSP四种会话跟踪技术分别是什么？</h3><p>page域 数据在一个<strong>页面</strong>范围内有效，通过pageContext对象访问<br>request域 数据在一个<strong>服务器</strong>请求范围内有效，通过request对象访问<br>session域 数据在一次<strong>会话</strong>范围内容有效，通过session对象访问<br>application域 数据在一个<strong>应用服务器</strong>范围内有效，通过application对象访问</p><h3 id="JSP和Servlet有哪些相同点和不同点？另外他们之间的联系又是什么呢？"><a href="#JSP和Servlet有哪些相同点和不同点？另外他们之间的联系又是什么呢？" class="headerlink" title="JSP和Servlet有哪些相同点和不同点？另外他们之间的联系又是什么呢？"></a>JSP和Servlet有哪些相同点和不同点？另外他们之间的联系又是什么呢？</h3><p>JSP全称Java Server Pages，是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码。标签通常以&lt;%开头以%&gt;结束。</p><p>Servlet(Servlet Applet):  是用JAVA编写的服务器端程序。主要用于交互式地浏览和修改数据，生成Web内容。</p><p>Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。<strong>JSP侧重于视图，Servlet主要用于控制逻辑。</strong></p><h3 id="JSP的内置对象以及该对象的使用方法。"><a href="#JSP的内置对象以及该对象的使用方法。" class="headerlink" title="JSP的内置对象以及该对象的使用方法。"></a>JSP的内置对象以及该对象的使用方法。</h3><p>request表示HttpServletRequest对象。它包含了有关浏览器请求的信息，并且提供了几个用于获取cookie, header, 和session数据的有用的方法。<br>response表示HttpServletResponse对象，并提供了几个用于设置送回浏览器的响应的方法（如cookies,头信息等）</p><h3 id="web-xml文件中可以配置哪些内容？"><a href="#web-xml文件中可以配置哪些内容？" class="headerlink" title="web.xml文件中可以配置哪些内容？"></a>web.xml文件中可以配置哪些内容？</h3><p>web.xml用于配置Web应用的相关信息，如：监听器（listener）、过滤器（filter）、Servlet、相关参数、会话超时时间、安全验证方式、错误页面等。</p><h3 id="对Javaweb开发中的监听器的理解？"><a href="#对Javaweb开发中的监听器的理解？" class="headerlink" title="对Javaweb开发中的监听器的理解？"></a>对Javaweb开发中的监听器的理解？</h3><p>Java Web开发中的监听器（listener）就是application、session、request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件。</p><h3 id="过滤器有哪些作用？以及过滤器的用法又是什么呢"><a href="#过滤器有哪些作用？以及过滤器的用法又是什么呢" class="headerlink" title="过滤器有哪些作用？以及过滤器的用法又是什么呢?"></a>过滤器有哪些作用？以及过滤器的用法又是什么呢?</h3><p>过滤器是一个驻留在服务器端的Web组件，它可以截取客户端和服务器之间的请求与响应信息，并对这些信息进行过滤。</p><p>常见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式。</p><h2 id="Web编程原理"><a href="#Web编程原理" class="headerlink" title="Web编程原理"></a>Web编程原理</h2><h3 id="get和post请求，并且说说它们之间的区别？"><a href="#get和post请求，并且说说它们之间的区别？" class="headerlink" title="get和post请求，并且说说它们之间的区别？"></a>get和post请求，并且说说它们之间的区别？</h3><p>①get请求用来从服务器上获得资源，而post是用来向服务器提交数据；<br>②get将表单中数据按照name=value的形式，添加到action所指向的URL 后面，并且两者使用”?”连接，而各个变量之间使用”&amp;”连接；post是将表单中的数据放在<strong>HTTP协议的请求头或消息体</strong>中，传递到action所指向URL；<br>③get传输的数据要受到URL长度限制（1024字节）；而post可以传输大量的数据，上传文件通常要使用post方式；<br>④使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post；</p><h3 id="转发和重定向之间的区别？"><a href="#转发和重定向之间的区别？" class="headerlink" title="转发和重定向之间的区别？"></a>转发和重定向之间的区别？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// servlet</span><br>request.getRequestDispatcher(<span class="hljs-string">&quot;new.jsp&quot;</span>).forward(request, response); <span class="hljs-comment">//转发到new.jsp</span><br>response.sendRedirect(<span class="hljs-string">&quot;new.jsp&quot;</span>); <span class="hljs-comment">//重定向到new.jsp</span><br><br><span class="hljs-comment">// jsp</span><br>&lt;jsp:forward page=<span class="hljs-string">&quot;apage.jsp&quot;</span> /&gt;<br>&lt;%response.sendRedirect(<span class="hljs-string">&quot;new.jsp&quot;</span>);<br></code></pre></td></tr></table></figure><p>转发是服务器行为，重定向是客户端行为。</p><p>重定向，其实是两次request。</p><p>转发：以前的request中存放的变量不会失效，就像把两个页面拼到了一起。</p><p>重定向：以前的request中存放的变量全部失效，并进入一个新的request作用域。</p><h3 id="forward-和redirect的区别？"><a href="#forward-和redirect的区别？" class="headerlink" title="forward 和redirect的区别？"></a>forward 和redirect的区别？</h3><p><a href="https://blog.csdn.net/weixin_37766296/article/details/80375106">https://blog.csdn.net/weixin_37766296/article/details/80375106</a></p><ol><li><p>本质</p><p> <strong>forword转发是服务器上的行为，而redirect重定向是客户端的行为</strong></p></li><li><p>地址栏</p><p> forward：转发，从服务器转发。因此在客户端的浏览器地址里看不出url的变化<br> redirect：重定向，在客户端重新定向了一次，因此在客户端能看出url的变化。</p></li><li><p>数据共享<br>由于在整个定向的过程中用的是同一个request，因此forward会将request的信息带到被重定向的jsp或者servlet中使用，即可以共享数据；redirect不能共享  </p></li><li><p>运用</p><p> forword：登录</p><p> redirect：注销或跳转其他网站</p></li></ol><h3 id="cookie-和-session-的区别？"><a href="#cookie-和-session-的区别？" class="headerlink" title="cookie 和 session 的区别？"></a>cookie 和 session 的区别？</h3><p>Cookie 用于存储 Web 页面的用户信息，如账号、密码。</p><p>Session 用于存储关于用户会话（session）的信息。</p><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p><p>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</p><p>考虑到安全应当使用session。</p><p>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。</p><p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p><h1 id="Java-EE"><a href="#Java-EE" class="headerlink" title="Java EE"></a>Java EE</h1><h2 id="Spring-一"><a href="#Spring-一" class="headerlink" title="Spring(一)"></a>Spring(一)</h2><h3 id="简单介绍一下spring？"><a href="#简单介绍一下spring？" class="headerlink" title="简单介绍一下spring？"></a>简单介绍一下spring？</h3><p>Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。</p><p>Spring的模块大概分为6个。分别是：</p><p>1、Core Container（Spring的核心）【重要】</p><p>2、AOP（面向切面编程）【重要】</p><p>3、Messaging（消息发送的支持）</p><p>4、Data Access/Integration（数据访问和集成）</p><p>5、Web（主要是SpringWeb内容，包括MVC）【重要】</p><p>6、Test（Spring测试支持，包含JUint等测试单元的支持）</p><p>Java Bean是可复用的实体类。</p><h3 id="Spring中自动装配的方式有哪些？"><a href="#Spring中自动装配的方式有哪些？" class="headerlink" title="Spring中自动装配的方式有哪些？"></a>Spring中自动装配的方式有哪些？</h3><p>…</p><h3 id="Spring中Bean的作用域有哪些？"><a href="#Spring中Bean的作用域有哪些？" class="headerlink" title="Spring中Bean的作用域有哪些？"></a>Spring中Bean的作用域有哪些？</h3><p>singleton和prototype</p><h3 id="什么是IoC和DI？并且简要说明一下DI是如何实现的？"><a href="#什么是IoC和DI？并且简要说明一下DI是如何实现的？" class="headerlink" title="什么是IoC和DI？并且简要说明一下DI是如何实现的？"></a>什么是IoC和DI？并且简要说明一下DI是如何实现的？</h3><p>IoC(Inversion of Control) 控制反转，DI(Dependency Injection)依赖注入</p><h3 id="Spring中BeanFactory和ApplicationContext的区别是什么？"><a href="#Spring中BeanFactory和ApplicationContext的区别是什么？" class="headerlink" title="Spring中BeanFactory和ApplicationContext的区别是什么？"></a>Spring中BeanFactory和ApplicationContext的区别是什么？</h3><p>BeanFactory是spring中比较原始，比较古老的Factory，所以BeanFactory无法支持spring插件，例如：AOP、Web应用等功能。</p><p>ApplicationContext是BeanFactory的子类，以一种更面向框架的工作方式以及对上下文进行分层和实现继承，并在这个基础上对功能进行扩展。</p><h3 id="springIOC原理是什么？如果你要实现IOC需要怎么做？请简单描述一下实现步骤？"><a href="#springIOC原理是什么？如果你要实现IOC需要怎么做？请简单描述一下实现步骤？" class="headerlink" title="springIOC原理是什么？如果你要实现IOC需要怎么做？请简单描述一下实现步骤？"></a>springIOC原理是什么？如果你要实现IOC需要怎么做？请简单描述一下实现步骤？</h3><p>…</p><h3 id="依赖注入的方式有哪几种？以及这些方法如何使用？"><a href="#依赖注入的方式有哪几种？以及这些方法如何使用？" class="headerlink" title="依赖注入的方式有哪几种？以及这些方法如何使用？"></a>依赖注入的方式有哪几种？以及这些方法如何使用？</h3><p>1、Set注入 2、构造器注入 3、接口注入</p><h3 id="Controller和-RestController的区别是什么？"><a href="#Controller和-RestController的区别是什么？" class="headerlink" title="@Controller和@RestController的区别是什么？"></a>@Controller和@RestController的区别是什么？</h3><p>@RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用</p><h3 id="autowired-和resource区别是什么？"><a href="#autowired-和resource区别是什么？" class="headerlink" title="autowired 和resource区别是什么？"></a>autowired 和resource区别是什么？</h3><p>1、共同点</p><p>两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p><p>2、不同点</p><p>（1）@Autowired</p><p>@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p><p>@Autowired注解是按照类型（byType）装配依赖对象</p><p>（2）@Resource</p><p>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。</p><h2 id="Spring-二"><a href="#Spring-二" class="headerlink" title="Spring(二)"></a>Spring(二)</h2><h3 id="IOC和AOP是什么？"><a href="#IOC和AOP是什么？" class="headerlink" title="IOC和AOP是什么？"></a>IOC和AOP是什么？</h3><p>依赖注入的三种方式：（1）接口注入（2）Construct注入（3）Setter注入</p><p>控制反转（IoC）与依赖注入（DI）是同一个概念，引入IOC的目的：（1）脱开、降低类之间的耦合；（2）倡导面向接口编程、实施依赖倒换原则； （3）提高系统可插入、可测试、可修改等特性。</p><p>AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。</p><h3 id="如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？"><a href="#如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？" class="headerlink" title="如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？"></a>如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？</h3><p>…</p><h3 id="AOP的原理是什么？"><a href="#AOP的原理是什么？" class="headerlink" title="AOP的原理是什么？"></a>AOP的原理是什么？</h3><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。</p><h3 id="Spring框架为企业级开发带来的好处有哪些？"><a href="#Spring框架为企业级开发带来的好处有哪些？" class="headerlink" title="Spring框架为企业级开发带来的好处有哪些？"></a>Spring框架为企业级开发带来的好处有哪些？</h3><p>…</p><h3 id="Spring框架的优点都有哪些？"><a href="#Spring框架的优点都有哪些？" class="headerlink" title="Spring框架的优点都有哪些？"></a>Spring框架的优点都有哪些？</h3><p>Spring是一个轻量级的DI和AOP容器框架，它的优点主要有以下几点：</p><p>Spring是一个非侵入式框架，其目标是使应用程序代码对框架的依赖最小化，应用代码可以在没有Spring或者其他容器的情况运行。</p><p>Spring提供了一个一致的编程模型，使应用直接使用POJO开发，从而可以使运行环境隔离开来。</p><p>Spring推动应用的设计风格向面向对象及面向接口编程转变，提高了代码的重用性和可测试性。</p><h3 id="Struts拦截器和Spring-AOP有什么区别？"><a href="#Struts拦截器和Spring-AOP有什么区别？" class="headerlink" title="Struts拦截器和Spring AOP有什么区别？"></a>Struts拦截器和Spring AOP有什么区别？</h3><p>…</p><h3 id="持久层设计要考虑的问题有哪些？请谈一下你用过的持久层框架都有哪些？"><a href="#持久层设计要考虑的问题有哪些？请谈一下你用过的持久层框架都有哪些？" class="headerlink" title="持久层设计要考虑的问题有哪些？请谈一下你用过的持久层框架都有哪些？"></a>持久层设计要考虑的问题有哪些？请谈一下你用过的持久层框架都有哪些？</h3><p>所谓”持久”就是将数据保存到可掉电式存储设备中以便今后使用，简单的说，就是将内存中的数据保存到关系型数据库、文件系统、消息队列等提供持久化支持的设备中。持久层就是系统中专注于实现数据持久化的相对独立的层面。</p><p>持久层框架有：<br>- Hibernate<br>- MyBatis</p><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="网络概述"><a href="#网络概述" class="headerlink" title="网络概述"></a>网络概述</h2><h3 id="TCP协议、IP协议、HTTP协议分别在哪一层？"><a href="#TCP协议、IP协议、HTTP协议分别在哪一层？" class="headerlink" title="TCP协议、IP协议、HTTP协议分别在哪一层？"></a>TCP协议、IP协议、HTTP协议分别在哪一层？</h3><p>运输层，网络层，应用层。</p><hr><p>网络七层模型：</p><p>  物理层，数据链路层，网络层，运输层，会话层，表示层，应用层</p><p>网络五层模型：</p><p>  物理层，数据链路层，网络层，运输层，应用层</p><p><img src="https://gitee.com/oeong/picgo/raw/master/images/20210316164355.jpeg" alt="img"></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="ARP协议和ARP攻击"><a href="#ARP协议和ARP攻击" class="headerlink" title="ARP协议和ARP攻击"></a>ARP协议和ARP攻击</h3><p>ARP协议(地址解析协议): 将IP地址转换为MAC地址</p><p>ARP应答中的IP地址和MAC地址中的信息是可以伪造的，并不一定是自己的真实IP地址和MAC地址，由此，ARP欺骗就产生了。</p><h3 id="什么是ICMP协议，它的作用是什么？"><a href="#什么是ICMP协议，它的作用是什么？" class="headerlink" title="什么是ICMP协议，它的作用是什么？"></a>什么是ICMP协议，它的作用是什么？</h3><p>ICMP(Internet控制报文)协议。用于在IP主机、路由器之间传递控制消息。</p><h3 id="交换机和的区别？"><a href="#交换机和的区别？" class="headerlink" title="交换机和的区别？"></a>交换机和的区别？</h3><p>1、工作层次不同，一个是数据链路层，一个是网络层</p><p>2、寻址依据不同，一个基于MAC寻址，一个是基于IP寻址</p><p>3、交换机分割冲突域，不划分广播域。路由器既可分割冲突域也可分割广播域</p><p>4、转发的数据对象不同，交换机转发的是数据帧，路由器转发的是分组报文</p><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><h3 id="3次握手"><a href="#3次握手" class="headerlink" title="3次握手"></a>3次握手</h3><p><img src="https://gitee.com/oeong/picgo/raw/master/images/20210422223429.png" alt="image-20210422223427394"></p><p>A发送SYN数据包请求连接；<br>B收到后回复ACK；<br>A收到后回复ACK</p><h3 id="4次挥手"><a href="#4次挥手" class="headerlink" title="4次挥手"></a>4次挥手</h3><p><img src="https://gitee.com/oeong/picgo/raw/master/images/20210422223348.png" alt="image-20210422223346629"></p><p>A发送FIN数据包请求断开连接；<br>B收到后回复ACK；<br>B发送FIN数据包要求反向断开连接；<br>A收到后回复ACK</p><p>【三次握手】<br>男：我们在一起吧<br>女：好的啊<br>男：好的，从现在开始吧<br>【四次挥手】<br>男：我们分手吧<br>女：我想一下<br>女：我们分手吧<br>男：好的，现在就结束吧</p><h3 id="TCP为什么要建立连接？"><a href="#TCP为什么要建立连接？" class="headerlink" title="TCP为什么要建立连接？"></a>TCP为什么要建立连接？</h3><p>保证可靠传输。</p><h3 id="TCP为什么可靠一些"><a href="#TCP为什么可靠一些" class="headerlink" title="TCP为什么可靠一些"></a>TCP为什么可靠一些</h3><p>三次握手，超时重传，滑动窗口，拥塞控制。</p><h3 id="哪种应用场景会使用TCP协议，使用它的意义"><a href="#哪种应用场景会使用TCP协议，使用它的意义" class="headerlink" title="哪种应用场景会使用TCP协议，使用它的意义"></a>哪种应用场景会使用TCP协议，使用它的意义</h3><p>当对网络通讯质量有要求的时候，需要整个数据要准确无误的传递给对方。如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="HTTP请求中的304状态码的含义"><a href="#HTTP请求中的304状态码的含义" class="headerlink" title="HTTP请求中的304状态码的含义"></a>HTTP请求中的304状态码的含义</h3><p>304(未修改)自从上次请求后，请求的网页未修改过。</p><h3 id="SSL四次握手的过程"><a href="#SSL四次握手的过程" class="headerlink" title="SSL四次握手的过程"></a>SSL四次握手的过程</h3><p>…</p><h3 id="HTTP1-1和1-0的区别"><a href="#HTTP1-1和1-0的区别" class="headerlink" title="HTTP1.1和1.0的区别"></a>HTTP1.1和1.0的区别</h3><p>…</p><h3 id="HTTP请求，并说明应答码502和504的区别"><a href="#HTTP请求，并说明应答码502和504的区别" class="headerlink" title="HTTP请求，并说明应答码502和504的区别"></a>HTTP请求，并说明应答码502和504的区别</h3><p>OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。</p><p>HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。</p><p>GET：向特定的资源发出请求。</p><p>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。</p><p>PUT：向指定资源位置上传其最新内容。</p><p>DELETE：请求服务器删除Request-URI所标识的资源。</p><p>TRACE：回显服务器收到的请求，主要用于测试或诊断。</p><p>CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p><p>虽然HTTP的请求方式有8种，但是我们在实际应用中常用的也就是get和post，其他请求方式也都可以通过这两种方式间接的来实现。</p><p>502：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到<strong>无效的响应</strong>。</p><p>504：作为网关或者代理工作的服务器尝试执行请求时，<strong>未能及时</strong>从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。</p><h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><ol><li>HTTPS需要申请CA证书</li><li>HTTP是明文传输，HTTPS是加密的安全传输</li><li>端口不同，HTTP是80，HTTPS是443</li></ol><h3 id="浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程。"><a href="#浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程。" class="headerlink" title="浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程。"></a>浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程。</h3><p>1.DNS解析 2.TCP连接 3.发送HTTP请求 4.服务器处理请求并返回HTTP报文 5.浏览器解析渲染页面</p><h3 id="DNS的寻址过程"><a href="#DNS的寻址过程" class="headerlink" title="DNS的寻址过程"></a>DNS的寻址过程</h3><p>1、在浏览器中输入<code>www.oeong.com</code>域名，操作系统会先检查自己<strong>本地的hosts文件</strong>是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</p><p>2、如果hosts里没有这个域名的映射，则查找<strong>本地DNS解析器</strong>缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</p><p>3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它<strong>本地DNS服务器</strong>，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</p><p>4、如果本地DNS服务器也失效：</p><p>如果未采用转发模式（<strong>迭代</strong>），本地DNS就把请求发至<strong>13台根DNS</strong>，根DNS服务器收到请求后，会判断这个域名（如.com）是谁来授权管理，并返回一个负责该顶级域名服务器的IP，本地DNS服务器收到顶级域名服务器IP信息后，继续向该顶级域名服务器IP发送请求，该服务器如果无法解析，则会找到负责这个域名的下一级DNS服务器（如<code>www.oeong.com</code>)的IP给本地DNS服务器，循环往复直至查询到映射，将解析结果返回本地DNS服务器，再由本地DNS服务器返回解析结果，查询完成。</p><p>如果采用转发模式（<strong>递归</strong>），则此DNS服务器就会把请求转发至<strong>上一级DNS服务器</strong>，如果上一级DNS服务器不能解析，则继续向上请求。最终将解析结果依次返回本地DNS服务器，本地DNS服务器再返回给客户机，查询完成。</p><p>从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。</p><h3 id="负载均衡-反向代理模式的优点、缺点"><a href="#负载均衡-反向代理模式的优点、缺点" class="headerlink" title="负载均衡 反向代理模式的优点、缺点"></a>负载均衡 反向代理模式的优点、缺点</h3><p>…</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><h3 id="64位和32位的区别？"><a href="#64位和32位的区别？" class="headerlink" title="64位和32位的区别？"></a>64位和32位的区别？</h3><p>32位操作系统针对32位的CPU设计，64位操作系统针对64位的CPU设计。</p><p>1、运行能力不同。64位可以一次性可以处理8个字节的数据量，而32位一次性只可以处理4个字节的数据量，因此64位比32位的运行能力提高了一倍。<br>2、内存寻址不同。<strong>64位最大寻址空间为2的64次方</strong>，理论值直接达到了16TB，而32位的最大寻址空间为2的32次方，为4GB，换而言之，就是说32位系统的处理器最大只支持到4G内存，而64位系统最大支持的内存高达亿位数。<br>3、运行软件不同。由于32位和64位CPU的指令集是不同的。所以需要区分32位和64位版本的软件。<br>为了保证兼容性，64位CPU上也能运行老的32位指令。于是实际上我们可以在64位CPU上运行32位程序，但是反过来不行。简而言之就是64位的操作系统可以兼容运行32位的软件，反过来32位系统不可以运行64位的软件。</p><h3 id="CentOS-和-Linux的关系？"><a href="#CentOS-和-Linux的关系？" class="headerlink" title="CentOS 和 Linux的关系？"></a>CentOS 和 Linux的关系？</h3><p>CentOS是Linux众多得发行版本之一</p><h2 id="进程的描述与控制"><a href="#进程的描述与控制" class="headerlink" title="进程的描述与控制"></a>进程的描述与控制</h2><h3 id="解释LINUX下的线程，GDI类"><a href="#解释LINUX下的线程，GDI类" class="headerlink" title="解释LINUX下的线程，GDI类"></a>解释LINUX下的线程，GDI类</h3><p>LINUX实现的就是基于核心轻量级进程的”一对一”线程模型，一个线程实体对应一个核心轻量级进程，而线程之间的管理在核外函数库中实现。</p><p>GDI类为图像设备编程接口类库。</p><h3 id="进程和线程的区别是什么？"><a href="#进程和线程的区别是什么？" class="headerlink" title="进程和线程的区别是什么？"></a>进程和线程的区别是什么？</h3><p>进程是运行中的程序，线程是进程内部的一个执行序列<br>进程是<strong>资源</strong>分配的基本单元，线程是<strong>独立调度</strong>的基本单位<br>进程间切换代价大，线程间切换代价小<br>进程拥有资源多，线程拥有资源少<br>多个线程共享进程的资源</p><p>开个QQ，开了一个进程。在QQ的这个进程里，传输文字开一个线程、传输语音开了一个线程、弹出对话框又开了一个线程。</p><h3 id="系统线程数量上限是多少？"><a href="#系统线程数量上限是多少？" class="headerlink" title="系统线程数量上限是多少？"></a>系统线程数量上限是多少？</h3><p>Linux 系统中单个进程的最大线程数有其最大的限制 PTHREAD_THREADS_MAX。</p><h3 id="如何杀死一个进程？"><a href="#如何杀死一个进程？" class="headerlink" title="如何杀死一个进程？"></a>如何杀死一个进程？</h3><ul><li><p>kill pid；系统发送一个signal,程序收到信号后，会先释放资源，再关闭程序。</p></li><li><p>kill -9 pid；-9表示强制执行。</p></li></ul><h2 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h2><h3 id="介绍socket编程的三种通信模型，BIO，NIO，AIO"><a href="#介绍socket编程的三种通信模型，BIO，NIO，AIO" class="headerlink" title="介绍socket编程的三种通信模型，BIO，NIO，AIO"></a>介绍socket编程的三种通信模型，BIO，NIO，AIO</h3><ul><li><p>BIO：block IO同步阻塞式IO，就是我们平时使用的传统IO，特点是模式简单使用方便，并发处理能力低。</p></li><li><p>NIO：new IO 同步非阻塞IO，是传统IO的升级，客户端和服务器通过channel（通道）通信，实现多路复用。</p></li><li><p>AIO，异步非阻塞IO，异步IO的操作是基于事件和回调机制的。</p></li></ul><h1 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h1><p><strong>统一建模语言</strong>(Unified Modeling Language，UML)是一种为面向对象系统的产品进行说明、可视化和编制文档的一种标准语言。</p><h3 id="UML中有哪些常用的图？"><a href="#UML中有哪些常用的图？" class="headerlink" title="UML中有哪些常用的图？"></a>UML中有哪些常用的图？</h3><p>用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）</p><p>类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）</p><p>时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Maven配置</title>
    <link href="/2021/02/04/Java/maven%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/02/04/Java/maven%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer">Maven 翻译为"专家"、"内行"，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。<a id="more"></a><h2 id="Maven是什么"><a href="#Maven是什么" class="headerlink" title="Maven是什么"></a>Maven是什么</h2><ul><li>Maven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。</li><li>Maven 是一个<strong>项目管理工具</strong>，可以对 Java 项目进行构建、依赖管理。</li></ul><p><a href="https://www.runoob.com/maven/maven-setup.html">Maven 环境配置</a></p><h2 id="配置MAVEN-HOME报错"><a href="#配置MAVEN-HOME报错" class="headerlink" title="配置MAVEN_HOME报错"></a>配置MAVEN_HOME报错</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xquery">The JAVA_HOME environment <span class="hljs-keyword">variable</span> <span class="hljs-literal">is</span><span class="hljs-built_in"> not</span> defined correctly<br>This environment <span class="hljs-keyword">variable</span> <span class="hljs-literal">is</span> needed <span class="hljs-keyword">to</span> run this program<br>NB: JAVA_HOME should point <span class="hljs-keyword">to</span> a JDK<span class="hljs-built_in"> not</span> a JRE<br></code></pre></td></tr></table></figure><p>原因是我安装了两个jdk版本，并同时将路径写在JAVA_HOME中。于是分别为两个jdk设置JAVA_HOME。设置<code>JAVA_HOME = %JAVA_HOME8%</code>，当需要另一版本则切换为<code>JAVA_HOME = %JAVA_HOME15%</code>。</p><p><img src="http://cdn.oeong.com/niu20210204235021.png" alt="image-20210204235019615"></p><p>学习博客：<a href="https://blog.csdn.net/yuruixin_china/article/details/53607248?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs">同一个电脑安装两个jdk版本</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记</title>
    <link href="/2021/01/23/Java/Java/"/>
    <url>/2021/01/23/Java/Java/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。</p><a id="more"></a><h1 id="Java快速入门"><a href="#Java快速入门" class="headerlink" title="Java快速入门"></a>Java快速入门</h1><h2 id="Java简介"><a href="#Java简介" class="headerlink" title="Java简介"></a>Java简介</h2><ul><li>JDK：Java Development Kit</li><li>JRE：Java Runtime Environment</li></ul><p>简单地说，JRE就是运行Java字节码的<strong>虚拟机</strong>。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了<strong>包含</strong>JRE，还提供了编译器、调试器等开发工具。</p><p>  二者关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ascii"> ┌─    ┌──────────────────────────────────┐<br> │     │     Compiler, debugger, etc.     │<br> │     └──────────────────────────────────┘<br>JDK ┌─ ┌──────────────────────────────────┐<br> │  │  │                                  │<br> │ JRE │      JVM + Runtime Library       │<br> │  │  │                                  │<br> └─ └─ └──────────────────────────────────┘<br>       ┌───────┐┌───────┐┌───────┐┌───────┐<br>       │Windows││ Linux ││ macOS ││others │<br>       └───────┘└───────┘└───────┘└───────┘<br></code></pre></td></tr></table></figure><h2 id="Java程序基础"><a href="#Java程序基础" class="headerlink" title="Java程序基础"></a>Java程序基础</h2><p><code>int[] ns = new int[5];</code></p><p>对象、数组都是引用数据类型。</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h4 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h4><p><code>==</code>表示“引用的<strong>对象</strong>是否相等”，浮点数判断相等不能直接用</p><p>使用<code>equals()</code>判断引用类型<strong>内容</strong>相等，注意避免<code>NullPointerException</code>。</p><h4 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for each循环"></a>for each循环</h4><p><code>for each</code>循环可以直接遍历数组的每个元素；</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span>[] ns = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span> &#125;;<br>for (<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> <span class="hljs-symbol">:</span> ns) &#123;<br>System.out.println(<span class="hljs-built_in">n</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><p>遍历数组可以使用<code>for</code>循环，<code>for</code>循环可以访问数组索引，<code>for each</code>循环直接迭代每个数组元素，但无法获取索引；</p><p>使用<code>Arrays.toString()</code>可以快速获取数组内容。</p><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>排序前</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                   ┌──────────────────────────────────┐<br>               ┌───┼──────────────────────┐           │<br>               │   │                      ▼           ▼<br>         ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐<br>ns ─────&gt;│░░░│░░░│░░░│   │&quot;banana&quot;│   │&quot;apple&quot;│   │&quot;pear&quot;│   │<br>         └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘<br>           │                 ▲<br>           └─────────────────┘<br></code></pre></td></tr></table></figure><p>排序后，原来的3个字符串在<strong>内存</strong>中均没有任何变化，但是<code>ns</code>数组的每个元素<strong>指向</strong>变化了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                   ┌──────────────────────────────────┐<br>               ┌───┼──────────┐                       │<br>               │   │          ▼                       ▼<br>         ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐<br>ns ─────&gt;│░░░│░░░│░░░│   │&quot;banana&quot;│   │&quot;apple&quot;│   │&quot;pear&quot;│   │<br>         └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘<br>           │                              ▲<br>           └──────────────────────────────┘<br></code></pre></td></tr></table></figure><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>Java是一种面向对象的编程语言。面向对象编程，英文是Object-Oriented Programming，简称OOP。</p><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><p>在OOP中，<code>class</code>和<code>instance</code>是“模版”和“实例”的关系；</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>在方法内部，可以使用一个隐含的变量<code>this</code>，它始终指向当前实例。因此，通过<code>this.field</code>就可以访问当前实例的字段。</p><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>方法重载是指多个方法的方法名相同，但各自的参数不同；</p><p>重载方法返回值类型应该相同。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="区分继承和组合"><a href="#区分继承和组合" class="headerlink" title="区分继承和组合"></a>区分继承和组合</h4><p><code>Student</code>和<code>Book</code>的关系是has关系。</p><ul><li>继承是面向对象编程的一种强大的代码复用方式；</li><li>Java只允许单继承，所有类最终的根类是<code>Object</code>；</li><li><code>protected</code>允许子类访问父类的字段和方法；</li><li>子类的构造方法可以通过<code>super()</code>调用父类的构造方法；</li><li>可以<strong>安全地向上转型</strong>为更抽象的类型；</li><li>可以强制向下转型，最好借助<code>instanceof</code>判断；</li><li>子类和父类的关系是is，has关系不能用继承。</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。</p><ul><li>子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为；</li><li>Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；</li><li><code>final</code>修饰符有多种作用：<ul><li><code>final</code>修饰的方法可以阻止被覆写；</li><li><code>final</code>修饰的class可以阻止被继承；</li><li><code>final</code>修饰的field必须在创建对象时初始化，随后不可修改。</li></ul></li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>通过<code>abstract</code>定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范；</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>所谓<code>interface</code>，就是比抽象类还要抽象的纯抽象接口，因为<strong>不能定义实例字段</strong>。</p><p><code>interface</code>的字段只能是<code>public static final</code>类型</p><h3 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h3><p>所有实例共享一个静态字段。</p><p>不推荐用<code>实例变量.静态字段</code>去访问静态字段，推荐<strong>用类名来访问静态字段</strong>。</p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>Java内建的<code>package</code>机制是为了避免<code>class</code>命名冲突；</p><p>JDK的核心类使用<code>java.lang</code>包，编译器会自动导入；</p><p>JDK的其它常用类定义在<code>java.util.*</code>，<code>java.math.*</code>，<code>java.text.*</code>，……；</p><p>包名推荐使用<strong>倒置的域名</strong>，避免冲突，例如<code>org.apache</code>。</p><p>包没有父子关系，<code>com.apache</code>和<code>com.apache.abc</code>是不同的包。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>定义在一个<code>class</code>内部的<code>class</code>称为嵌套类（<code>nested class</code>）</p><p>如果不确定是否需要<code>public</code>，就不声明为<code>public</code>，即尽可能少地暴露对外的字段和方法。</p><p>把方法定义为<code>package</code>权限有助于测试，因为测试类和被测试类只要位于同一个<code>package</code>，测试代码就可以访问被测试类的<code>package</code>权限方法。</p><p>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。如果有<code>public</code>类，文件名必须和<code>public</code>类的名字相同。</p><p><code>protected</code>作用于继承关系。定义为<code>protected</code>的字段和方法可以被子类访问，以及子类的子类</p><h3 id="classpath和jar"><a href="#classpath和jar" class="headerlink" title="classpath和jar"></a>classpath和jar</h3><p><code>classpath</code>是JVM用到的一个环境变量，它用来指示JVM如何搜索<code>class</code>。</p><p>因为Java是编译型语言，源码文件是<code>.java</code>，而编译后的<code>.class</code>文件才是真正可以被JVM执行的字节码。</p><p>jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。</p><blockquote><p> 如何创建jar包？</p></blockquote><p>因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从<code>.zip</code>改为<code>.jar</code>，一个jar包就创建成功。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>JVM通过环境变量<code>classpath</code>决定搜索<code>class</code>的路径和顺序；</p><p>不推荐设置系统环境变量<code>classpath</code>，始终建议通过<code>-cp</code>命令传入；</p><p>jar包相当于目录，可以包含很多<code>.class</code>文件，方便下载和使用；</p><p><code>MANIFEST.MF</code>文件可以提供jar包的信息，如<code>Main-Class</code>，这样可以直接运行jar包。</p><h2 id="Java核心类"><a href="#Java核心类" class="headerlink" title="Java核心类"></a>Java核心类</h2><h3 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h3><ul><li>Java字符串<code>String</code>是不可变对象；</li><li>字符串操作不改变原字符串内容，而是返回新字符串；</li><li>常用的字符串操作：提取子串、查找、替换、大小写转换等；</li><li>Java使用Unicode编码表示<code>String</code>和<code>char</code>；</li><li>转换编码就是将<code>String</code>和<code>byte[]</code>转换，需要指定编码；</li><li>转换为<code>byte[]</code>时，始终优先考虑<code>UTF-8</code>编码。</li></ul><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>为了能高效拼接字符串，Java标准库提供了<code>StringBuilder</code>，它是一个可变对象，可以预分配<strong>缓冲区</strong>，这样，往<code>StringBuilder</code>中新增字符时，<strong>不会创建新的临时对象</strong>；</p><p><code>StringBuilder</code>可以支持<strong>链式操作</strong>，实现链式操作的关键是返回实例本身；</p><h3 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h3><p>用指定分隔符拼接字符串数组时，使用<code>StringJoiner</code>或者<code>String.join()</code>更方便；</p><p>用<code>StringJoiner</code>拼接字符串时，还可以额外附加一个“开头”和“结尾”。</p><h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>Java核心库提供的包装类型可以把基本类型包装为<code>class</code>；</p><p>自动装箱和自动拆箱都是在编译期完成的（JDK&gt;=1.5）；</p><p>装箱和拆箱会影响执行效率，且拆箱时可能发生<code>NullPointerException</code>；</p><p>包装类型的比较必须使用<code>equals()</code>；</p><p>整数和浮点数的包装类型都继承自<code>Number</code>；</p><p>包装类型提供了大量实用方法。</p><h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><p>JavaBean是一种符合命名规范的<code>class</code>，它通过<code>getter</code>和<code>setter</code>来定义属性；</p><p>JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输；</p><p>可以利用IDE快速生成<code>getter</code>和<code>setter</code>；</p><p>属性是一种通用的叫法，并非Java语法规定；</p><p>使用<code>Introspector.getBeanInfo()</code>可以获取属性列表。</p><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>Java使用<code>enum</code>定义枚举类型，它被编译器编译为<code>final class Xxx extends Enum &#123; … &#125;</code>；</p><p>通过<code>name()</code>获取常量定义的字符串，注意不要使用<code>toString()</code>；</p><p>通过<code>ordinal()</code>返回常量定义的顺序（无实质意义）；</p><p>可以为<code>enum</code>编写构造方法、字段和方法</p><p><code>enum</code>的构造方法要声明为<code>private</code>，字段强烈建议声明为<code>final</code>；</p><p><code>enum</code>适合用在<code>switch</code>语句中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Weekday</span> </span>&#123;<br>    MON(<span class="hljs-number">1</span>), TUE(<span class="hljs-number">2</span>), WED(<span class="hljs-number">3</span>), THU(<span class="hljs-number">4</span>), FRI(<span class="hljs-number">5</span>), SAT(<span class="hljs-number">6</span>), SUN(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="纪录类"><a href="#纪录类" class="headerlink" title="纪录类"></a>纪录类</h3><p>使用<code>String</code>、<code>Integer</code>等类型的时候，这些类型都是<strong>不变类</strong>，一个不变类具有以下特点：</p><ol><li>定义class时使用<code>final</code>，无法派生子类；</li><li>每个字段使用<code>final</code>，保证创建实例后无法修改任何字段。</li></ol><p><code>public record Point(int x, int y) &#123;&#125;</code></p><p>从Java 14开始，提供新的<code>record</code>关键字，可以非常方便地定义Data Class：</p><ul><li>使用<code>record</code>定义的是不变类；</li><li>可以编写Compact Constructor对参数进行验证；</li><li>可以定义静态方法。</li></ul><h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h3><p><code>BigInteger</code>用于表示任意大小的整数；</p><p><code>BigInteger</code>是不变类，并且继承自<code>Number</code>；</p><p>将<code>BigInteger</code>转换成基本类型时可使用<code>longValueExact()</code>等方法保证结果准确。</p><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>如果查看<code>BigDecimal</code>的源码，可以发现，实际上一个<code>BigDecimal</code>是通过一个<code>BigInteger</code>和一个<code>scale</code>来表示的，即<code>BigInteger</code>表示一个完整的整数，而<code>scale</code>表示小数位数；</p><p><code>BigDecimal</code>用于表示精确的小数，常用于财务计算；</p><p>比较<code>BigDecimal</code>的值是否相等，必须使用<code>compareTo()</code>而不能使用<code>equals()</code></p><h3 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h3><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><p>数学计算</p><h4 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h4><p>创建<code>Random</code>实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的<strong>伪随机数</strong>序列就不同。</p><h4 id="SecureRandom"><a href="#SecureRandom" class="headerlink" title="SecureRandom"></a>SecureRandom</h4><p>安全的随机数，真随机数。种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="Java的异常"><a href="#Java的异常" class="headerlink" title="Java的异常"></a>Java的异常</h2><p>Java使用异常来表示错误，并通过<code>try ... catch</code>捕获异常；</p><p>Java的异常是<code>class</code>，并且从<code>Throwable</code>继承；</p><p><code>Error</code>是无需捕获的严重错误，<code>Exception</code>是应该捕获的可处理的错误；</p><p><code>RuntimeException</code>无需强制捕获，非<code>RuntimeException</code>（Checked Exception）需强制捕获，或者用<code>throws</code>声明；</p><p>如果不想写任何<code>try</code>代码，可以直接把<code>main()</code>方法定义为<code>throws Exception</code>。也就声明了可能抛出所有的<code>Exception</code>，因此在内部就无需捕获了。代价就是一旦发生异常，程序会立刻退出。</p><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>使用<code>try ... catch ... finally</code>时：</p><ul><li>多个<code>catch</code>语句的匹配顺序非常重要，子类必须放在前面；</li><li><code>finally</code>语句保证了有无异常都会执行，它是可选的；</li><li>一个<code>catch</code>语句也可以匹配多个非继承关系的异常。</li></ul><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>调用<code>printStackTrace()</code>可以打印异常的传播栈，对于调试非常有用；</p><p>捕获异常并再次抛出新的异常时，应该持有原始异常信息；</p><p>通常不要在<code>finally</code>中抛出异常。如果在<code>finally</code>中抛出异常，应该原始异常加入到原有异常中。调用方可通过<code>Throwable.getSuppressed()</code>获取所有添加的<code>Suppressed Exception</code>。</p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>抛出异常时，尽量复用JDK已定义的异常类型；</p><p>自定义异常体系时，推荐从<code>RuntimeException</code>派生“根异常”，再派生出业务异常；</p><p>自定义异常时，应该提供多种构造方法。</p><h2 id="NullPointerException"><a href="#NullPointerException" class="headerlink" title="NullPointerException"></a>NullPointerException</h2><p>空指针异常</p><p>编写业务逻辑时，用空字符串<code>&quot;&quot;</code>表示未填写比<code>null</code>安全得多。</p><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>断言（Assertion）是一种调试程序的方式。在Java中，使用<code>assert</code>关键字来实现断言。</p><h2 id="JDK-Logging"><a href="#JDK-Logging" class="headerlink" title="JDK Logging"></a>JDK Logging</h2><p>日志是为了替代<code>System.out.println()</code>，可以定义格式，重定向到文件等；</p><p>日志可以存档，便于追踪问题；</p><p>日志记录可以按级别分类，便于打开或关闭某些级别；</p><p>可以根据配置文件调整日志，无需修改代码；</p><p>Java标准库提供了<code>java.util.logging</code>来实现日志功能。</p><h2 id="Commons-Logging"><a href="#Commons-Logging" class="headerlink" title="Commons Logging"></a>Commons Logging</h2><p>和Java标准库提供的日志不同，Commons Logging是一个第三方日志库，它是由Apache创建的日志模块。</p><p>Commons Logging是使用最广泛的日志模块；</p><p>Commons Logging的API非常简单；</p><p>Commons Logging可以自动检测并使用其他日志模块。</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。</p><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>JVM为每个加载的class及interface创建了对应的Class实例来保存class及interface的所有信息；</p><p>获取一个class对应的Class实例后，就可以获取该class的所有信息；</p><p>通过Class实例获取class信息的方法称为反射（Reflection）；</p><p>JVM总是动态加载class，可以在运行期根据条件来控制加载class。</p><h2 id="访问字段"><a href="#访问字段" class="headerlink" title="访问字段"></a>访问字段</h2><p>Java的反射API提供的<code>Field</code>类封装了字段的所有信息：</p><p>通过<code>Class</code>实例的方法可以获取<code>Field</code>实例：<code>getField()</code>，<code>getFields()</code>，<code>getDeclaredField()</code>，<code>getDeclaredFields()</code>；</p><p>通过Field实例可以获取字段信息：<code>getName()</code>，<code>getType()</code>，<code>getModifiers()</code>；</p><p>通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用<code>setAccessible(true)</code>来访问非<code>public</code>字段。</p><p>通过反射读写字段是一种非常规方法，它会破坏对象的封装。</p><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>Java的反射API提供的Method对象封装了方法的所有信息：</p><p>通过<code>Class</code>实例的方法可以获取<code>Method</code>实例：<code>getMethod()</code>，<code>getMethods()</code>，<code>getDeclaredMethod()</code>，<code>getDeclaredMethods()</code>；</p><p>通过<code>Method</code>实例可以获取方法信息：<code>getName()</code>，<code>getReturnType()</code>，<code>getParameterTypes()</code>，<code>getModifiers()</code>；</p><p>通过<code>Method</code>实例可以调用某个对象的方法：<code>Object invoke(Object instance, Object... parameters)</code>；</p><p>通过设置<code>setAccessible(true)</code>来访问非<code>public</code>方法；</p><p>通过反射调用方法时，仍然遵循多态原则。</p><h2 id="调用构造方法"><a href="#调用构造方法" class="headerlink" title="调用构造方法"></a>调用构造方法</h2><p><code>Constructor</code>对象封装了构造方法的所有信息；</p><p>通过<code>Class</code>实例的方法可以获取<code>Constructor</code>实例：<code>getConstructor()</code>，<code>getConstructors()</code>，<code>getDeclaredConstructor()</code>，<code>getDeclaredConstructors()</code>；</p><p>通过<code>Constructor</code>实例可以创建一个实例对象：<code>newInstance(Object... parameters)</code>； 通过设置<code>setAccessible(true)</code>来访问非<code>public</code>构造方法。</p><h2 id="获取继承关系"><a href="#获取继承关系" class="headerlink" title="获取继承关系"></a>获取继承关系</h2><p>通过<code>Class</code>对象可以获取继承关系：</p><ul><li><code>Class getSuperclass()</code>：获取父类类型；</li><li><code>Class[] getInterfaces()</code>：获取当前类实现的所有接口。</li></ul><p>通过<code>Class</code>对象的<code>isAssignableFrom()</code>方法可以判断一个向上转型是否可以实现。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>Java标准库提供了动态代理功能，允许在运行期动态创建一个接口的实例；</p><p>动态代理是通过<code>Proxy</code>创建代理对象，然后将接口方法“代理”给<code>InvocationHandler</code>完成的。</p><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h2><p>注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”。<br>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。</p><p>注解（Annotation）是Java语言用于工具处理的标注：</p><p>注解可以配置参数，没有指定配置的参数使用默认值；</p><p>如果参数名称是<code>value</code>，且只有一个参数，那么可以省略参数名称。</p><h2 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h2><p>Java使用<code>@interface</code>定义注解：</p><p>可定义多个参数和默认值，核心参数使用<code>value</code>名称；</p><p>必须设置<code>@Target</code>来指定<code>Annotation</code>可以应用的范围；</p><p>应当设置<code>@Retention(RetentionPolicy.RUNTIME)</code>便于运行期读取该<code>Annotation</code>。</p><h2 id="处理注解"><a href="#处理注解" class="headerlink" title="处理注解"></a>处理注解</h2><p>可以在运行期通过反射读取<code>RUNTIME</code>类型的注解，注意千万不要漏写<code>@Retention(RetentionPolicy.RUNTIME)</code>，否则运行期无法读取到该注解。</p><p>可以通过程序处理注解来实现相应的功能：</p><ul><li>对JavaBean的属性值按规则进行检查；</li><li>JUnit会自动运行<code>@Test</code>标记的测试方法。</li></ul><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>Java的集合类定义在<code>java.util</code>包中，支持泛型，主要提供了3种集合类，包括<code>List</code>，<code>Set</code>和<code>Map</code>。Java集合使用统一的<code>Iterator</code>遍历，尽量不要使用遗留接口。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><code>List</code>的行为和数组几乎完全相同。 List是一个接口，而ArrayList是List接口的一个实现类。 </p><p><code>List</code>是按索引顺序访问的长度可变的有序表，优先使用<code>ArrayList</code>而不是<code>LinkedList</code>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br></code></pre></td></tr></table></figure><p>通过<code>Iterator</code>遍历<code>List</code>永远是最高效的方式。并且，由于<code>Iterator</code>遍历是如此常用，所以，Java的<code>for each</code>循环本身就可以帮我们使用<code>Iterator</code>遍历。</p><p><code>List</code>可以和<code>Array</code>相互转换。</p><p>List和Array的区别是什么？</p><ol><li>数组是定长，list是自动增长。</li><li>数组效率高，list效率低。</li></ol><h2 id="编写equals方法"><a href="#编写equals方法" class="headerlink" title="编写equals方法"></a>编写equals方法</h2><p><code>List</code>还提供了<code>boolean contains(Object o)</code>方法来判断<code>List</code>是否包含某个指定元素。此外，<code>int indexOf(Object o)</code>方法可以返回某个元素的索引，如果元素不存在，就返回<code>-1</code>。</p><p>对于引用字段比较，我们使用<code>equals()</code>，对于基本类型字段的比较，我们使用<code>==</code>。</p><p>总结一下<code>equals()</code>方法的正确编写方法：</p><ol><li>先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；</li><li>用<code>instanceof</code>判断传入的待比较的<code>Object</code>是不是当前类型，如果是，继续比较，否则，返回<code>false</code>；</li><li>对引用类型用<code>Objects.equals()</code>比较，对基本类型直接用<code>==</code>比较。</li></ol><p>如果不调用<code>List</code>的<code>contains()</code>、<code>indexOf()</code>这些方法，就不必覆写<code>equals()</code>方法。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><code>Map</code>是一种映射表，可以通过<code>key</code>快速查找<code>value</code>。无序。</p><p>可以通过<code>for each</code>遍历<code>keySet()</code>，也可以通过<code>for each</code>遍历<code>entrySet()</code>，直接获取<code>key-value</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (String key : map.keySet())<br><span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet())<br></code></pre></td></tr></table></figure><p>最常用的一种<code>Map</code>实现是<code>HashMap</code>。</p><h2 id="编写equals和hashCode"><a href="#编写equals和hashCode" class="headerlink" title="编写equals和hashCode"></a>编写equals和hashCode</h2><p><code>HashMap</code>之所以能根据<code>key</code>直接拿到<code>value</code>，原因是它内部通过空间换时间的方法，用一个大数组存储所有<code>value</code>，并根据key直接计算出<code>value</code>应该存储在哪个索引</p><p>要正确使用<code>HashMap</code>，作为<code>key</code>的类必须正确覆写<code>equals()</code>和<code>hashCode()</code>方法；</p><p>一个类如果覆写了<code>equals()</code>，就必须覆写<code>hashCode()</code>，并且覆写规则是：</p><ul><li>如果<code>equals()</code>返回<code>true</code>，则<code>hashCode()</code>返回值必须相等；</li><li>如果<code>equals()</code>返回<code>false</code>，则<code>hashCode()</code>返回值尽量不要相等。</li></ul><p>实现<code>hashCode()</code>方法可以通过<code>Objects.hashCode()</code>辅助方法实现。</p><h2 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h2><p>如果<code>Map</code>的key是<code>enum</code>类型，推荐使用<code>EnumMap</code>，既保证速度，也不浪费空间。</p><p>使用<code>EnumMap</code>的时候，根据面向抽象编程的原则，应持有<code>Map</code>接口。</p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ascii">       ┌───┐<br>       │Map│<br>       └───┘<br>         ▲<br>    ┌────┴─────┐<br>    │          │<br>┌───────┐ ┌─────────┐<br>│HashMap│ │SortedMap│<br>└───────┘ └─────────┘<br>               ▲<br>               │<br>          ┌─────────┐<br>          │ TreeMap │<br>          └─────────┘<br></code></pre></td></tr></table></figure><p><code>SortedMap</code>是接口，它的实现类是<code>TreeMap</code>。创建<code>TreeMap</code>时同时指定一个自定义排序算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Person, Integer&gt; map = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;(<span class="hljs-keyword">new</span> Comparator&lt;Person&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person p1, Person p2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> p1.name.compareTo(p2.name);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>SortedMap</code>在遍历时严格按照Key的<strong>顺序</strong>遍历，最常用的实现类是<code>TreeMap</code>；</p><p>作为<code>SortedMap</code>的Key必须实现<code>Comparable</code>接口，或者传入<code>Comparator</code>；</p><p>要严格按照<code>compare()</code>规范实现比较逻辑，否则，<code>TreeMap</code>将不能正常工作。</p><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>Java集合库提供的<code>Properties</code>用于读写配置文件<code>.properties</code>。<code>.properties</code>文件可以使用UTF-8编码。</p><p>可以从文件系统、classpath或其他任何地方读取<code>.properties</code>文件。</p><p>读写<code>Properties</code>时，注意仅使用<code>getProperty()</code>和<code>setProperty()</code>方法，不要调用继承而来的<code>get()</code>和<code>put()</code>等方法。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><code>Set</code>实际上相当于只存储key、不存储value的<code>Map</code>。</p><p><code>Set</code>用于存储不重复的元素集合：</p><ul><li>放入<code>HashSet</code>的元素与作为<code>HashMap</code>的key要求相同；</li><li>放入<code>TreeSet</code>的元素与作为<code>TreeMap</code>的Key要求相同；</li></ul><p>利用<code>Set</code>可以去除重复元素；</p><p>遍历<code>SortedSet</code>按照元素的排序顺序遍历，也可以自定义排序算法。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>队列<code>Queue</code>实现了一个先进先出（FIFO）的数据结构：</p><ul><li>通过<code>add()</code>/<code>offer()</code>方法将元素添加到队尾；</li><li>通过<code>remove()</code>/<code>poll()</code>从队首获取元素并删除；</li><li>通过<code>element()</code>/<code>peek()</code>从队首获取元素但不删除。</li></ul><p>要避免把<code>null</code>添加到队列，很难确定是取到了<code>null</code>元素还是队列为空。</p><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p><code>PriorityQueue</code>实现了一个优先队列：从队首获取元素时，总是获取优先级最高的元素。</p><p><code>PriorityQueue</code>默认按元素比较的顺序排序（必须实现<code>Comparable</code>接口），也可以通过<code>Comparator</code>自定义排序算法（元素就不必实现<code>Comparable</code>接口）。</p><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p><code>Deque</code>实现了一个双端队列（Double Ended Queue），它可以：</p><ul><li>将元素添加到队尾或队首：<code>addLast()</code>/<code>offerLast()</code>/<code>addFirst()</code>/<code>offerFirst()</code>；</li><li>从队首／队尾获取元素并删除：<code>removeFirst()</code>/<code>pollFirst()</code>/<code>removeLast()</code>/<code>pollLast()</code>；</li><li>从队首／队尾获取元素但不删除：<code>getFirst()</code>/<code>peekFirst()</code>/<code>getLast()</code>/<code>peekLast()</code>；</li><li>总是调用<code>xxxFirst()</code>/<code>xxxLast()</code>以便与<code>Queue</code>的方法区分开；</li><li>避免把<code>null</code>添加到队列。</li></ul><p><code>Deque</code>是一个接口，它的实现类有<code>ArrayDeque</code>和<code>LinkedList</code>。</p><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>栈（Stack）是一种后进先出（LIFO）的数据结构，操作栈的元素的方法有：</p><ul><li>把元素压栈：<code>push(E)</code>；</li><li>把栈顶的元素“弹出”：<code>pop(E)</code>；</li><li>取栈顶元素但不弹出：<code>peek(E)</code>。</li></ul><p>在Java中，我们用<code>Deque</code>可以实现<code>Stack</code>的功能，注意只调用<code>push()</code>/<code>pop()</code>/<code>peek()</code>方法，避免调用<code>Deque</code>的其他方法。</p><p>最后，不要使用遗留类<code>Stack</code>。</p><h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>我们把这种通过<code>Iterator</code>对象遍历集合的模式称为迭代器。</p><p>使用迭代器的好处在于，调用方总是以统一的方式遍历各种集合类型，而不必关系它们内部的存储结构。</p><p><code>Iterator</code>是一种抽象的数据访问模型。使用<code>Iterator</code>模式进行迭代的好处有：</p><ul><li>对任何集合都采用<strong>同一种访问模型</strong>；</li><li>调用者对集合<strong>内部结构</strong>一无所知；</li><li>集合类返回的<code>Iterator</code>对象知道如何迭代。</li></ul><p>Java提供了标准的迭代器模型，即集合类实现<code>java.util.Iterable</code>接口，返回<code>java.util.Iterator</code>实例。</p><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p><code>Collections</code>类提供了一组工具方法来方便使用集合类：</p><ul><li>创建空集合；</li><li>创建单元素集合；</li><li>创建不可变集合；</li><li>排序／洗牌等操作。</li></ul><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><p>IO是指Input/Output，即输入和输出。以<strong>内存</strong>为中心：</p><ul><li>Input指从外部读入数据到内存</li><li>Output指把数据从内存输出到外部</li></ul><p>IO流是一种顺序读写数据的模式，它的特点是单向流动。数据类似自来水一样在水管中流动，所以我们把它称为IO流。</p><p>IO流以<code>byte</code>（字节）为最小单位，因此也称为<em>字节流</em>。</p><p>如果我们需要读写的是字符，并且字符不全是单字节表示的ASCII字符，那么，按照<code>char</code>来读写显然更方便，这种流称为<em>字符流</em>。</p><h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>同步IO是指，读写IO时代码<strong>必须等待数据返回后才继续执行后续代码</strong>，它的优点是代码编写简单，缺点是CPU执行效率低。</p><p>而异步IO是指，读写IO时<strong>仅发出请求，然后立刻执行后续代码</strong>，它的优点是CPU执行效率高，缺点是代码编写复杂。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>IO流是一种流式的数据输入/输出模型：</p><ul><li>字节流，二进制数据以<code>byte</code>为最小单位在<code>InputStream</code>/<code>OutputStream</code>中单向流动；</li><li>字符流，字符数据以<code>char</code>为最小单位在<code>Reader</code>/<code>Writer</code>中单向流动。</li></ul><h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><p>传入相对路径时，相对路径前面加上当前目录就是绝对路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设当前目录是C:\Docs</span><br>File f1 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;sub\\javac&quot;</span>); <span class="hljs-comment">// 绝对路径是C:\Docs\sub\javac</span><br></code></pre></td></tr></table></figure><p><code>File</code>对象既可以表示文件，<strong>也可以表示目录</strong>。</p><p>Java标准库的<code>java.io.File</code>对象表示一个文件或者目录：</p><ul><li>创建<code>File</code>对象本身不涉及IO操作；</li><li>可以获取路径／绝对路径／规范路径：<code>getPath()</code>/<code>getAbsolutePath()</code>/<code>getCanonicalPath()</code>；</li><li>可以获取目录的文件和子目录：<code>list()</code>/<code>listFiles()</code>；</li><li>可以创建或删除文件和目录。</li></ul><h2 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h2><p>用<code>try ... finally</code>来保证<code>InputStream</code>在无论是否发生IO错误的时候都能够正确地关闭</p><p>Java标准库的<code>java.io.InputStream</code>定义了所有输入流的超类：</p><ul><li><code>FileInputStream</code>实现了文件流输入；</li><li><code>ByteArrayInputStream</code>在内存中模拟一个字节流输入。</li></ul><p>总是使用<code>try(resource)</code>来保证<code>InputStream</code>正确关闭。</p><h2 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h2><p>为什么要有<code>flush()</code>？因为向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个<code>byte[]</code>数组），<strong>等到缓冲区写满了，再一次性写入文件或者网络。</strong></p><p>Java标准库的<code>java.io.OutputStream</code>定义了所有输出流的超类：</p><ul><li><code>FileOutputStream</code>实现了文件流输出；</li><li><code>ByteArrayOutputStream</code>在内存中模拟一个字节流输出。</li></ul><p>某些情况下需要手动调用<code>OutputStream</code>的<code>flush()</code>方法来强制输出缓冲区。</p><p>总是使用<code>try(resource)</code>来保证<code>OutputStream</code>正确关闭。</p><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>Java的IO标准库使用Filter模式为<code>InputStream</code>和<code>OutputStream</code>增加功能：</p><ul><li>可以把一个<code>InputStream</code>和任意个<code>FilterInputStream</code>组合；</li><li>可以把一个<code>OutputStream</code>和任意个<code>FilterOutputStream</code>组合。</li></ul><p>Filter模式可以在运行期动态增加功能（又称Decorator模式）。</p><h2 id="操作Zip"><a href="#操作Zip" class="headerlink" title="操作Zip"></a>操作Zip</h2><p><code>ZipInputStream</code>可以读取zip格式的流，<code>ZipOutputStream</code>可以把多份数据写入zip包；</p><p>配合<code>FileInputStream</code>和<code>FileOutputStream</code>就可以读写zip文件。</p><h2 id="读取classpath资源"><a href="#读取classpath资源" class="headerlink" title="读取classpath资源"></a>读取classpath资源</h2><p>把资源存储在classpath中可以避免文件路径依赖；</p><p><code>Class</code>对象的<code>getResourceAsStream()</code>可以从classpath中读取指定资源；</p><p>根据classpath读取资源时，需要检查返回的<code>InputStream</code>是否为<code>null</code>。</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>序列化是指把一个Java对象变成二进制内容，本质上就是一个<code>byte[]</code>数组。</p><p>为什么要把Java对象序列化呢？因为序列化后可以把<code>byte[]</code>保存到文件中，或者把<code>byte[]</code>通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。</p><p>可序列化的Java对象必须实现<code>java.io.Serializable</code>接口，类似<code>Serializable</code>这样的空接口被称为“标记接口”（Marker Interface）；</p><p>反序列化时不调用构造方法，可设置<code>serialVersionUID</code>作为版本号（非必需）；</p><p>Java的序列化机制仅适用于Java，如果需要与其它语言交换数据，必须使用通用的序列化方法，例如JSON。</p><h2 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h2><p><code>Reader</code>是Java的IO库提供的另一个输入流接口。和<code>InputStream</code>的区别是，<code>InputStream</code>是一个字节流，即以<code>byte</code>为单位读取，而<code>Reader</code>是一个字符流，即以<code>char</code>为单位读取。</p><p><code>Reader</code>定义了所有<strong>字符</strong>输入流的超类：</p><ul><li><code>FileReader</code>实现了文件字符流输入，使用时需要指定编码；</li><li><code>CharArrayReader</code>和<code>StringReader</code>可以在内存中模拟一个字符流输入。</li></ul><p><code>Reader</code>是基于<code>InputStream</code>构造的：可以通过<code>InputStreamReader</code>在指定编码的同时将任何<code>InputStream</code>转换为<code>Reader</code>。</p><p>总是使用<code>try (resource)</code>保证<code>Reader</code>正确关闭。</p><h2 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h2><p><code>Writer</code>定义了所有字符输出流的超类：</p><ul><li><code>FileWriter</code>实现了文件字符流输出；</li><li><code>CharArrayWriter</code>和<code>StringWriter</code>在内存中模拟一个字符流输出。</li></ul><p>使用<code>try (resource)</code>保证<code>Writer</code>正确关闭。</p><p><code>Writer</code>是基于<code>OutputStream</code>构造的，可以通过<code>OutputStreamWriter</code>将<code>OutputStream</code>转换为<code>Writer</code>，转换时需要指定编码。</p><h2 id="PrintStream和PrintWriter"><a href="#PrintStream和PrintWriter" class="headerlink" title="PrintStream和PrintWriter"></a>PrintStream和PrintWriter</h2><p><code>PrintStream</code>是一种<code>FilterOutputStream</code>，它在<code>OutputStream</code>的接口上，额外提供了一些写入各种数据类型的方法。</p><p><code>PrintStream</code>是一种能接收各种数据类型的输出，打印数据时比较方便：</p><ul><li><code>System.out</code>是标准输出；</li><li><code>System.err</code>是标准错误输出。</li></ul><p><code>PrintWriter</code>是基于<code>Writer</code>的输出。</p><h2 id="使用Files"><a href="#使用Files" class="headerlink" title="使用Files"></a>使用Files</h2><p>对于简单的小文件读写操作，可以使用<code>Files</code>工具类简化代码。</p><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h2><p>现代操作系统（Windows，macOS，Linux）都可以执行多任务。多任务就是同时运行多个任务。例如，让浏览器执行0.001秒，让QQ执行0.001秒，再让音乐播放器执行0.001秒，在人看来，CPU就是在同时执行多个任务。</p><p>在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。某些进程内部还需要同时执行多个子任务。例如，我们在使用Word时，Word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。</p><p>进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。</p><p>Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行<code>main()</code>方法，在<code>main()</code>方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。</p><p>因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用<strong>多线程实现多任务</strong>。</p><p>和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难。</p><p>Java多线程编程的特点又在于：</p><ul><li>多线程模型是Java程序最基本的并发模型；</li><li>后续读写网络、数据库、Web开发等都依赖Java多线程模型。</li></ul><h2 id="创建新线程"><a href="#创建新线程" class="headerlink" title="创建新线程"></a>创建新线程</h2><p>Java用<code>Thread</code>对象表示一个线程，通过调用<code>start()</code>启动一个新线程；</p><p>一个线程对象只能调用一次<code>start()</code>方法；</p><p>线程的执行代码写在<code>run()</code>方法中；</p><p>线程调度由操作系统决定，程序本身无法决定调度顺序；</p><p><code>Thread.sleep()</code>可以把当前线程暂停一段时间。</p><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>Java线程对象<code>Thread</code>的状态包括：<code>New</code>、<code>Runnable</code>、<code>Blocked</code>、<code>Waiting</code>、<code>Timed Waiting</code>和<code>Terminated</code>；</p><p>通过对另一个线程对象调用<code>join()</code>方法可以等待其执行结束；</p><p>可以指定等待时间，超过等待时间线程仍然没有结束就不再等待；</p><p>对已经运行结束的线程调用<code>join()</code>方法会立刻返回。</p><h2 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h2><blockquote><p>如果线程需要执行一个长时间任务，就可能需要能中断线程。</p></blockquote><p>对目标线程调用<code>interrupt()</code>方法可以请求中断一个线程，目标线程通过检测<code>isInterrupted()</code>标志获取自身是否已中断。如果目标线程处于等待状态，该线程会捕获到<code>InterruptedException</code>；</p><p>目标线程检测到<code>isInterrupted()</code>为<code>true</code>或者捕获了<code>InterruptedException</code>都应该立刻结束自身线程；</p><p><code>public volatile boolean running = true;</code>通过标志位判断需要正确使用<code>volatile</code>关键字；</p><p><code>volatile</code>关键字解决的是<strong>可见性</strong>问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。</p><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>Java程序入口就是由JVM启动<code>main</code>线程，<code>main</code>线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束。如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。但是有一种线程的目的就是<strong>无限循环</strong>，例如，一个定时触发任务的线程。如果这个线程不结束，JVM进程就无法结束。</p><p>守护线程（Daemon Thread）是指<strong>为其他线程服务</strong>的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。</p><p>守护线程不能持有需要关闭的资源（如打开文件等）。</p><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>当多个线程同时运行时，线程的调度由<strong>操作系统</strong>决定，程序本身无法决定。因此，任何一个线程都有可能在任何指令处被操作系统暂停，然后在某个时间段后继续执行。</p><p>多线程同时读写共享变量时，会造成逻辑错误，因此需要通过<code>synchronized</code>同步；</p><p>同步的本质就是给指定对象加锁lock，加锁后才能继续执行后续代码；</p><p>注意加锁对象必须是同一个实例；</p><p>对JVM定义的单个原子操作不需要同步。</p><h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><p>用<code>synchronized</code>修饰方法可以把整个方法变为同步代码块，<code>synchronized</code>方法加锁对象是<code>this</code>；</p><p>通过合理的设计和数据封装可以让一个类变为“线程安全”；</p><p>一个类没有特殊说明，默认不是thread-safe；</p><p>多线程能否安全访问某个非线程安全的实例，需要具体问题具体分析。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>Java的<code>synchronized</code>锁是可重入锁；</p><p>死锁产生的条件是多线程各自持有不同的锁，并互相试图获取对方已持有的锁，导致无限等待；</p><p>避免死锁的方法是多线程获取锁的顺序要一致。</p><h2 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h2><p><code>wait</code>和<code>notify</code>用于多线程协调运行：</p><ul><li>在<code>synchronized</code>内部可以调用<code>wait()</code>使线程进入等待状态；</li><li>必须在已获得的锁对象上调用<code>wait()</code>方法；</li><li>在<code>synchronized</code>内部可以调用<code>notify()</code>或<code>notifyAll()</code>唤醒其他等待线程；</li><li>必须在已获得的锁对象上调用<code>notify()</code>或<code>notifyAll()</code>方法；</li><li>已唤醒的线程还需要重新获得锁后才能继续执行。</li></ul><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p><code>ReentrantLock</code>可以替代<code>synchronized</code>进行同步；</p><p><code>ReentrantLock</code>获取锁更安全；</p><p>必须先获取到锁，再进入<code>try &#123;...&#125;</code>代码块，最后使用<code>finally</code>保证释放锁；</p><p>可以使用<code>tryLock()</code>尝试获取锁。</p><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p><code>Condition</code>可以替代<code>wait</code>和<code>notify</code>；</p><p><code>Condition</code>对象必须从<code>Lock</code>对象获取。</p><h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><p>使用<code>ReadWriteLock</code>可以提高读取效率：</p><ul><li><code>ReadWriteLock</code>只允许一个线程写入；</li><li><code>ReadWriteLock</code>允许多个线程在没有写入时同时读取；</li><li><code>ReadWriteLock</code>适合读多写少的场景。</li></ul><h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><p><code>StampedLock</code>和<code>ReadWriteLock</code>相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。</p><p>乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</p><p><code>StampedLock</code>提供了乐观读锁，可取代<code>ReadWriteLock</code>以进一步提升并发性能；</p><p><code>StampedLock</code>是不可重入锁。</p><h2 id="Concurrent集合"><a href="#Concurrent集合" class="headerlink" title="Concurrent集合"></a>Concurrent集合</h2><p>使用<code>java.util.concurrent</code>包提供的线程安全的并发集合可以大大简化多线程编程：</p><p>多线程同时读写并发集合是安全的；</p><p>尽量使用Java标准库提供的并发集合，避免自己编写同步代码。</p><h2 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h2><p>使用<code>java.util.concurrent.atomic</code>提供的原子操作可以简化多线程编程：</p><ul><li>原子操作实现了无锁的线程安全；</li><li>适用于计数器，累加器等。</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>JDK提供了<code>ExecutorService</code>实现了线程池功能：</p><ul><li>线程池内部维护一组线程，可以高效执行大量小任务；</li><li><code>Executors</code>提供了静态方法创建不同类型的<code>ExecutorService</code>；</li><li>必须调用<code>shutdown()</code>关闭<code>ExecutorService</code>；</li><li><code>ScheduledThreadPool</code>可以定期调度多个任务。</li></ul><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>对线程池提交一个<code>Callable</code>任务，可以获得一个<code>Future</code>对象；</p><p>可以用<code>Future</code>在将来某个时刻获取结果。</p><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p><code>CompletableFuture</code>可以指定异步处理流程：</p><ul><li><code>thenAccept()</code>处理正常结果；</li><li><code>exceptional()</code>处理异常结果；</li><li><code>thenApplyAsync()</code>用于串行化另一个<code>CompletableFuture</code>；</li><li><code>anyOf()</code>和<code>allOf()</code>用于并行化多个<code>CompletableFuture</code>。</li></ul><h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>Fork/Join是一种基于“分治”的算法：通过分解任务，并行执行，最后合并结果得到最终结果。</p><p><code>ForkJoinPool</code>线程池可以把一个大任务分拆成小任务并行执行，任务类必须继承自<code>RecursiveTask</code>或<code>RecursiveAction</code>。</p><p>使用Fork/Join模式可以进行并行计算以提高效率。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><code>ThreadLocal</code>表示线程的“局部变量”，它确保每个线程的<code>ThreadLocal</code>变量都是各自独立的；</p><p><code>ThreadLocal</code>适合在一个线程的处理流程中保持上下文（避免了同一参数在所有方法中传递）；</p><p>使用<code>ThreadLocal</code>要用<code>try ... finally</code>结构，并在<code>finally</code>中清除。</p><h1 id="Maven基础"><a href="#Maven基础" class="headerlink" title="Maven基础"></a>Maven基础</h1><p>Maven是一个Java项目管理和构建工具，它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建。</p><h2 id="Maven介绍"><a href="#Maven介绍" class="headerlink" title="Maven介绍"></a>Maven介绍</h2><p>项目结构</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">a-maven-project<br>├── pom.xml  <span class="hljs-regexp">//</span> 项目描述文件<br>├── src<br>│   ├── main<br>│   │   ├── java  <span class="hljs-regexp">//</span> Java源码目录<br>│   │   └── resources  <span class="hljs-regexp">//</span> 资源文件<br>│   └── test<br>│       ├── java  <span class="hljs-regexp">//</span> 测试源码<br>│       └── resources<br>└── target  <span class="hljs-regexp">//</span> 所有编译、打包生成的文件都放在target目录里<br></code></pre></td></tr></table></figure><p>一个Java项目的管理和构建工具：</p><ul><li>Maven使用<code>pom.xml</code>定义项目内容，并使用预设的目录结构；</li><li>在Maven中声明一个依赖项可以自动下载并导入classpath；</li><li>Maven使用<code>groupId</code>，<code>artifactId</code>和<code>version</code>唯一定位一个依赖。</li></ul><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>Maven通过解析依赖关系确定项目所需的jar包，常用的4种<code>scope</code>有：<code>compile</code>（默认），<code>test</code>，<code>runtime</code>和<code>provided</code>；</p><p>Maven从中央仓库下载所需的jar包并缓存在本地；</p><p>可以通过镜像仓库加速下载。</p><h2 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h2><p>Maven通过lifecycle、phase和goal来提供标准的构建流程。</p><p>最常用的构建命令是指定phase，然后让Maven执行到指定的phase：</p><ul><li>mvn clean</li><li>mvn clean compile</li><li>mvn clean test</li><li>mvn clean package</li></ul><p>通常情况，我们总是执行phase默认绑定的goal，因此不必指定goal。</p><h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p>Maven通过自定义插件可以执行项目构建时需要的额外功能，使用自定义插件必须在pom.xml中声明插件及配置；</p><p>插件会在某个phase被执行时执行；</p><p>插件的配置和用法需参考插件的官方文档。</p><h2 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h2><p>Maven支持模块化管理，可以把一个大项目拆成几个模块：</p><ul><li>可以通过继承在parent的<code>pom.xml</code>统一定义重复配置；</li><li>可以通过<code>&lt;modules&gt;</code>编译多个模块。</li></ul><h2 id="mvnw"><a href="#mvnw" class="headerlink" title="mvnw"></a>mvnw</h2><p>使用Maven Wrapper，可以为一个项目指定特定的Maven版本。</p><h2 id="发布Artifact"><a href="#发布Artifact" class="headerlink" title="发布Artifact"></a>发布Artifact</h2><p>使用Maven发布一个Artifact时：</p><ul><li>可以发布到本地，然后由静态服务器提供repo服务，使用方必须声明repo地址；</li><li>可以发布到<a href="https://central.sonatype.org/">central.sonatype.org</a>，并自动同步到Maven中央仓库，需要前期申请账号以及本地配置；</li><li>可以发布到GitHub Packages作为私有仓库使用，必须提供Token以及正确的权限才能发布和使用。</li></ul><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="网络编程基础"><a href="#网络编程基础" class="headerlink" title="网络编程基础"></a>网络编程基础</h2><p>计算机网络是指两台或更多的计算机组成的网络，在同一个网络中，任意两台计算机都可以直接通信，因为所有计算机都需要遵循同一种网络协议。</p><p>那什么是互联网呢？互联网是网络的网络（internet），即把很多计算机网络连接起来，形成一个全球统一的互联网。</p><p>因为直接记忆IP地址非常困难，所以我们通常使用域名访问某个特定的服务。域名解析服务器DNS负责把域名翻译成对应的IP，客户端再根据IP地址访问服务器。</p><p>计算机网络的基本概念主要有：</p><ul><li>计算机网络：由两台或更多计算机组成的网络；</li><li>互联网：连接网络的网络；</li><li>IP地址：计算机的网络接口（通常是网卡）在网络中的唯一标识；</li><li>网关：负责连接多个网络，并在多个网络之间转发数据的计算机，通常是路由器或交换机；</li><li>网络协议：互联网使用TCP/IP协议，它泛指互联网协议簇；</li><li>IP协议：一种分组交换传输协议；</li><li>TCP协议：传输控制协议，一种面向连接，可靠传输的协议；</li><li>UDP协议：用户数据报协议，一种无连接，不可靠传输的协议</li></ul><h2 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h2><blockquote><p>为什么需要Socket进行网络通信？</p></blockquote><p>因为仅仅通过IP地址进行通信是不够的，同一台计算机同一时间会运行多个网络应用程序，例如浏览器、QQ、邮件客户端等。当操作系统接收到一个数据包的时候，如果只有IP地址，它没法判断应该发给哪个应用程序，所以，操作系统抽象出Socket接口，每个应用程序需要各自对应到不同的Socket，数据包才能根据Socket正确地发到对应的应用程序。</p><p>一个Socket就是由<strong>IP地址和端口号</strong>（范围是0～65535）组成，可以把Socket简单理解为IP地址加端口号。端口号总是由操作系统分配，它是一个0～65535之间的数字，其中，小于1024的端口属于<em>特权端口</em>，需要管理员权限，大于1024的端口可以由任意用户的应用程序打开。</p><p>使用Java进行TCP编程时，需要使用Socket模型：</p><ul><li>服务器端用<code>ServerSocket</code>监听指定端口；</li><li>客户端使用<code>Socket(InetAddress, port)</code>连接服务器；</li><li>服务器端用<code>accept()</code>接收连接并返回<code>Socket</code>；</li><li>双方通过<code>Socket</code>打开<code>InputStream</code>/<code>OutputStream</code>读写数据；</li><li>服务器端通常使用多线程同时处理多个客户端连接，利用线程池可大幅提升效率；</li><li><code>flush()</code>用于强制输出缓冲区到网络。</li></ul><h2 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h2><p>使用UDP协议通信时，服务器和客户端双方无需建立连接：</p><ul><li>服务器端用<code>DatagramSocket(port)</code>监听端口；</li><li>客户端使用<code>DatagramSocket.connect()</code>指定远程地址和端口；</li><li>双方通过<code>receive()</code>和<code>send()</code>读写数据；</li><li><code>DatagramSocket</code>没有IO流接口，数据被直接写入<code>byte[]</code>缓冲区。</li></ul><h2 id="发生Email"><a href="#发生Email" class="headerlink" title="发生Email"></a>发生Email</h2><p>使用JavaMail API发送邮件本质上是一个MUA(Mail User Agent)软件通过SMTP协议发送邮件至MTA(Mail Transfer Agent)服务器；</p><p>打开调试模式可以看到详细的SMTP交互信息；</p><p>某些邮件服务商需要开启SMTP，并需要独立的SMTP登录密码。</p><h2 id="接收Email"><a href="#接收Email" class="headerlink" title="接收Email"></a>接收Email</h2><p>使用Java接收Email时，可以用POP3协议或IMAP协议。</p><p>使用POP3协议时，需要用Maven引入JavaMail依赖，并确定POP3服务器的域名／端口／是否使用SSL等，然后，调用相关API接收Email。</p><p>设置debug模式可以查看通信详细内容，便于排查错误。</p><h2 id="HTTP编程"><a href="#HTTP编程" class="headerlink" title="HTTP编程"></a>HTTP编程</h2><p>什么是HTTP？HTTP就是目前使用最广泛的Web应用程序使用的基础协议，例如，浏览器访问网站，手机App访问后台服务器，都是通过HTTP协议实现的。</p><p>Java提供了<code>HttpClient</code>作为新的HTTP客户端编程接口用于取代老的<code>HttpURLConnection</code>接口；</p><p><code>HttpClient</code>使用链式调用并通过内置的<code>BodyPublishers</code>和<code>BodyHandlers</code>来更方便地处理数据。</p><h2 id="RMI远程调用"><a href="#RMI远程调用" class="headerlink" title="RMI远程调用"></a>RMI远程调用</h2><p>Java的RMI远程调用是指，一个JVM中的代码可以通过网络实现远程调用另一个JVM的某个方法。RMI是Remote Method Invocation的缩写。</p><p>Java提供了RMI实现远程方法调用：</p><p>RMI通过自动生成stub和skeleton实现网络调用，客户端只需要查找服务并获得接口实例，服务器端只需要编写实现类并注册为服务；</p><p>RMI的序列化和反序列化可能会造成安全漏洞，因此调用双方必须是内网互相信任的机器，不要把1099端口暴露在公网上作为对外服务。</p><h1 id="XML与JSON"><a href="#XML与JSON" class="headerlink" title="XML与JSON"></a>XML与JSON</h1><h2 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a>XML简介</h2><p>XML是可扩展标记语言（eXtensible Markup Language）的缩写，它是是一种数据表示格式，可以描述非常复杂的数据结构，常用于传输和存储数据。</p><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>Java提供的DOM API可以将XML解析为DOM结构，以Document对象表示；</p><p>DOM可在内存中完整表示XML数据结构；</p><p>DOM解析速度慢，内存占用大。</p><h2 id="SAX"><a href="#SAX" class="headerlink" title="SAX"></a>SAX</h2><p>SAX是Simple API for XML的缩写，它是一种基于流的解析方式，边读取XML边解析，并以事件回调的方式让调用者获取数据。因为是一边读一边解析，所以无论XML有多大，占用的内存都很小。</p><p>SAX是一种流式解析XML的API；</p><p>SAX通过事件触发，读取速度快，消耗内存少；</p><p>调用方必须通过回调方法获得解析过程中的数据。</p><h2 id="Jackson"><a href="#Jackson" class="headerlink" title="Jackson"></a>Jackson</h2><p>使用Jackson解析XML，可以直接把XML解析为JavaBean，十分方便。</p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON是JavaScript Object Notation的缩写，它去除了所有JavaScript执行代码，只保留JavaScript的对象格式。</p><p>JSON作为数据传输的格式，有几个显著的优点：</p><ul><li>JSON只允许使用UTF-8编码，不存在编码问题；</li><li>JSON只允许使用双引号作为key，特殊字符用<code>\</code>转义，格式简单；</li><li>浏览器内置JSON支持，如果把数据用JSON发送给浏览器，可以用JavaScript直接处理。</li></ul><p>JSON是轻量级的数据表示方式，常用于Web应用；</p><p>Jackson可以实现JavaBean和JSON之间的转换；</p><p>可以通过Module扩展Jackson能处理的数据类型；</p><p>可以自定义<code>JsonSerializer</code>和<code>JsonDeserializer</code>来定制序列化和反序列化。</p><h1 id="JDBC编程"><a href="#JDBC编程" class="headerlink" title="JDBC编程"></a>JDBC编程</h1><p>Java为关系数据库定义了一套标准的访问接口：JDBC（Java Database Connectivity）</p><h2 id="JDBC简介"><a href="#JDBC简介" class="headerlink" title="JDBC简介"></a>JDBC简介</h2><p>使用JDBC的好处是：</p><ul><li>各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发；</li><li>Java程序编译期仅依赖java.sql包，不依赖具体数据库的jar包；</li><li>可随时替换底层数据库，访问数据库的Java代码基本不变。</li></ul><h2 id="JDBC查询"><a href="#JDBC查询" class="headerlink" title="JDBC查询"></a>JDBC查询</h2><p>JDBC接口的<code>Connection</code>代表一个JDBC连接；</p><p>使用JDBC查询时，总是使用<code>PreparedStatement</code>进行查询而不是<code>Statement</code>；</p><p>查询结果总是<code>ResultSet</code>，即使使用聚合查询也不例外。</p><h2 id="JDBC-更新"><a href="#JDBC-更新" class="headerlink" title="JDBC 更新"></a>JDBC 更新</h2><p>使用JDBC执行<code>INSERT</code>、<code>UPDATE</code>和<code>DELETE</code>都可视为更新操作；</p><p>更新操作使用<code>PreparedStatement</code>的<code>executeUpdate()</code>进行，返回受影响的行数。</p><h2 id="JDBC事务"><a href="#JDBC事务" class="headerlink" title="JDBC事务"></a>JDBC事务</h2><p>数据库事务（Transaction）是由若干个SQL语句构成的一个<strong>操作序列</strong>，有点类似于Java的<code>synchronized</code>同步。数据库系统保证在一个事务中的所有SQL要么<strong>全部</strong>执行成功，要么全部不执行，即数据库事务具有ACID特性：</p><ul><li>Atomicity：原子性</li><li>Consistency：一致性</li><li>Isolation：隔离性</li><li>Durability：持久性</li></ul><p>JDBC提供了事务的支持，使用Connection可以开启、提交或回滚事务。</p><h2 id="JDBC-Batch"><a href="#JDBC-Batch" class="headerlink" title="JDBC Batch"></a>JDBC Batch</h2><p>使用JDBC的batch操作会大大提高执行效率，对内容相同，参数不同的SQL，要优先考虑batch操作。</p><h2 id="JDBC-连接池"><a href="#JDBC-连接池" class="headerlink" title="JDBC 连接池"></a>JDBC 连接池</h2><p>创建线程是一个昂贵的操作，如果有大量的小任务需要执行，并且频繁地创建和销毁线程，实际上会消耗大量的系统资源，往往创建和消耗线程所耗费的时间比执行任务的时间还长，所以，为了提高效率，可以用线程池。</p><p>数据库连接池是一种复用<code>Connection</code>的组件，它可以避免反复创建新连接，提高JDBC代码的运行效率；</p><p>可以配置连接池的详细参数并监控连接池。</p><h1 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a>Web开发</h1><p>什么是JavaEE？JavaEE是Java Platform Enterprise Edition的缩写，即Java企业平台。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ascii">┌────────────────┐<br>│     JavaEE     │<br>│┌──────────────┐│<br>││    JavaSE    ││<br>││┌────────────┐││<br>│││   JavaME   │││<br>││└────────────┘││<br>│└──────────────┘│<br>└────────────────┘<br></code></pre></td></tr></table></figure><h2 id="Web基础"><a href="#Web基础" class="headerlink" title="Web基础"></a>Web基础</h2><p>访问网站，使用App时，都是基于Web这种Browser/Server模式，简称BS架构，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web页面，并把Web页面展示给用户即可。</p><p>对于Browser来说，请求页面的流程如下：</p><ol><li><strong>与服务器建立TCP连接</strong>；</li><li>发送HTTP请求；</li><li>收取HTTP响应，然后把网页在浏览器中显示出来。</li></ol><p>使用B/S架构时，总是通过HTTP协议实现通信；</p><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>Java Servlet 是运行在 Web 服务器的程序，用于处理HTTP请求。</p><p>一个Servlet总是继承自<code>HttpServlet</code>，然后覆写<code>doGet()</code>或<code>doPost()</code>方法。</p><p>编写Web应用程序就是编写Servlet处理HTTP请求；</p><p>Servlet API提供了<code>HttpServletRequest</code>和<code>HttpServletResponse</code>两个高级接口来封装HTTP请求和响应；</p><p>Web应用程序必须按固定结构组织并打包为<code>.war</code>文件；</p><p>需要启动Web服务器来加载我们的war包来运行Servlet。</p><h2 id="Servlet进阶"><a href="#Servlet进阶" class="headerlink" title="Servlet进阶"></a>Servlet进阶</h2><p>一个Webapp中的多个Servlet依靠路径映射来处理不同的请求；</p><p>映射为<code>/</code>的Servlet可处理所有“未匹配”的请求；</p><p>如何处理请求取决于Servlet覆写的对应方法；</p><p>Web服务器通过多线程处理HTTP请求，一个Servlet的处理方法可以由多线程并发执行。</p><h3 id="重定向与转发"><a href="#重定向与转发" class="headerlink" title="重定向与转发"></a>重定向与转发</h3><p>使用重定向时，浏览器知道重定向规则，并且会自动发起新的HTTP请求；</p><p>使用转发时，浏览器并不知道服务器内部的转发逻辑。</p><h3 id="Session和Cookie"><a href="#Session和Cookie" class="headerlink" title="Session和Cookie"></a>Session和Cookie</h3><p>基于唯一ID识别用户身份的机制称为Session。</p><p>…</p><h1 id="Spring开发"><a href="#Spring开发" class="headerlink" title="Spring开发"></a>Spring开发</h1><p>Spring是一个支持快速开发Java EE应用程序的框架。</p><h2 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h2><p>容器是一种为某种特定组件的运行提供必要支持的一个软件环境。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Apache配置https</title>
    <link href="/2021/01/19/Linux/Apache%E9%85%8D%E7%BD%AEhttps/"/>
    <url>/2021/01/19/Linux/Apache%E9%85%8D%E7%BD%AEhttps/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>HTTPS (Hyper Text Transfer Protocol over SecureSocket Layer)，是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性 。HTTPS 在HTTP 的基础下加入SSL，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。</p><a id="more"></a><h1 id="申请免费DV证书"><a href="#申请免费DV证书" class="headerlink" title="申请免费DV证书"></a>申请免费DV证书</h1><p><a href="https://help.aliyun.com/document_detail/156645.html?spm=a2c4g.11186623.6.606.39605b2eT9S1Na">阿里云官方文档</a></p><h2 id="申请SSL证书"><a href="#申请SSL证书" class="headerlink" title="申请SSL证书"></a>申请SSL证书</h2><ol><li><p>访问<a href="https://common-buy.aliyun.com/?spm=a2c4g.11186623.2.8.53e14802HoOdmn&commodityCode=cas_dv_public_cn&request={" ord_time":"1:year","order_num":1,"product":"free_product","certcount":"20"}">证书资源包</a>购买页，领取阿里云免费DV证书。</p></li><li><p>申请免费版SSL证书。</p></li></ol><h2 id="下载证书并上传服务器"><a href="#下载证书并上传服务器" class="headerlink" title="下载证书并上传服务器"></a>下载证书并上传服务器</h2><p><img src="https://img2020.cnblogs.com/blog/1677222/202101/1677222-20210119194324937-2131771008.png" alt><br>重命名文件chain.crt –&gt; ca.crt, public.crt –&gt; server.key<br>通过XShell上传至服务器，并放在<code>/usr/local/apache2/conf/key</code>下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@ECS key]# pwd<br>/usr/local/apache2/conf/key<br>[root@ECS key]# ls<br>ca.crt  server.crt  server.key<br></code></pre></td></tr></table></figure><h1 id="在Apache服务器上安装SSL证书"><a href="#在Apache服务器上安装SSL证书" class="headerlink" title="在Apache服务器上安装SSL证书"></a>在Apache服务器上安装SSL证书</h1><p><a href="https://help.aliyun.com/document_detail/98727.html?spm=a2c4g.11186623.6.636.53e14802HoOdmn">阿里云官方文档</a></p><h2 id="配置httpd-conf"><a href="#配置httpd-conf" class="headerlink" title="配置httpd.conf"></a>配置httpd.conf</h2><p><code># vim /usr/local/apache2/conf/httpd.conf</code></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">LoadModule ssl_module modules/mod_ssl.<span class="hljs-keyword">so</span><br><span class="hljs-keyword">Include</span> <span class="hljs-keyword">conf</span>/extra/httpd-ssl.<span class="hljs-keyword">conf</span><br>#<span class="hljs-keyword">Include</span> <span class="hljs-keyword">conf</span>/extra/httpd-ahssl.<span class="hljs-keyword">conf</span><br></code></pre></td></tr></table></figure><h2 id="配置httpd-ssl-conf"><a href="#配置httpd-ssl-conf" class="headerlink" title="配置httpd-ssl.conf"></a>配置httpd-ssl.conf</h2><p><code># vim /usr/local/apache2/conf/extra/httpd-ssl.conf</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;VirtualHost _default_<span class="hljs-number">:443</span>&gt;</span><br><span class="hljs-attribute"><span class="hljs-nomarkup">DocumentRoot</span></span> <span class="hljs-string">&quot;/usr/local/apache2/htdocs&quot;</span><br><span class="hljs-attribute"><span class="hljs-nomarkup">ServerName</span></span> www.oeong.com:<span class="hljs-number">443</span> # 域名<br><span class="hljs-attribute">ServerAdmin</span> oeong@foxmail.com # 邮箱<br><span class="hljs-attribute">ErrorLog</span> <span class="hljs-string">&quot;/usr/local/apache2/logs/error_log&quot;</span><br><span class="hljs-attribute">TransferLog</span> <span class="hljs-string">&quot;/usr/local/apache2/logs/access_log&quot;</span><br><br><span class="hljs-attribute">SSLCertificateFile</span> <span class="hljs-string">&quot;/usr/local/apache2/conf/key/server.crt&quot;</span><br><span class="hljs-attribute">SSLCertificateKeyFile</span> <span class="hljs-string">&quot;/usr/local/apache2/conf/key/server.key&quot;</span><br><span class="hljs-attribute">SSLCertificateChainFile</span> <span class="hljs-string">&quot;/usr/local/apache2/conf/key/ca.crt&quot;</span><br><br><span class="hljs-attribute">SSLEngine</span> <span class="hljs-literal">on</span><br></code></pre></td></tr></table></figure><h2 id="重启Apache"><a href="#重启Apache" class="headerlink" title="重启Apache"></a>重启Apache</h2><p><code>[root@ECS conf]# /usr/local/apache2/bin/apachectl restart</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>HTTPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL笔记</title>
    <link href="/2020/05/26/SQL/"/>
    <url>/2020/05/26/SQL/</url>
    
    <content type="html"><![CDATA[<p>SQL是<strong>结构化查询语言</strong>的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还可以对数据库进行管理和维护操作。不同的数据库，都支持SQL，这样，我们通过学习SQL这一种语言，就可以操作各种不同的数据库。</p><a id="more"></a><h2 id="关系数据库概述"><a href="#关系数据库概述" class="headerlink" title="关系数据库概述"></a>关系数据库概述</h2><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>什么是SQL？SQL是<strong>结构化查询语言</strong>的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还可以对数据库进行管理和维护操作。不同的数据库，都支持SQL，这样，我们通过学习SQL这一种语言，就可以操作各种不同的数据库。</p><ul><li><a href="https://www.liaoxuefeng.com/wiki/1177760294764384">廖雪峰的SQL教程</a></li></ul><p>本教程约定：<strong>SQL关键字总是大写，以示突出，表名和列名均使用小写</strong>。</p><h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><p>表的每一行称为记录（Record），记录是一个逻辑意义上的数据。<br>表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。</p><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>主键是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。主键也不应该允许<code>NULL</code>。</p><p>可以使用多个列作为联合主键，但联合主键并不常用。</p><h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，<code>class_id</code>仅仅是一个普通的列，只是它起到了外键的作用而已。</p><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。</p><p>一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表<code>user_info</code>和用户详细信息表<code>user_profiles</code>，大部分时候，只需要查询<code>user_info</code>表，并不需要查询<code>user_profiles</code>表，这样就提高了查询速度。</p><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>通过一个表的外键关联到另一个表，我们可以定义出一对多关系。</p><p>例如，一个老师可以对应多个班级，一个班级也可以对应多个老师，因此，班级表和老师表存在多对多关系。</p><p>多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。</p><p>索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。</p><p>如果要经常根据<code>score</code>列进行查询，就可以对<code>score</code>列创建索引：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> students<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">INDEX</span> idx_score (score);<br></code></pre></td></tr></table></figure><p>索引的效率取决于索引列的值是否散列，即该<strong>列的值如果越互不相同，那么索引效率越高</strong>。反过来，如果记录的列存在大量相同的值，例如<code>gender</code>列，大约一半的记录值是<code>M</code>，另一半是<code>F</code>，因此，对该列创建索引就没有意义。</p><p>可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是<strong>在插入、更新和删除记录时，需要同时修改索引</strong>，因此，索引越多，插入、更新和删除记录的速度就越慢。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>通过对数据库表创建索引，可以提高查询速度。</p><p>通过创建唯一索引，可以保证某一列的值具有唯一性。</p><p>数据库索引对于用户和应用程序来说都是透明的。</p><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><h3 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h3><p>使用SELECT查询的基本语句SELECT * FROM &lt;表名&gt;可以查询一个表的所有行和所有列的数据。</p><p>SELECT查询的结果是一个二维表。</p><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>通过<code>WHERE</code>条件查询，可以筛选出符合指定条件的记录，而不是整个表的所有记录。</p><h3 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h3><p>使用<code>SELECT *</code>表示查询表的所有列，使用<code>SELECT 列1, 列2, 列3</code>则可以仅返回指定列，这种操作称为投影。</p><p>SELECT语句可以对结果集的列进行重命名。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>使用<code>ORDER BY</code>可以对结果集进行排序；</p><p>可以对多列进行升序、倒序排序。</p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>使用<code>LIMIT  OFFSET</code>可以对结果集进行分页，每次查询返回结果集的一部分；</p><p>分页查询需要先确定每页的数量和当前页数，然后确定<code>LIMIT</code>和<code>OFFSET</code>的值。</p><h3 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h3><p>使用SQL提供的聚合查询，我们可以方便地计算总数、合计值、平均值、最大值和最小值；</p><p>聚合查询也可以添加WHERE条件。</p><h2 id="TO-BE-CONTINUED…"><a href="#TO-BE-CONTINUED…" class="headerlink" title="TO BE CONTINUED…"></a>TO BE CONTINUED…</h2>]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭网站遇到的问题</title>
    <link href="/2020/04/02/Linux/%E6%90%AD%E7%BD%91%E7%AB%99%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2020/04/02/Linux/%E6%90%AD%E7%BD%91%E7%AB%99%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>前车之鉴，后事之师。</p><a id="more"></a><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="CentOS7安装LAMP"><a href="#CentOS7安装LAMP" class="headerlink" title="CentOS7安装LAMP"></a>CentOS7安装LAMP</h2><p><a href="https://help.aliyun.com/document_detail/50774.html?spm=5176.11065259.1996646101.searchclickresult.65fe1a5640ehqG">https://help.aliyun.com/document_detail/50774.html?spm=5176.11065259.1996646101.searchclickresult.65fe1a5640ehqG</a></p><h3 id="安装apache"><a href="#安装apache" class="headerlink" title="安装apache"></a>安装apache</h3><p><a href="https://blog.csdn.net/u012965203/article/details/94134619">https://blog.csdn.net/u012965203/article/details/94134619</a></p><h2 id="Linux下安装anaconda"><a href="#Linux下安装anaconda" class="headerlink" title="Linux下安装anaconda"></a>Linux下安装anaconda</h2><p><a href="https://blog.csdn.net/zaishijizhidian/article/details/81663387">https://blog.csdn.net/zaishijizhidian/article/details/81663387</a></p><h2 id="apache配置https"><a href="#apache配置https" class="headerlink" title="apache配置https"></a>apache配置https</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@ECS key]# pwd<br>/usr/local/apache2/conf/key<br>[root@ECS key]# vim ../extra/httpd-ssl.conf<br>/usr/local/apache2/bin/apachectl restart 重启<br></code></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/63c748bad09e">https://www.jianshu.com/p/63c748bad09e</a><br><a href="https://blog.csdn.net/qq_36431166/article/details/98631352?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task">https://blog.csdn.net/qq_36431166/article/details/98631352?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h3 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h3><p>[root@ECS ~]# mysql -u root -p    // 进入数据库<br>mysql&gt; set password for root@localhost = password(‘&lt;密码&gt;’);<br>mysql&gt; show databases;    // 显示数据库<br>mysql&gt; use &lt;数据库名&gt;;    // 选择数据库<br>mysql&gt; create database &lt;数据库名&gt;;    // 创建数据库<br>mysql&gt; drop database &lt;数据库名&gt;;    // 删除数据库</p><p>// 创建数据表<br>mysql&gt; create table &lt;数据表名&gt;(<br>    -&gt; id int not null auto_increment,<br>    -&gt; primary key(id)<br>    -&gt; )ENGINE=InnoDB DEFAULT CHARSET=utf8;<br>mysql&gt; drop table &lt;数据表名&gt;;</p><h3 id="ThinkPHP查询数据库时各种条件设置"><a href="#ThinkPHP查询数据库时各种条件设置" class="headerlink" title="ThinkPHP查询数据库时各种条件设置"></a>ThinkPHP查询数据库时各种条件设置</h3><p><a href="https://blog.csdn.net/yexudengzhidao/article/details/54943510">https://blog.csdn.net/yexudengzhidao/article/details/54943510</a></p><h3 id="MySQL中将日期和时间从日期时间中分离出来"><a href="#MySQL中将日期和时间从日期时间中分离出来" class="headerlink" title="MySQL中将日期和时间从日期时间中分离出来"></a>MySQL中将日期和时间从日期时间中分离出来</h3><p><a href="https://cloud.tencent.com/developer/ask/66839">https://cloud.tencent.com/developer/ask/66839</a><br><code>select DATE(dateTimeFeild) as Date, TIME(dateTimeFeild) as Time, col2, col3, FROM Table1 ...</code></p><h3 id="mysql查询特定时间段内的数据"><a href="#mysql查询特定时间段内的数据" class="headerlink" title="mysql查询特定时间段内的数据"></a>mysql查询特定时间段内的数据</h3><p><a href="https://blog.csdn.net/EightSwords/article/details/79702101">https://blog.csdn.net/EightSwords/article/details/79702101</a><br>– 今天<br>select fullName,addedTime from t_user where to_days(addedTime) = to_days(now());   </p><h1 id="ThinkPHP"><a href="#ThinkPHP" class="headerlink" title="ThinkPHP"></a>ThinkPHP</h1><h2 id="php部署问题"><a href="#php部署问题" class="headerlink" title="php部署问题"></a>php部署问题</h2><p>php项目部署到服务器上，无需改ip地址的配置，还是127.0.0.1<br>在Loginout.php中要写入自己的ip</p><h3 id="failed-to-open-stream-Permission-denied-in-错误的解决方法"><a href="#failed-to-open-stream-Permission-denied-in-错误的解决方法" class="headerlink" title="failed to open stream:Permission denied in 错误的解决方法"></a>failed to open stream:Permission denied in 错误的解决方法</h3><p>给runtime以其下面的文件写权限</p><h3 id="Thinkphp5开启调试模式"><a href="#Thinkphp5开启调试模式" class="headerlink" title="Thinkphp5开启调试模式"></a>Thinkphp5开启调试模式</h3><p>在application/config.php中把调试模式改为true</p><h3 id="重定向和跳转要继承Controller"><a href="#重定向和跳转要继承Controller" class="headerlink" title="重定向和跳转要继承Controller"></a>重定向和跳转要继承Controller</h3><h2 id="mkdir-Permission-denied"><a href="#mkdir-Permission-denied" class="headerlink" title="mkdir() Permission denied"></a>mkdir() Permission denied</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 查看apache的用户和用户组<br>[root@ECS tp5]# ps aux | grep apache <br>[root@ECS htdocs]# chown -R daemon tp5/<br>[root@ECS htdocs]# chgrp -R daemon tp5/<br>[root@ECS tp5]# chmod -R 777 runtime/<br></code></pre></td></tr></table></figure><h2 id="thinkphp-中html标签加载js-css-img-script的路径问题"><a href="#thinkphp-中html标签加载js-css-img-script的路径问题" class="headerlink" title="thinkphp 中html标签加载js,css,img,script的路径问题"></a>thinkphp 中html标签加载js,css,img,script的路径问题</h2><p>在thinkphp中，路径中不能用”../“表示上一级，而是用正斜杠”/“表示项目根目录<br>D:\phpstudy_pro\WWW\oeong.demo\tp5\public\js\index.js<br>引用<code>&lt;script src=&quot;/tp5/public/js/index.js&quot;&gt;&lt;/script&gt;</code><br><a href="https://blog.csdn.net/luguo0816/article/details/7192482?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task">https://blog.csdn.net/luguo0816/article/details/7192482?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p><h2 id="thinkphp-更换跳转模板"><a href="#thinkphp-更换跳转模板" class="headerlink" title="thinkphp 更换跳转模板"></a>thinkphp 更换跳转模板</h2><p><a href="https://www.cnblogs.com/wenhainan/p/7481723.html">https://www.cnblogs.com/wenhainan/p/7481723.html</a></p><h2 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h2><p><a href="https://blog.csdn.net/yexudengzhidao/article/details/54943510">https://blog.csdn.net/yexudengzhidao/article/details/54943510</a></p><p>如果是mac或者linux环境，请确保runtime目录有可写权限</p><p>上面的目录结构和名称是可以改变的，尤其是应用的目录结构，这取决于你的入口文件和配置参数。</p><h2 id="Form-提交表单的时候-避免跳转页面"><a href="#Form-提交表单的时候-避免跳转页面" class="headerlink" title="Form 提交表单的时候 避免跳转页面"></a>Form 提交表单的时候 避免跳转页面</h2><ol><li>target参数、iframe<br><a href="https://blog.csdn.net/h2503652646/article/details/86634345">https://blog.csdn.net/h2503652646/article/details/86634345</a></li><li>重定向<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">use</span> \<span class="hljs-title">think</span>\<span class="hljs-title">Controller</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> *** <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>&#123; <br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">$this</span>-&gt;redirect(<span class="hljs-string">&quot;http://localhost:8080/tp5/public/index.php&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1>在vi中可以通过:/xxx进行搜索定位，n键查找下一项<br>创建软链接 <code>ln -s  &lt; source&gt;  &lt;target&gt;</code><br>cd - 返回上一次目录<br>在 /usr/local/apache2/conf/httpd.conf中找到User<br><code>chown -R &lt;user&gt;:&lt;group&gt; *</code></li></ol><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><h2 id="下拉框设置默认值"><a href="#下拉框设置默认值" class="headerlink" title="下拉框设置默认值"></a>下拉框设置默认值</h2><p><a href="https://blog.csdn.net/qq_37117258/article/details/100551443">https://blog.csdn.net/qq_37117258/article/details/100551443</a></p><h2 id="屏蔽广告"><a href="#屏蔽广告" class="headerlink" title="屏蔽广告"></a>屏蔽广告</h2><p>找到广告所在的div</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">#&lt;idname&gt; &#123;<br>    <span class="hljs-attribute">display</span>: none;<br>    <span class="hljs-attribute">visibility</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="js实现点击后改变一个css"><a href="#js实现点击后改变一个css" class="headerlink" title="js实现点击后改变一个css"></a>js实现点击后改变一个css</h2><p>document.getElementById(“tbl”).className = “click”;<br>.click, td, th{border: 1px solid black;}</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>VScode格式化代码<br>Shift + Alt + F</p><h2 id="函数和类、属性命名"><a href="#函数和类、属性命名" class="headerlink" title="函数和类、属性命名"></a>函数和类、属性命名</h2><p><strong>类</strong>的命名采用驼峰法（首字母大写），例如 User、UserType，默认不需要添加后缀，例如UserController应该直接命名为User；<br><strong>函数</strong>的命名使用小写字母和下划线（小写字母开头）的方式，例如 get_client_ip；<br><strong>方法</strong>的命名使用驼峰法（首字母小写），例如 getUserName；<br><strong>属性</strong>的命名使用驼峰法（首字母小写），例如 tableName、instance；<br>以双下划线“__”打头的函数或方法作为魔术方法，例如 __call 和 __autoload；</p><h2 id="云服务器ECS与轻量应用服务器的区别"><a href="#云服务器ECS与轻量应用服务器的区别" class="headerlink" title="云服务器ECS与轻量应用服务器的区别"></a>云服务器ECS与轻量应用服务器的区别</h2><ul><li>云服务器ECS（Elastic Compute Service）是一种简单高效、处理能力可弹性伸缩的计算服务。帮助您构建更稳定、安全的应用，提升运维效率，降低IT成本，使您更专注于核心业务创新。</li><li>轻量应用服务器是面向单机应用场景的新一代计算服务，提供应用一键部署、一站式域名解析、网站发布、安全、运维、应用管理等服务。极大地优化了搭建简单应用的体验，降低了入门级用户使用云计算产品的门槛。</li></ul><p>阿里云ECS学生机配置：CPU1核、内存2GB、带宽1Mbps</p>]]></content>
    
    
    <categories>
      
      <category>WebSite</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>WebSite</tag>
      
      <tag>ThinkPHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThinkPHP5.0</title>
    <link href="/2020/04/02/PHP/ThinkPHP5/"/>
    <url>/2020/04/02/PHP/ThinkPHP5/</url>
    
    <content type="html"><![CDATA[<p>ThinkPHP是一个免费开源的，快速、简单的面向对象的轻量级PHP开发框架，是为了敏捷WEB应用开发和简化企业应用开发而诞生的。</p><a id="more"></a><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>ThinkPHP是一个免费开源的，快速、简单的面向对象的轻量级PHP开发框架，是为了敏捷WEB应用开发和简化企业应用开发而诞生的。</p><ul><li><a href="https://www.kancloud.cn/manual/thinkphp5/118003">ThinkPHP5.0官方手册</a><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h3>函数和类、属性命名</li><li>类的命名采用驼峰法（首字母大写），例如 User、UserType，默认不需要添加后缀，例如UserController应该直接命名为User；</li><li>函数的命名使用小写字母和下划线（小写字母开头）的方式，例如 get_client_ip；</li><li>方法的命名使用驼峰法（首字母小写），例如 getUserName；</li><li>属性的命名使用驼峰法（首字母小写），例如 tableName、instance；</li><li>以双下划线“__”打头的函数或方法作为魔术方法，例如 __call 和 <em>\</em>autoload；</li></ul><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>如果是mac或者linux环境，请确保<code>runtime</code>目录有可写权限<br>目录结构和名称是可以改变的，尤其是应用的目录结构，这取决于你的入口文件和配置参数。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="架构总览"><a href="#架构总览" class="headerlink" title="架构总览"></a>架构总览</h3><p>ThinkPHP5.0应用基于MVC（模型-视图-控制器）的方式来组织。</p><h4 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h4><p>用户请求的PHP文件，负责处理一个请求（注意，不一定是URL请求）的生命周期，最常见的入口文件就是<code>index.php</code></p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>应用在ThinkPHP中是一个<strong>管理系统架构及生命周期的对象</strong>，由系统的 \think\App类完成，应用通常在入口文件中被调用和执行</p><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><p>每个模块拥有独立的MVC类库及配置文件，一个模块下面有多个控制器负责响应请求，而每个控制器其实就是一个独立的控制器类。</p><p>控制器主要负责请求的接收，并调用相关的模型处理，并最终通过视图输出。</p><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><p>模型类通常完成实际的业务逻辑和数据封装，并返回和格式无关的数据。</p><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>控制器调用模型类后返回的数据通过视图组装成不同格式的输出。视图根据不同的需求，来决定调用模板引擎进行内容解析后输出还是直接输出。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="入口文件-1"><a href="#入口文件-1" class="headerlink" title="入口文件"></a>入口文件</h4><p>用户发起的请求都会经过应用的入口文件，通常是 public/index.php文件。</p><h4 id="引导文件"><a href="#引导文件" class="headerlink" title="引导文件"></a>引导文件</h4><h4 id="URL访问检测"><a href="#URL访问检测" class="headerlink" title="URL访问检测"></a>URL访问检测</h4><p>应用初始化完成后，就会进行URL的访问检测，包括PATH_INFO检测和URL后缀检测。</p><h3 id="入口文件-2"><a href="#入口文件-2" class="headerlink" title="入口文件"></a>入口文件</h3><p>入口文件位置的设计是为了让应用部署更安全，public目录为web可访问目录，其他的文件都可以放到非WEB访问目录下面。</p><h3 id="URL访问"><a href="#URL访问" class="headerlink" title="URL访问"></a>URL访问</h3><p>ThinkPHP5.0在没有启用路由的情况下典型的URL访问规则是：<br><code>http://serverName/index.php（或者其它应用入口文件）/模块/控制器/操作/[参数名/参数值...]</code></p><h3 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h3><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>路由的作用是简化URL访问地址，并根据定义的路由类型做出正确的解析。</p><h3 id="域名路由"><a href="#域名路由" class="headerlink" title="域名路由"></a>域名路由</h3><p>ThinkPHP支持完整域名、子域名和IP部署的路由和绑定功能，同时还可以起到简化URL的作用。</p><h2 id="控制器-1"><a href="#控制器-1" class="headerlink" title="控制器"></a>控制器</h2><h3 id="控制器定义"><a href="#控制器定义" class="headerlink" title="控制器定义"></a>控制器定义</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">namespace</span> <span class="hljs-title">app</span>\<span class="hljs-title">index</span>\<span class="hljs-title">controller</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> </span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">index</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;index&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>控制器类文件的实际位置是<code>application\index\controller\Index.php</code></p><h3 id="控制器初始化"><a href="#控制器初始化" class="headerlink" title="控制器初始化"></a>控制器初始化</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">namespace</span> <span class="hljs-title">app</span>\<span class="hljs-title">index</span>\<span class="hljs-title">controller</span>;<br><br><span class="hljs-keyword">use</span> <span class="hljs-title">think</span>\<span class="hljs-title">Controller</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span></span><br><span class="hljs-class"></span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_initialize</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;init&lt;br/&gt;&#x27;</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果访问<code>http://localhost/index.php/index/Index/hello</code><br>会输出</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">init</span><br>hello<br></code></pre></td></tr></table></figure><h3 id="前置操作"><a href="#前置操作" class="headerlink" title="前置操作"></a>前置操作</h3><h3 id="跳转和重定向"><a href="#跳转和重定向" class="headerlink" title="跳转和重定向"></a>跳转和重定向</h3><blockquote><p>重定向和跳转要继承Controller</p></blockquote><h4 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h4><p>系统的\think\Controller类内置了两个跳转方法<code>success</code>和<code>error</code>，用于页面跳转提示。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span> (<span class="hljs-variable">$result</span>) &#123;<br>    <span class="hljs-comment">//设置成功后跳转页面的地址，默认的返回页面是$_SERVER[&#x27;HTTP_REFERER&#x27;]</span><br>    <span class="hljs-keyword">$this</span>-&gt;success(<span class="hljs-string">&#x27;新增成功&#x27;</span>, <span class="hljs-string">&#x27;User/list&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//错误页面的默认跳转页面是返回前一页，通常不需要设置</span><br>    <span class="hljs-keyword">$this</span>-&gt;error(<span class="hljs-string">&#x27;新增失败&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>\think\Controller类的redirect方法可以实现页面的重定向功能。<br>$this-&gt;redirect(“<a href="http://localhost:8080/tp5/public/index.php&quot;">http://localhost:8080/tp5/public/index.php&quot;</a>);</p><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><h3 id="请求信息"><a href="#请求信息" class="headerlink" title="请求信息"></a>请求信息</h3><p>如果要获取当前的请求信息，可以使用\think\Request类<br><code>$request = Request::instance();</code><br>或助手函数<code>$request = request();</code></p><h3 id="输入变量"><a href="#输入变量" class="headerlink" title="输入变量"></a>输入变量</h3><h4 id="获取POST变量"><a href="#获取POST变量" class="headerlink" title="获取POST变量"></a>获取POST变量</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">Request::instance()-&gt;post(<span class="hljs-string">&#x27;name&#x27;</span>); <span class="hljs-comment">// 获取某个post变量</span><br>Request::instance()-&gt;post(); <span class="hljs-comment">// 获取经过过滤的全部post变量</span><br></code></pre></td></tr></table></figure><h4 id="获取SESSION变量"><a href="#获取SESSION变量" class="headerlink" title="获取SESSION变量"></a>获取SESSION变量</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">Request::instance()-&gt;session(<span class="hljs-string">&#x27;user_id&#x27;</span>); <span class="hljs-comment">// 获取某个session变量</span><br>Request::instance()-&gt;session(); <span class="hljs-comment">// 获取全部的session变量</span><br></code></pre></td></tr></table></figure><h4 id="获取Cookie变量"><a href="#获取Cookie变量" class="headerlink" title="获取Cookie变量"></a>获取Cookie变量</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">Request::instance()-&gt;cookie(<span class="hljs-string">&#x27;user_id&#x27;</span>); <span class="hljs-comment">// 获取某个cookie变量</span><br>Request::instance()-&gt;cookie(); <span class="hljs-comment">// 获取全部的cookie变量</span><br></code></pre></td></tr></table></figure><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>支持query（查询操作）和execute（写入操作）方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">Db::query(<span class="hljs-string">&#x27;select * from think_user where id=?&#x27;</span>,[<span class="hljs-number">8</span>]);<br>Db::execute(<span class="hljs-string">&#x27;insert into think_user (id, name) values (?, ?)&#x27;</span>,[<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;thinkphp&#x27;</span>]);<br></code></pre></td></tr></table></figure><h3 id="查询构造器"><a href="#查询构造器" class="headerlink" title="查询构造器"></a>查询构造器</h3><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><p>查询一个数据使用：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// table方法必须指定完整的数据表名</span><br>Db::table(<span class="hljs-string">&#x27;think_user&#x27;</span>)-&gt;where(<span class="hljs-string">&#x27;id&#x27;</span>,<span class="hljs-number">1</span>)-&gt;find();<br></code></pre></td></tr></table></figure><p>查询数据集使用：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">Db::table(<span class="hljs-string">&#x27;think_user&#x27;</span>)-&gt;where(<span class="hljs-string">&#x27;status&#x27;</span>,<span class="hljs-number">1</span>)-&gt;select();<br></code></pre></td></tr></table></figure><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><p>添加一条数据</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$data</span> = [<span class="hljs-string">&#x27;foo&#x27;</span> =&gt; <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span> =&gt; <span class="hljs-string">&#x27;foo&#x27;</span>];<br>Db::table(<span class="hljs-string">&#x27;think_user&#x27;</span>)-&gt;insert(<span class="hljs-variable">$data</span>);<br></code></pre></td></tr></table></figure><p>添加多条数据</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$data</span> = [<br>    [<span class="hljs-string">&#x27;foo&#x27;</span> =&gt; <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span> =&gt; <span class="hljs-string">&#x27;foo&#x27;</span>],<br>    [<span class="hljs-string">&#x27;foo&#x27;</span> =&gt; <span class="hljs-string">&#x27;bar1&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span> =&gt; <span class="hljs-string">&#x27;foo1&#x27;</span>],<br>    [<span class="hljs-string">&#x27;foo&#x27;</span> =&gt; <span class="hljs-string">&#x27;bar2&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span> =&gt; <span class="hljs-string">&#x27;foo2&#x27;</span>]<br>];<br>Db::name(<span class="hljs-string">&#x27;user&#x27;</span>)-&gt;insertAll(<span class="hljs-variable">$data</span>);<br></code></pre></td></tr></table></figure><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><p><code>Db::table(&#39;think_user&#39;)-&gt;where(&#39;id&#39;, 1)-&gt;update([&#39;name&#39; =&gt; &#39;thinkphp&#39;]);</code></p><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 根据主键删除</span><br>Db::table(<span class="hljs-string">&#x27;think_user&#x27;</span>)-&gt;delete(<span class="hljs-number">1</span>);<br>Db::table(<span class="hljs-string">&#x27;think_user&#x27;</span>)-&gt;delete([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);<br><br><span class="hljs-comment">// 条件删除    </span><br>Db::table(<span class="hljs-string">&#x27;think_user&#x27;</span>)-&gt;where(<span class="hljs-string">&#x27;id&#x27;</span>,<span class="hljs-number">1</span>)-&gt;delete();<br>Db::table(<span class="hljs-string">&#x27;think_user&#x27;</span>)-&gt;where(<span class="hljs-string">&#x27;id&#x27;</span>,<span class="hljs-string">&#x27;&lt;&#x27;</span>,<span class="hljs-number">10</span>)-&gt;delete();<br></code></pre></td></tr></table></figure><h2 id="视图-1"><a href="#视图-1" class="headerlink" title="视图"></a>视图</h2><p>继承\think\Controller类</p><h3 id="模板渲染"><a href="#模板渲染" class="headerlink" title="模板渲染"></a>模板渲染</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 不带任何参数 自动定位当前操作的模板文件</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;fetch();<br></code></pre></td></tr></table></figure><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="包含文件"><a href="#包含文件" class="headerlink" title="包含文件"></a>包含文件</h3><p>{include file=’模版文件1,模版文件2,…’ /}</p><h3 id="内置标签"><a href="#内置标签" class="headerlink" title="内置标签"></a>内置标签</h3><p>volist标签通常用于查询数据集（select方法）的结果输出，通常模型的select方法返回的结果是一个二维数组，可以直接使用volist标签进行输出。</p><h3 id="资源文件加载"><a href="#资源文件加载" class="headerlink" title="资源文件加载"></a>资源文件加载</h3><p>传统方式的导入外部JS和CSS文件的方法是直接在模板文件使用：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">&lt;script type=<span class="hljs-string">&#x27;text/javascript&#x27;</span> src=<span class="hljs-string">&#x27;/static/js/common.js&#x27;</span>&gt;<br>&lt;link rel=<span class="hljs-string">&quot;stylesheet&quot;</span> type=<span class="hljs-string">&quot;text/css&quot;</span> href=<span class="hljs-string">&quot;/static/css/style.css&quot;</span> /&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ThinkPHP</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP笔记</title>
    <link href="/2020/03/15/PHP/PHP/"/>
    <url>/2020/03/15/PHP/PHP/</url>
    
    <content type="html"><![CDATA[<blockquote><p>PHP is a popular general-purpose scripting language that is especially suited to web development.</p></blockquote><a id="more"></a><h1 id="PHP基础"><a href="#PHP基础" class="headerlink" title="PHP基础"></a>PHP基础</h1><h2 id="PHP简介"><a href="#PHP简介" class="headerlink" title="PHP简介"></a>PHP简介</h2><p>PHP（全称：PHP：Hypertext Preprocessor，即”PHP：超文本预处理器”）是一种通用开源脚本语言。<br>PHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器。</p><ul><li><a href="https://www.runoob.com/php/php-tutorial.html">菜鸟教程</a></li><li><a href="https://www.php.net/">https://www.php.net/</a></li></ul><h3 id="PHP能做什么？"><a href="#PHP能做什么？" class="headerlink" title="PHP能做什么？"></a>PHP能做什么？</h3><ul><li>PHP 可以生成动态页面内容</li><li>PHP 可以收集表单数据</li><li>PHP 可以添加、删除、修改您的数据库中的数据</li></ul><h2 id="PHP语法"><a href="#PHP语法" class="headerlink" title="PHP语法"></a>PHP语法</h2><p>PHP 脚本以 <?php 开始，以 ?> 结束。<br>PHP 中的每个代码行都必须以分号结束。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello World!&quot;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="PHP语法-1"><a href="#PHP语法-1" class="headerlink" title="PHP语法"></a>PHP语法</h2><ol><li>定义在函数外部的就是全局变量，它的作用域从定义处一直到文件结尾。</li><li>函数内定义的变量就是局部变量，它的作用域为函数定义范围内。</li><li>函数之间存在作用域互不影响。</li><li>函数内访问全局变量需要 <code>global</code> 关键字或者使用 <code>$GLOBALS[index]</code> 数组</li><li><code>static</code> 关键字使某个局部变量不被删除。</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$x</span>=<span class="hljs-number">5</span>;<br><span class="hljs-variable">$y</span>=<span class="hljs-number">10</span>;<br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myTest</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">global</span> <span class="hljs-variable">$x</span>,<span class="hljs-variable">$y</span>;<br>    <span class="hljs-variable">$y</span>=<span class="hljs-variable">$x</span>+<span class="hljs-variable">$y</span>;<br>&#125;<br> <br>myTest();<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$y</span>; <span class="hljs-comment">// 输出 15</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="echo-和-print-语句"><a href="#echo-和-print-语句" class="headerlink" title="echo 和 print 语句"></a>echo 和 print 语句</h2><h2 id="EOF-heredoc-使用说明"><a href="#EOF-heredoc-使用说明" class="headerlink" title="EOF(heredoc) 使用说明"></a>EOF(heredoc) 使用说明</h2><p>PHP 定界符<code>EOF</code> 中是会解析 html 格式内容的，并且在双引号内的内容也有转义效果。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$name</span>=<span class="hljs-string">&quot;runoob&quot;</span>;<br><span class="hljs-variable">$a</span>= &lt;&lt;&lt;EOF<br>&lt;h1&gt;EOF&lt;/h1&gt;<br>        <span class="hljs-string">&quot;abc&quot;</span><span class="hljs-variable">$name</span><br>        <span class="hljs-string">&quot;123&quot;</span><br>EOF;<br><span class="hljs-comment">// 结束需要独立一行且前后不能空格</span><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$a</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><code>var_dump()</code> 函数返回变量的数据类型和值</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$cars</span>=<span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;Volvo&quot;</span>,<span class="hljs-string">&quot;BMW&quot;</span>,<span class="hljs-string">&quot;Toyota&quot;</span>); <span class="hljs-comment">// 数组</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> <span class="hljs-variable">$color</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$color</span>=<span class="hljs-string">&quot;green&quot;</span></span>) </span>&#123;<br>    <span class="hljs-keyword">$this</span>-&gt;color = <span class="hljs-variable">$color</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">what_color</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;color;<br>  &#125;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="类型比较"><a href="#类型比较" class="headerlink" title="类型比较"></a>类型比较</h2><ul><li>松散比较：使用两个等号 == 比较，只比较值，不比较类型。</li><li>严格比较：用三个等号 === 比较，除了比较值，也比较类型。</li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量值被定义后，在脚本的其他任何地方都不能被改变。<br>bool define ( string $name , mixed $value [, bool $case_insensitive = false ] )</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// true 不区分大小写的常量名</span><br>define(<span class="hljs-string">&quot;GREETING&quot;</span>, <span class="hljs-string">&quot;欢迎&quot;</span>, <span class="hljs-literal">true</span>);<br><span class="hljs-keyword">echo</span> greeting;  <span class="hljs-comment">// 输出 &quot;欢迎&quot;</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="字符串变量"><a href="#字符串变量" class="headerlink" title="字符串变量"></a>字符串变量</h2><p>*<em>并置运算符 *</em>(.) 用于把两个字符串值连接起来。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$txt1</span>=<span class="hljs-string">&quot;Hello world!&quot;</span>;<br><span class="hljs-variable">$txt2</span>=<span class="hljs-string">&quot;What a nice day!&quot;</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$txt1</span> . <span class="hljs-string">&quot; &quot;</span> . <span class="hljs-variable">$txt2</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>strlen() 函数返回字符串的长度（字节数）。</p><p>strpos() 函数用于在字符串内查找一个字符或一段指定的文本。<br><code>echo strpos(&quot;Hello world!&quot;,&quot;world&quot;);</code></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>运算符优先级中，or 和 ||，&amp;&amp; 和 and 都是逻辑运算符，效果一样，但是其优先级却不一样。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// 优先级： &amp;&amp;  &gt;  =  &gt;  and</span><br><span class="hljs-comment">// 优先级： ||  &gt;  =  &gt;  or</span><br> <br><span class="hljs-variable">$a</span> = <span class="hljs-number">3</span>;<br><span class="hljs-variable">$b</span> = <span class="hljs-literal">false</span>;<br><span class="hljs-variable">$c</span> = <span class="hljs-variable">$a</span> <span class="hljs-keyword">or</span> <span class="hljs-variable">$b</span>;<br>var_dump(<span class="hljs-variable">$c</span>);          <span class="hljs-comment">// 这里的 $c 为 int 值3，而不是 boolean 值 true</span><br><span class="hljs-variable">$d</span> = <span class="hljs-variable">$a</span> || <span class="hljs-variable">$b</span>;<br>var_dump(<span class="hljs-variable">$d</span>);          <span class="hljs-comment">//这里的 $d 就是 boolean 值 true </span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="If…Else"><a href="#If…Else" class="headerlink" title="If…Else"></a>If…Else</h2><h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$cars</span>=<span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;Volvo&quot;</span>,<span class="hljs-string">&quot;BMW&quot;</span>,<span class="hljs-string">&quot;Toyota&quot;</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;I like &quot;</span> . <span class="hljs-variable">$cars</span>[<span class="hljs-number">0</span>] . <span class="hljs-string">&quot;, &quot;</span> . <span class="hljs-variable">$cars</span>[<span class="hljs-number">1</span>] . <span class="hljs-string">&quot; and &quot;</span> . <span class="hljs-variable">$cars</span>[<span class="hljs-number">2</span>] . <span class="hljs-string">&quot;.&lt;br&gt;&quot;</span>;<br><span class="hljs-keyword">echo</span> count(<span class="hljs-variable">$cars</span>);<span class="hljs-comment">// 数组长度</span><br><br><span class="hljs-comment">// 关联数组</span><br><span class="hljs-variable">$age</span>=<span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;Peter&quot;</span>=&gt;<span class="hljs-string">&quot;35&quot;</span>,<span class="hljs-string">&quot;Ben&quot;</span>=&gt;<span class="hljs-string">&quot;37&quot;</span>,<span class="hljs-string">&quot;Joe&quot;</span>=&gt;<span class="hljs-string">&quot;43&quot;</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br&gt;Peter is &quot;</span> . <span class="hljs-variable">$age</span>[<span class="hljs-string">&#x27;Peter&#x27;</span>] . <span class="hljs-string">&quot; years old.&quot;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><p>sort() - 对数组进行升序排列<br>rsort() - 对数组进行降序排列<br>asort() - 根据关联数组的值，对数组进行升序排列<br>ksort() - 根据关联数组的键，对数组进行升序排列</p><h2 id="超级全局变量"><a href="#超级全局变量" class="headerlink" title="超级全局变量"></a>超级全局变量</h2><p>超级全局变量在PHP 4.1.0之后被启用, 是PHP系统中自带的变量，在一个脚本的全部作用域中都可用。<br><code>$GLOBALS</code> 是PHP的一个超级全局变量组，在一个PHP脚本的全部作用域中都可以访问。<br>$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。</p><h3 id="REQUEST"><a href="#REQUEST" class="headerlink" title="$_REQUEST"></a>$_REQUEST</h3><p><code>$_REQUEST</code> 用于收集HTML表单提交的数据。<br>当用户通过点击 “Submit” 按钮提交表单数据时, 表单数据将发送至<form>标签中 action 属性中指定的脚本文件。</form></p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-comment">&lt;!-- $_SERVER[&#x27;PHP_SELF&#x27;] 获取 当前执行脚本的文件名 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;</span></span></span><span class="php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">echo</span> <span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;PHP_SELF&#x27;</span>];<span class="hljs-meta">?&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span> </span><br><span class="xml">Name: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fname&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><span class="xml"> </span><br><span class="php"><span class="hljs-meta">&lt;?php</span> </span><br><span class="php"><span class="hljs-variable">$name</span> = <span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;fname&#x27;</span>]; </span><br><span class="php"><span class="hljs-keyword">echo</span> <span class="hljs-variable">$name</span>; </span><br><span class="php"><span class="hljs-meta">?&gt;</span></span><br><span class="xml"> </span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><code>$_POST</code>、<code>$_GET</code>同样被广泛应用于收集表单数据。</p><h2 id="While-循环"><a href="#While-循环" class="headerlink" title="While 循环"></a>While 循环</h2><h2 id="For-循环"><a href="#For-循环" class="headerlink" title="For 循环"></a>For 循环</h2><h3 id="foreach-循环"><a href="#foreach-循环" class="headerlink" title="foreach 循环"></a>foreach 循环</h3><p>冒泡排序</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$arr</span> = <span class="hljs-keyword">array</span>(<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span>=count(<span class="hljs-variable">$arr</span>)<span class="hljs-number">-1</span>; <span class="hljs-variable">$i</span>&gt;=<span class="hljs-number">0</span>; <span class="hljs-variable">$i</span>--) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-variable">$j</span>= <span class="hljs-number">0</span>; <span class="hljs-variable">$j</span>&lt;<span class="hljs-variable">$i</span>; <span class="hljs-variable">$j</span>++) &#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$arr</span>[<span class="hljs-variable">$j</span>] &gt; <span class="hljs-variable">$arr</span>[<span class="hljs-variable">$j</span>+<span class="hljs-number">1</span>]) &#123;<br><span class="hljs-variable">$temp</span> = <span class="hljs-variable">$arr</span>[<span class="hljs-variable">$j</span>];<br><span class="hljs-variable">$arr</span>[<span class="hljs-variable">$j</span>] = <span class="hljs-variable">$arr</span>[<span class="hljs-variable">$j</span>+<span class="hljs-number">1</span>];<br><span class="hljs-variable">$arr</span>[<span class="hljs-variable">$j</span>+<span class="hljs-number">1</span>] = <span class="hljs-variable">$temp</span>;<br>&#125;<br>&#125;<br>&#125;<br>print_r(<span class="hljs-variable">$arr</span>[<span class="hljs-number">4</span>]);<br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params"><span class="hljs-variable">$x</span>, <span class="hljs-variable">$y</span></span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable">$x</span> + <span class="hljs-variable">$y</span>;<br>&#125;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;14 + 12 = &#x27;</span> . add(<span class="hljs-number">14</span>, <span class="hljs-number">12</span>);<br></code></pre></td></tr></table></figure><h2 id="魔法常量"><a href="#魔法常量" class="headerlink" title="魔法常量"></a>魔法常量</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;该文件位于 &quot; &#x27;</span>  . <span class="hljs-keyword">__FILE__</span> . <span class="hljs-string">&#x27; &quot; &lt;br&gt;&#x27;</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_print</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;类名为：&#x27;</span>  . <span class="hljs-keyword">__CLASS__</span> . <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;函数名为：&#x27;</span> . <span class="hljs-keyword">__FUNCTION__</span> ;<br>    &#125;<br>&#125;<br><span class="hljs-variable">$t</span> = <span class="hljs-keyword">new</span> test();<br><span class="hljs-variable">$t</span>-&gt;_print();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="命名空间-namespace"><a href="#命名空间-namespace" class="headerlink" title="命名空间(namespace)"></a>命名空间(namespace)</h2><p>PHP 命名空间可以解决以下两类问题：</p><ul><li>用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。</li><li>为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。</li></ul><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h1 id="PHP表单"><a href="#PHP表单" class="headerlink" title="PHP表单"></a>PHP表单</h1><h2 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h2><p><code>&lt;form method=&quot;post&quot; action=&quot;&lt;?php echo htmlspecialchars($_SERVER[&quot;PHP_SELF&quot;]);?&gt;&quot;&gt;</code><br><code>$_SERVER[&quot;PHP_SELF&quot;]</code>是超级全局变量，返回当前正在执行脚本的文件名，与 document root相关。所以，<code>$_SERVER[&quot;PHP_SELF&quot;]</code> 会发送表单数据到当前页面，而不是跳转到不同的页面。<br>htmlspecialchars() 函数把一些预定义的字符转换为 HTML 实体。<br>预定义的字符是：</p><ul><li>&amp; （和号） 成为 &amp;</li><li>“ （双引号） 成为 &quot;</li><li>‘ （单引号） 成为 &#039;</li><li>&lt; （小于） 成为 &lt;</li><li>&gt; （大于） 成为 &gt;</li></ul><p><code>$_SERVER[&quot;PHP_SELF&quot;]</code> 变量有可能会被黑客使用！可以通过 htmlspecialchars() 函数来避免被利用。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// 定义变量并默认设置为空值</span><br><span class="hljs-variable">$name</span> = <span class="hljs-variable">$email</span> = <span class="hljs-variable">$gender</span> = <span class="hljs-variable">$comment</span> = <span class="hljs-variable">$website</span> = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-comment">// 通过$_SERVER[&quot;REQUEST_METHOD&quot;]来检测表单是否被提交</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&quot;REQUEST_METHOD&quot;</span>] == <span class="hljs-string">&quot;POST&quot;</span>)<br>&#123;<br>   <span class="hljs-variable">$name</span> = test_input(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;name&quot;</span>]);<br>   <span class="hljs-variable">$gender</span> = test_input(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;gender&quot;</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test_input</span>(<span class="hljs-params"><span class="hljs-variable">$data</span></span>)</span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-variable">$data</span> = trim(<span class="hljs-variable">$data</span>);  <span class="hljs-comment">// 去除用户输入数据中不必要的字符 (如：空格，tab，换行)。</span><br>   <span class="hljs-variable">$data</span> = stripslashes(<span class="hljs-variable">$data</span>);  <span class="hljs-comment">// 去除用户输入数据中的反斜杠 (\)</span><br>   <span class="hljs-variable">$data</span> = htmlspecialchars(<span class="hljs-variable">$data</span>);  <span class="hljs-comment">// 把一些预定义的字符转换为 HTML 实体。</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-variable">$data</span>;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="必须字段"><a href="#必须字段" class="headerlink" title="必须字段"></a>必须字段</h2><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="php"><span class="hljs-meta">&lt;?php</span></span><br><span class="php"><span class="hljs-comment">// 定义变量并默认设为空值</span></span><br><span class="php"><span class="hljs-variable">$nameErr</span> = <span class="hljs-variable">$name</span> = <span class="hljs-string">&quot;&quot;</span>;</span><br><span class="php"><span class="hljs-keyword">if</span> (<span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&quot;REQUEST_METHOD&quot;</span>] == <span class="hljs-string">&quot;POST&quot;</span>) &#123;</span><br><span class="php">  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;name&quot;</span>])) &#123;</span><br><span class="php">    <span class="hljs-variable">$nameErr</span> = <span class="hljs-string">&quot;名字是必需的。&quot;</span>;</span><br><span class="php">  &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="php">    <span class="hljs-variable">$name</span> = test_input(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;name&quot;</span>]);</span><br><span class="php">  &#125;</span><br><span class="php">&#125;</span><br><span class="php"><span class="hljs-meta">?&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;</span></span></span><span class="php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">echo</span> htmlspecialchars(<span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;PHP_SELF&#x27;</span>]);<span class="hljs-meta">?&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span> </span><br><span class="xml">   名字: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span></span><br><span class="xml">   <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;error&quot;</span>&gt;</span>* </span><span class="php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">echo</span> <span class="hljs-variable">$nameErr</span>;<span class="hljs-meta">?&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit&quot;</span>&gt;</span> </span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="验证邮件和URL"><a href="#验证邮件和URL" class="headerlink" title="验证邮件和URL"></a>验证邮件和URL</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">if</span> (empty(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;name&quot;</span>])) &#123;<br>  <span class="hljs-variable">$nameErr</span> = <span class="hljs-string">&quot;Name is required&quot;</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br> <span class="hljs-variable">$name</span> = test_input(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;name&quot;</span>]);<br> <span class="hljs-regexp">//</span> 检测名字是否只包含字母跟空格<br> <span class="hljs-keyword">if</span> (!preg_match(<span class="hljs-string">&quot;/^[a-zA-Z ]*$/&quot;</span>,<span class="hljs-variable">$name</span>)) &#123;<br> <span class="hljs-variable">$nameErr</span> = <span class="hljs-string">&quot;只允许字母和空格&quot;</span>; <br> &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="GET-变量"><a href="#GET-变量" class="headerlink" title="$_GET 变量"></a>$_GET 变量</h2><p>预定义的<code>$_GET</code> 变量用于收集来自 <code>method=&quot;get&quot;</code>的表单中的值。</p><p>从带有 GET 方法的表单发送的信息，对任何人都是可见的（会显示在浏览器的地址栏），并且对发送信息的量也有限制。</p><h2 id="POST-变量"><a href="#POST-变量" class="headerlink" title="$_POST 变量"></a>$_POST 变量</h2><p>预定义的 <code>$_POST</code> 变量用于收集来自 <code>method=&quot;post&quot;</code>的表单中的值。</p><p>从带有 POST 方法的表单发送的信息，对任何人都是不可见的（不会显示在浏览器的地址栏），并且对发送信息的量也没有限制。</p><h1 id="PHP高级教程"><a href="#PHP高级教程" class="headerlink" title="PHP高级教程"></a>PHP高级教程</h1><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs smali">$sites = array<br>(<br>    array(<span class="hljs-string">&quot;Volvo&quot;</span>,100,96),<br>    <span class="hljs-string">&quot;taobao&quot;</span>=&gt;array<br>    (<br>        <span class="hljs-string">&quot;淘宝&quot;</span>,<br>        <span class="hljs-string">&quot;http://www.taobao.com&quot;</span><br>    )<br>);<br></code></pre></td></tr></table></figure><h2 id="date-函数"><a href="#date-函数" class="headerlink" title="date() 函数"></a>date() 函数</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>date_default_timezone_set(<span class="hljs-string">&#x27;PRC&#x27;</span>); <br><span class="hljs-keyword">echo</span> date(<span class="hljs-string">&quot;Y/m/d&quot;</span>) . <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br><span class="hljs-keyword">echo</span> date(<span class="hljs-string">&quot;Y.m.d&quot;</span>) . <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br><span class="hljs-keyword">echo</span> date(<span class="hljs-string">&quot;Y-m-d H:i:s&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="包含文件"><a href="#包含文件" class="headerlink" title="包含文件"></a>包含文件</h2><p>include 和 require 语句用于在执行流中插入写在其他文件中的有用的代码。<br>处理错误方式不同：</p><ul><li>require 生成一个致命错误（E_COMPILE_ERROR），在错误发生后脚本会停止执行。</li><li>include 生成一个警告（E_WARNING），在错误发生后脚本会继续执行。<br><code>&lt;?php include &#39;header.php&#39;; ?&gt;</code></li></ul><h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><p>fopen()、fclose()、feof()</p><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>允许用户上传文件是一个巨大的安全风险。请仅仅允许可信的用户执行文件上传操作。<br><a href="https://www.cnblogs.com/54chensongxia/p/11662252.html#2409458956">https://www.cnblogs.com/54chensongxia/p/11662252.html#2409458956</a></p><h3 id="上传限制"><a href="#上传限制" class="headerlink" title="上传限制"></a>上传限制</h3><p>用户只能上传 .gif、.jpeg、.jpg、.png 文件，文件大小必须小于 200 kB</p><h3 id="保存被上传的文件"><a href="#保存被上传的文件" class="headerlink" title="保存被上传的文件"></a>保存被上传的文件</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// 允许上传的图片后缀</span><br><span class="hljs-variable">$allowedExts</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;gif&quot;</span>, <span class="hljs-string">&quot;jpeg&quot;</span>, <span class="hljs-string">&quot;jpg&quot;</span>, <span class="hljs-string">&quot;png&quot;</span>);<br><span class="hljs-variable">$temp</span> = explode(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;name&quot;</span>]);<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;size&quot;</span>];<br><span class="hljs-variable">$extension</span> = end(<span class="hljs-variable">$temp</span>);     <span class="hljs-comment">// 获取文件后缀名</span><br><span class="hljs-keyword">if</span> (((<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;image/gif&quot;</span>)<br>|| (<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;image/jpeg&quot;</span>)<br>|| (<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;image/jpg&quot;</span>)<br>|| (<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;image/pjpeg&quot;</span>)<br>|| (<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;image/x-png&quot;</span>)<br>|| (<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;image/png&quot;</span>))<br>&amp;&amp; (<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;size&quot;</span>] &lt; <span class="hljs-number">204800</span>)   <span class="hljs-comment">// 小于 200 kb</span><br>&amp;&amp; in_array(<span class="hljs-variable">$extension</span>, <span class="hljs-variable">$allowedExts</span>))<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;error&quot;</span>] &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;错误：: &quot;</span> . <span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;error&quot;</span>] . <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;上传文件名: &quot;</span> . <span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;name&quot;</span>] . <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;文件类型: &quot;</span> . <span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;type&quot;</span>] . <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;文件大小: &quot;</span> . (<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;size&quot;</span>] / <span class="hljs-number">1024</span>) . <span class="hljs-string">&quot; kB&lt;br&gt;&quot;</span>;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;文件临时存储的位置: &quot;</span> . <span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;tmp_name&quot;</span>] . <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br>        <br>        <span class="hljs-comment">// 判断当期目录下的 upload 目录是否存在该文件</span><br>        <span class="hljs-comment">// 如果没有 upload 目录，你需要创建它，upload 目录权限为 777</span><br>        <span class="hljs-keyword">if</span> (file_exists(<span class="hljs-string">&quot;upload/&quot;</span> . <span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;name&quot;</span>]))<br>        &#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;name&quot;</span>] . <span class="hljs-string">&quot; 文件已经存在。 &quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// 如果 upload 目录不存在该文件则将文件上传到 upload 目录下</span><br>            move_uploaded_file(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;tmp_name&quot;</span>], <span class="hljs-string">&quot;upload/&quot;</span> . <span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;name&quot;</span>]);<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;文件存储在: &quot;</span> . <span class="hljs-string">&quot;upload/&quot;</span> . <span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;name&quot;</span>];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;非法的文件格式&quot;</span>;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>cookie 常用于<strong>识别用户</strong>。cookie 是一种服务器留在用户计算机上的小文件。每当同一台计算机通过浏览器请求页面时，这台计算机将会发送 cookie。通过 PHP，您能够创建并取回 cookie 的值。</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>session 变量用于存储关于用户会话（session）的信息，或者更改用户会话（session）的设置。Session 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的。</p><h2 id="Email"><a href="#Email" class="headerlink" title="Email"></a>Email</h2><p>PHP 允许您从脚本直接发送电子邮件。</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>在 PHP 中，默认的错误处理很简单。一条错误消息会被发送到浏览器，这条消息带有文件名、行号以及描述错误的消息。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span>(!file_exists(<span class="hljs-string">&quot;welcome.txt&quot;</span>)) &#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;文件不存在&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable">$file</span>=fopen(<span class="hljs-string">&quot;welcome.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常用于在指定的错误发生时改变脚本的正常流程。</p><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>PHP 过滤器用于验证和过滤来自非安全来源的数据，比如用户的输入。</p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>json_encode: 对变量进行 JSON 编码<br>json_decode: 对 JSON 格式的字符串进行解码，转换为 PHP 变量</p><h1 id="PHP数据库"><a href="#PHP数据库" class="headerlink" title="PHP数据库"></a>PHP数据库</h1><h2 id="MySQL简介"><a href="#MySQL简介" class="headerlink" title="MySQL简介"></a>MySQL简介</h2><p>MySQL 是一种在 Web、服务器 上使用的数据库系统。</p><h2 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h2><h3 id="实例-MySQLi-面向对象"><a href="#实例-MySQLi-面向对象" class="headerlink" title="实例 (MySQLi - 面向对象)"></a>实例 (MySQLi - 面向对象)</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$servername</span> = <span class="hljs-string">&quot;localhost&quot;</span>;<br><span class="hljs-variable">$username</span> = <span class="hljs-string">&quot;username&quot;</span>;<br><span class="hljs-variable">$password</span> = <span class="hljs-string">&quot;password&quot;</span>;<br> <br><span class="hljs-comment">// 创建连接</span><br><span class="hljs-variable">$conn</span> = <span class="hljs-keyword">new</span> mysqli(<span class="hljs-variable">$servername</span>, <span class="hljs-variable">$username</span>, <span class="hljs-variable">$password</span>);<br> <br><span class="hljs-comment">// 检测连接</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$conn</span>-&gt;connect_error) &#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;连接失败: &quot;</span> . <span class="hljs-variable">$conn</span>-&gt;connect_error);<br>&#125; <br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;连接成功&quot;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 创建数据库</span><br><span class="hljs-variable">$sql</span> = <span class="hljs-string">&quot;CREATE DATABASE myDB&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$conn</span>-&gt;query(<span class="hljs-variable">$sql</span>) === <span class="hljs-literal">TRUE</span>) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;数据库创建成功&quot;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Error creating database: &quot;</span> . <span class="hljs-variable">$conn</span>-&gt;error;<br>&#125;<br> <br><span class="hljs-variable">$conn</span>-&gt;close();<br></code></pre></td></tr></table></figure><h2 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 使用 sql 创建数据表</span><br><span class="hljs-variable">$sql</span> = <span class="hljs-string">&quot;CREATE TABLE MyGuests (</span><br><span class="hljs-string">id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY, </span><br><span class="hljs-string">firstname VARCHAR(30) NOT NULL,</span><br><span class="hljs-string">lastname VARCHAR(30) NOT NULL,</span><br><span class="hljs-string">email VARCHAR(50),</span><br><span class="hljs-string">reg_date TIMESTAMP</span><br><span class="hljs-string">)&quot;</span>;<br> <br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$conn</span>-&gt;query(<span class="hljs-variable">$sql</span>) === <span class="hljs-literal">TRUE</span>) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Table MyGuests created successfully&quot;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;创建数据表错误: &quot;</span> . <span class="hljs-variable">$conn</span>-&gt;error;<br>&#125;<br> <br><span class="hljs-variable">$conn</span>-&gt;close();<br></code></pre></td></tr></table></figure><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>预处理语句对于防止 MySQL 注入是非常有用的。<br>预处理语句用于执行多个相同的 SQL 语句，并且执行效率更高。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$servername</span> = <span class="hljs-string">&quot;localhost&quot;</span>;<br><span class="hljs-variable">$username</span> = <span class="hljs-string">&quot;username&quot;</span>;<br><span class="hljs-variable">$password</span> = <span class="hljs-string">&quot;password&quot;</span>;<br><span class="hljs-variable">$dbname</span> = <span class="hljs-string">&quot;myDB&quot;</span>;<br> <br><span class="hljs-comment">// 创建连接</span><br><span class="hljs-variable">$conn</span> = <span class="hljs-keyword">new</span> mysqli(<span class="hljs-variable">$servername</span>, <span class="hljs-variable">$username</span>, <span class="hljs-variable">$password</span>, <span class="hljs-variable">$dbname</span>);<br> <br><span class="hljs-comment">// 检测连接</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$conn</span>-&gt;connect_error) &#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;连接失败: &quot;</span> . <span class="hljs-variable">$conn</span>-&gt;connect_error);<br>&#125;<br> <br><span class="hljs-comment">// 预处理及绑定</span><br><span class="hljs-variable">$stmt</span> = <span class="hljs-variable">$conn</span>-&gt;prepare(<span class="hljs-string">&quot;INSERT INTO MyGuests (firstname, lastname, email) VALUES (?, ?, ?)&quot;</span>);<br><span class="hljs-variable">$stmt</span>-&gt;bind_param(<span class="hljs-string">&quot;sss&quot;</span>, <span class="hljs-variable">$firstname</span>, <span class="hljs-variable">$lastname</span>, <span class="hljs-variable">$email</span>);<br> <br><span class="hljs-comment">// 设置参数并执行</span><br><span class="hljs-variable">$firstname</span> = <span class="hljs-string">&quot;John&quot;</span>;<br><span class="hljs-variable">$lastname</span> = <span class="hljs-string">&quot;Doe&quot;</span>;<br><span class="hljs-variable">$email</span> = <span class="hljs-string">&quot;john@example.com&quot;</span>;<br><span class="hljs-variable">$stmt</span>-&gt;execute();<br> <br><span class="hljs-variable">$firstname</span> = <span class="hljs-string">&quot;Julie&quot;</span>;<br><span class="hljs-variable">$lastname</span> = <span class="hljs-string">&quot;Dooley&quot;</span>;<br><span class="hljs-variable">$email</span> = <span class="hljs-string">&quot;julie@example.com&quot;</span>;<br><span class="hljs-variable">$stmt</span>-&gt;execute();<br> <br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;新记录插入成功&quot;</span>;<br> <br><span class="hljs-variable">$stmt</span>-&gt;close();<br><span class="hljs-variable">$conn</span>-&gt;close();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><code>$stmt-&gt;bind_param(&quot;sss&quot;, $firstname, $lastname, $email);</code><br>bind_param函数绑定了 SQL 的参数，且告诉数据库参数的值。 “sss” 参数列处理其余参数的数据类型。s 字符告诉数据库该参数为字符串。</p><p>参数有以下四种类型:</p><p>i - integer（整型）<br>d - double（双精度浮点型）<br>s - string（字符串）<br>b - BLOB（binary large object:二进制大对象）<br>每个参数都需要指定类型。通过告诉数据库参数的数据类型，可以降低 SQL 注入的风险。</p><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$servername</span> = <span class="hljs-string">&quot;localhost&quot;</span>;<br><span class="hljs-variable">$username</span> = <span class="hljs-string">&quot;username&quot;</span>;<br><span class="hljs-variable">$password</span> = <span class="hljs-string">&quot;password&quot;</span>;<br><span class="hljs-variable">$dbname</span> = <span class="hljs-string">&quot;myDB&quot;</span>;<br> <br><span class="hljs-comment">// 创建连接</span><br><span class="hljs-variable">$conn</span> = <span class="hljs-keyword">new</span> mysqli(<span class="hljs-variable">$servername</span>, <span class="hljs-variable">$username</span>, <span class="hljs-variable">$password</span>, <span class="hljs-variable">$dbname</span>);<br><span class="hljs-comment">// Check connection</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$conn</span>-&gt;connect_error) &#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;连接失败: &quot;</span> . <span class="hljs-variable">$conn</span>-&gt;connect_error);<br>&#125; <br> <br><span class="hljs-variable">$sql</span> = <span class="hljs-string">&quot;SELECT id, firstname, lastname FROM MyGuests&quot;</span>;<br><span class="hljs-variable">$result</span> = <span class="hljs-variable">$conn</span>-&gt;query(<span class="hljs-variable">$sql</span>);<br> <br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$result</span>-&gt;num_rows &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 输出数据</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-variable">$row</span> = <span class="hljs-variable">$result</span>-&gt;fetch_assoc()) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;id: &quot;</span> . <span class="hljs-variable">$row</span>[<span class="hljs-string">&quot;id&quot;</span>]. <span class="hljs-string">&quot; - Name: &quot;</span> . <span class="hljs-variable">$row</span>[<span class="hljs-string">&quot;firstname&quot;</span>]. <span class="hljs-string">&quot; &quot;</span> . <span class="hljs-variable">$row</span>[<span class="hljs-string">&quot;lastname&quot;</span>]. <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;0 结果&quot;</span>;<br>&#125;<br><span class="hljs-variable">$conn</span>-&gt;close();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>crontab定时任务</title>
    <link href="/2020/03/13/Linux/crontab%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <url>/2020/03/13/Linux/crontab%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>Linux的crond定时任务是周期性执行任务的守护进程。</p><a id="more"></a><ol><li><p>安装<br> <code>yum -y install crontab</code></p></li><li><p>启动crond服务<br> <code>service crond start</code><br> 查看状态<code>service crond status</code></p></li><li><p>使用<code>crontab -e</code>进行定时任务的编辑<br> 格式: <code>分 时 日 月 周 [用户] command</code><br> 这里我写入<code>0 * * * * /root/anaconda3/bin/python3 /root/*.py</code>, 表示每天每小时0分时自动执行<code>python3 /root/*.py</code>命令。<br> 注意: 设置好运行命令的<strong>绝对路径</strong>和被执行文件的<strong>绝对路径</strong>，因为crontab本身不具备平时运行的环境变量。</p></li><li><p>使用<code>crontab -l</code>查看设置好的定时任务</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux笔记</title>
    <link href="/2020/02/26/Linux/Linux/"/>
    <url>/2020/02/26/Linux/Linux/</url>
    
    <content type="html"><![CDATA[<p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p><a id="more"></a><p><code>[root@localhost ~]#</code>的含义</p><ol><li>用户名：root</li><li>主机名：localhost</li><li>当前路径：~当前用户的home目录</li><li>权限标志位：#代表root，$代表普通用户</li></ol><h2 id="vi操作"><a href="#vi操作" class="headerlink" title="vi操作"></a>vi操作</h2><ul><li>可以编辑文件 <code>vi &lt;file&gt;</code></li><li>插入内容 <code>p、P</code></li><li>复制 <code>[n]yy</code></li><li>删除行，删除词 <code>[n]dd、dw、x</code></li><li>撤销 <code>u</code></li><li>跳转某一行 <code>[n]G</code></li><li>跳转行的开头<code>0</code>、末尾<code>$</code></li><li>通过:/xxx进行搜索定位，n键查找下一项<br><code>vi /etc/hostname</code> 改主机名<br><code>:wq</code>   强制性写入文件并退出。即使文件没有被修改也强制写入，并更新文件的修改时间。<br><code>:x</code>    写入文件并退出。仅当文件被修改时才写入，并更新文件修改时间，否则不会更新文件修改时间。</li></ul><h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><p>文件和文件夹的创建删除<br><code>mkdir -p &lt;dir/subdir&gt;</code>  创建多级目录<br><code>rm -r &lt;file&gt;</code>   删除多级文件<br><code>mv &lt;old&gt; &lt;new&gt;</code>  移动和文件更名<br><code>pwd</code> 查看当前绝对路径<br><code>cp &lt;file&gt; &lt;file&gt;.bak</code>  复制、备份文件</p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><p>cat，more，less，grep，wc –l<br>cd - 返回上一次目录<br>more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读</p><p>文件的打包和解压： tar cvfz以及对应的tar xvfz<br>c ：创建一个新归档；x ： 从归档中抽取文件。<br>v ：显示文件的归档进度；z ：使用 gzip 来压缩 tar 文件。<br>f ：当与 -c 选项一起使用时，创建的 tar 文件使用该选项指定的文件名；当与 -x 选项<br>一起使用时，则解除该选项指定的归档。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ tar cvfz share.tar.gz <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/share/</span><br>$ tar xvfz share.tar.gz -C ./tmp<br></code></pre></td></tr></table></figure><p>打包指的是将多个文件和目录集中存储在一个文件中；<br>而压缩则指的是利用算法对文件进行处理，从而达到缩减占用磁盘空间的目的。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle">echo  <span class="hljs-comment">// 用于字符串的输出</span><br>ls -l f*  <span class="hljs-comment">// 查看虚拟机上以f开头的设备文件</span><br><span class="hljs-keyword">find</span> &lt;dir&gt; -name &lt;文件名&gt; <span class="hljs-number">2</span>&gt;<span class="hljs-regexp">/dev/</span><span class="hljs-keyword">null</span>  <span class="hljs-comment">// 查找文件</span><br><span class="hljs-keyword">grep</span> &lt;查找内容&gt; &lt;文件名&gt;  <span class="hljs-comment">// 搜索文件内容</span><br><span class="hljs-keyword">find</span> . | <span class="hljs-keyword">grep</span> passwd<br>ls | <span class="hljs-keyword">grep</span> *.txt<br>tail -n &lt;<span class="hljs-keyword">file</span>&gt;<span class="hljs-comment">// 查看某一文件后n行</span><br></code></pre></td></tr></table></figure><p>创建软链接<br><code>ln -s &lt;source&gt; &lt;target&gt;</code><br>如<code>ln -s /root/htdocs/cqcq/application/index/controller/ ~/controller</code><br>注意，删除软链接用<code>rm -rf ~/controller</code>，而不是<code>rm -rf ~/controller/</code></p><h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h3><p>Ubuntu用<code>apt-get</code>，Centos用<code>yum</code>。<br>加上<code>-y</code>遇到询问时自动yes。</p><h2 id="重定向和管道"><a href="#重定向和管道" class="headerlink" title="重定向和管道"></a>重定向和管道</h2><p>重定向的符号有两个：&gt;或&gt;&gt;。<br>两者的区别是：<br>前者会先清空文件，然后再写入内容；<br>后者会将重定向的内容追加到现有文件的尾部。</p><p>能够将任意命令的运行结果重定向到文件中。例如<code>ls –l &gt; tmp.txt</code></p><p><strong>管道</strong>：</p><ul><li>把一个程序的输出直接连接到另一个程序的输入。</li><li>通过管道将两个命令拼接起来。</li></ul><p>最典型的比如<code>ls –l | wc –l</code>计算数量。<br><code>cat &lt;file&gt; | wc -l</code>统计file的行数，file的内容输出连接到wc -l的输入。</p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>创建用户，修改用户密码</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe">sudo adduser &lt;<span class="hljs-keyword">new</span><span class="hljs-type">user</span>&gt;     <br>sudo passwd &lt;<span class="hljs-keyword">new</span><span class="hljs-type">user</span>&gt;<br></code></pre></td></tr></table></figure><p>su — Switch User<br>切换到指定用户，并且在该用户的家目录中创建文件，再退出这个用户。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">su newuser <br>touch &lt;file&gt;<br><span class="hljs-keyword">exit</span> <br></code></pre></td></tr></table></figure><p>用su来切换root用户和普通用户，注意切换用户后还在原来的路径上<br>改主机名：<code>hostnamectl set-hostname &lt;newname&gt;</code></p><p>可以使用chmod为文件增加可执行权限。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">chmod +x &lt;file&gt;  <span class="hljs-regexp">//</span> 加操作权限<br>chmod <span class="hljs-number">777</span> &lt;file&gt;  <span class="hljs-regexp">//</span> <span class="hljs-number">8</span>进制加满权限<br></code></pre></td></tr></table></figure><p><code>chown -R &lt;user&gt;:&lt;group&gt; *</code></p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>编译.c程序，并且将其放在后台进程运行。<br>ps命令用于显示当前进程 (process) 的状态。<br><code>ps -ef</code>   // 显示所有命令，连带命令行<br><code>kill &lt;id&gt;</code>  // 杀死进程<br>后台进程的启动是用户在输入命令行后加上“&amp;”字符，常用于进程耗时长、用户不着急得到结果的场合。<br>PPID：父进程的进程号。TTY：启动进程的终端号。<br>NI：nice的优先级。PRI：进程的优先级。<br>PRI -&gt; 进程的优先级，大部分系统都是数字越低优先级越高，进程就优先运行 。</p><p>在shell上启动了两个test_loop程序（使用<code>test_loop &amp;</code>），这两个程序都是shell（bash）“生”出来的，即属于shell的子进程。<br>BASH是SHELL的一种，是大多数LINUX发行版默认的SHELL。</p><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>Shell俗称壳（用来区别于内核），是指“提供使用者使用界面”的软件，就是一个<strong>命令行解释器</strong>。</p><p>定义简单变量并且打印，可以运行脚本。<br><code>chmod + x &lt;file.sh&gt;</code><br>If条件判断，字符串是否相等的比较</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">result=$(…)<br><span class="hljs-keyword">if</span> [ “<span class="hljs-variable">$result</span>” = “<span class="hljs-variable">$1</span>” ]; <span class="hljs-keyword">then</span><br><span class="hljs-keyword">elif</span> [ “” = “” ]; <span class="hljs-keyword">then</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>读入清单，批量创建清单上的文件目录</p><p>shell中，<br>== 可用于判断变量是否相等。<br>= 除了可用于判断变量是否相等外，还可以表示赋值。<br>= 与 == 在 [ ] 中表示判断(字符串比较)时是等价的。</p><h2 id="Linux目录"><a href="#Linux目录" class="headerlink" title="Linux目录"></a>Linux目录</h2><p>/boot：存放Linux内核、引导配置等<strong>启动</strong>文件。<br>/dev：存放硬盘、键盘、鼠标、光驱等各种<strong>设备</strong>文件。<br>/etc：存放各种<strong>配置</strong>文件、配置目录。<br>/home：存放普通用户的默认工作文件夹（即宿主目录、家目录）。<br>/var：存放日志文件、用户邮箱目录、进程运行数据等<strong>变化</strong>的文档。<br>/tmp：存放系统运行过程中使用的一些<strong>临时</strong>文件。</p><h2 id="QUESTION"><a href="#QUESTION" class="headerlink" title="QUESTION"></a>QUESTION</h2><ol><li><p>可执行文件前为什么要加<code>./</code>？<br>“./“表示当前目录下的可执行文件。<br>若要在任意目录下访问。</p><ol><li><code>chmod +x xx.sh</code>加上写权限。</li><li>在<code>~/.bashrc</code>中将当前目录加入到<code>export PATH=$PATH:</code>后。</li></ol></li><li><p>FTP是什么？<br>FTP就是文件传输协议。用于互联网双向传输，控制文件下载空间在服务器复制文件从本地计算机或本地上传文件复制到服务器上的空间。使用Xshell6中的Xftp6。</p></li><li><p>如何将静态页面部署到服务器上？<br>在服务器中安装<code>nginx</code>，使用<code>/etc/init.d/nginx start</code>启动，把<code>index.html</code>放在<code>/usr/share/nginx/html/</code>之下。</p></li><li><p><code>yum install</code>的<code>-y</code>参数是什么意思？<br>遇到询问时自动yes。</p></li><li><p>如何看自己的Linux服务器是多少位的？<br><code>getconf LONG_BIT</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo备份</title>
    <link href="/2020/02/18/Hexo/Hexo%E5%A4%87%E4%BB%BD/"/>
    <url>/2020/02/18/Hexo/Hexo%E5%A4%87%E4%BB%BD/</url>
    
    <content type="html"><![CDATA[<p><code>hexo d</code>只将编译后的文件<code>public</code>上传到gitee的<code>master</code>分支，因此我们新建一个分支<code>hexo</code>用于备份网站的源文件。</p><meta name="referrer" content="no-referrer"><a id="more"></a><p>最近把原本部署在GitHub上的hexo同时部署到码云上，速度快到飞起。<br>可做对比，我的<a href="https://hongchenglong.github.io">GitHub Pages</a>像乌龟一样慢吞吞，我的<a href="https://oeong.gitee.io">Gitee Pages</a>像兔子一样敏捷。</p><blockquote><p>使用hexo，如果换了电脑怎么更新博客？</p></blockquote><p>新建一个分支<strong>hexo</strong>用来存放Hexo生成的网站<strong>原始文件</strong>，而主分支<strong>master</strong>用来存放生成的<strong>静态网页</strong>，即<code>hexo d</code>编译后的文件。</p><p>我以操作码云为例。</p><ol><li>上传分支<br>新建一个hexo分支，点击<strong>管理</strong>，并设为<strong>默认</strong>分支。<br><img src="https://img2018.cnblogs.com/blog/1677222/202002/1677222-20200218154619708-1227810824.png" alt></li><li>克隆仓库到本地<br><code>git clone git@gitee.com:hongchenglong/Hongchenglong.git</code></li><li>将博客源文件全部复制过来，除了<code>.deploy_git</code>，因为<code>hexo d</code>上传部署到github的其实是hexo编译后的文件，是用来生成网页的，即<code>.deploy_git</code>里面的文件。<br>在<code>.gitignore</code>中加入以下文件，这些文件在别的电脑上需要重新输入命令安装 。<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">public</span><br>node_modules<br><span class="hljs-meta">.deploy_git</span><br><span class="hljs-meta">.DS_Store</span><br>Thumbs<span class="hljs-number">.</span><span class="hljs-built_in">db</span><br><span class="hljs-built_in">db</span><span class="hljs-number">.</span>json<br>*.log<br></code></pre></td></tr></table></figure>注意，如果之前克隆过theme中的主题文件，那么应该把主题文件中的<code>.git</code>文件夹删掉，因为<strong>git不能嵌套上传</strong>。</li><li>上传源文件到码云上 <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> .<br><span class="hljs-symbol">git</span> commit –m <span class="hljs-string">&quot;xxxx&quot;</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> <br></code></pre></td></tr></table></figure></li><li>发布博客<code>hexo g -d</code></li><li>最后手动更新部署<span style="color:red">master</span>分支</li></ol><p><img src="https://img2018.cnblogs.com/blog/1677222/202002/1677222-20200218161451693-906408523.png" alt></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>hexo d</code>只将编译后的文件<code>public</code>上传到gitee的<code>master</code>分支，因此我们新建一个分支<code>hexo</code>用于备份网站的源文件。</p><p>参考知乎回答：<a href="https://www.zhihu.com/question/21193762/answer/489124966">https://www.zhihu.com/question/21193762/answer/489124966</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo笔记</title>
    <link href="/2020/02/16/Hexo/Hexo/"/>
    <url>/2020/02/16/Hexo/Hexo/</url>
    
    <content type="html"><![CDATA[<p>Hexo is a fast, simple and powerful blog framework. You write posts in <a href="http://daringfireball.net/projects/markdown/">Markdown</a> (or other markup languages) and Hexo generates static files with a beautiful theme in seconds.</p><a id="more"></a><h2 id="如何上传文章"><a href="#如何上传文章" class="headerlink" title="如何上传文章"></a>如何上传文章</h2><p>在你博客站点文件夹下右键空白处，选择<code>Git Bash Here</code></p><ol><li><code>hexo new post &quot;&quot;</code>然后在<code>./source/_posts</code>里找到并编辑。</li><li><code>hexo g</code> (hexo generate)，用于生成静态文件</li><li><code>hexo s</code> (hexo server)，用于启动服务器，主要用来本地预览；完成后打开浏览器输入 <code>localhost:4000</code></li><li><code>hexo d</code> (hexo deploy)，用于将本地文件发布到github等git仓库上</li><li>2、4步简写 <code>hexo g -d</code></li><li><code>hexo clean &amp;&amp; hexo g -d</code></li></ol><h2 id="显示不出分类、标签问题"><a href="#显示不出分类、标签问题" class="headerlink" title="显示不出分类、标签问题"></a>显示不出分类、标签问题</h2><p>在<code>./source/tags/index.md</code>中添加<code>type: tags</code>字段。<br><code>categories</code>同理。<br>参考博客：<a href="https://blog.csdn.net/Wonz5130/article/details/84666519">https://blog.csdn.net/Wonz5130/article/details/84666519</a></p><h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><p>npm 出现 <code>operation not permitted, mkdir...</code>问题<br>解决办法：以管理员身份运行cmd输入<code>npm -v</code>，然后在git bash中就没问题了。</p><h2 id="主题加载不出"><a href="#主题加载不出" class="headerlink" title="主题加载不出"></a>主题加载不出</h2><p>我是因为配置文件url配错了，改成原有的配置就OK了。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">url:</span> http:<span class="hljs-comment">//yoursite.com</span><br><span class="hljs-symbol">root:</span> /<br></code></pre></td></tr></table></figure><h2 id="图片加载不出"><a href="#图片加载不出" class="headerlink" title="图片加载不出"></a>图片加载不出</h2><p>我是引用cnblog的图片链接，刚刚上传那会还能显示图片，过几天就发现图片加载不出。<br>解决方法：<br>在文章头部加上<code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;</code>，解决防盗链问题。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Hexo学习笔记</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">&lt;meta</span> <span class="hljs-string">name=&quot;referrer&quot;</span> <span class="hljs-string">content=&quot;no-referrer&quot;/&gt;</span><br></code></pre></td></tr></table></figure><p>参考博客：</p><ul><li><a href="https://qsh5.cn/595.html">https://qsh5.cn/595.html</a></li><li><a href="https://blog.csdn.net/mqdxiaoxiao/article/details/96770756">https://blog.csdn.net/mqdxiaoxiao/article/details/96770756</a></li></ul><h2 id="hexo同时部署到码云Gitee"><a href="#hexo同时部署到码云Gitee" class="headerlink" title="hexo同时部署到码云Gitee"></a>hexo同时部署到码云Gitee</h2><p>如何创建一个首页访问地址不带二级目录的 pages，如hongchenglong.gitee.io？<br><strong>需要建立一个与自己个性地址同名的项目</strong>，<br>我的<strong>个性地址</strong>就是<code>https://gitee.com/hongchenglong</code>里的<code>hongchenglong</code><br>参考码云帮助文档：<a href="http://git.mydoc.io/?t=154714&amp;tdsourcetag=s_pctim_aiomsg">http://git.mydoc.io/?t=154714&amp;tdsourcetag=s_pctim_aiomsg</a><br>码云的速度很快，缺点是每次部署都要去码云Pages手动<strong>更新</strong></p><h2 id="设置网站的图标Favicon"><a href="#设置网站的图标Favicon" class="headerlink" title="设置网站的图标Favicon"></a>设置网站的图标Favicon</h2><p><a href="https://www.jianshu.com/p/82c1d33420ba">https://www.jianshu.com/p/82c1d33420ba</a></p><h2 id="hexo在添加新文章的时候添加categories"><a href="#hexo在添加新文章的时候添加categories" class="headerlink" title="hexo在添加新文章的时候添加categories"></a>hexo在添加新文章的时候添加categories</h2><p>修改<code>/scaffolds/post.md</code>，这是文章模板</p><h2 id="绑定自定义域名"><a href="#绑定自定义域名" class="headerlink" title="绑定自定义域名"></a>绑定自定义域名</h2><p>在<code>/_config.yml</code>将<code>url: yoursite.com</code>修改为<code>url: http://hexo.oeong.com</code><br>并在域名控制台添加解析</p><table><thead><tr><th>主机记录</th><th>记录类型</th><th>记录值</th></tr></thead><tbody><tr><td>hexo</td><td>CNAME</td><td>hongchenglong.github.io</td></tr></tbody></table><h2 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h2><ol><li>语句含义<br><code>home: / || home</code>中的<code>|| home</code>表示会到自带库里找到home这个图标并展示。</li><li>改成中文<br>主目录下的配置文件<code>_config.yml</code>中修改language的值，改成<code>language: zh-CN</code></li><li>如果修改过文件内容，需要通过如下命令清除已经生成的静态文件，重新生成！<br><code>hexo clean</code></li><li>部署到Gitee上，每次修改都要去码云Pages手动<strong>更新</strong>master分支</li><li>初始化一个Hexo，<code>hexo init blog</code></li><li>多标签，<code>tags: [标签1,标签2,标签3]</code></li><li>写新博客前记得加上<code>&lt;!-- more --&gt;</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git笔记</title>
    <link href="/2020/02/02/%E5%B7%A5%E5%85%B7/Git/"/>
    <url>/2020/02/02/%E5%B7%A5%E5%85%B7/Git/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.</p><a id="more"></a><h1 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h1><p>Git是目前世界上最先进的<strong>分布式版本控制系统</strong>。由Linus使用C写成。</p><ul><li><p><a href="http://git-scm.com">http://git-scm.com</a></p></li><li><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的Git教程</a></p></li><li><p><a href="https://backlog.com/git-tutorial/cn/intro/intro1_1.html">猴子都能懂的GIT入门</a></p></li><li><p><a href="https://gitee.com/liaoxuefeng/learn-java/raw/master/teach/git-cheatsheet.pdf">Git Cheat Sheet</a></p><h2 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a>版本库</h2></li></ul><p>版本库又名仓库，英文名<strong>repository</strong>。<br>初始化一个Git仓库，使用<code>git init</code>命令。<br>添加文件到Git仓库，分两步：</p><ol><li>使用命令<code>git add</code>，注意，可反复多次使用，添加多个文件；</li><li>使用命令<code>git commit -m &quot;&lt;message&gt;&quot;</code>，完成。(-m后面输入的是本次提交的说明)</li></ol><p>注意：</p><ul><li>目录名尽量不使用中文。</li><li>强烈建议使用标准的UTF-8编码。</li><li>版本控制系统是没法跟踪Word文件的改动。</li><li><code>.git</code>目录是Git来跟踪管理版本库的，尽量不要去改动。</li></ul><h1 id="时光机回溯"><a href="#时光机回溯" class="headerlink" title="时光机回溯"></a>时光机回溯</h1><ul><li>要随时掌握工作区的状态，使用<code>git status</code>命令。</li><li>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</li><li><code>git diff</code>查看文件在工作目录与暂存区的差别。</li></ul><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><ul><li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard</code>。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li></ul><h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p>工作区（Working Directory）：在电脑里能看到的目录。<br>版本库（Repository）：隐藏目录<code>.git</code>。<br>其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><p><img src="https://img2018.cnblogs.com/blog/1677222/202002/1677222-20200214213914797-1652178625.png" alt="img"></p><p>文件往Git版本库里添加的时候，是分两步执行的：<br>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到<strong>暂存区</strong>；<br>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到<strong>当前分支</strong>。<br><strong>需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</strong></p><h2 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h2><p>为什么Git比其他版本控制系统设计得优秀，因为<strong>Git跟踪并管理的是修改</strong>，而非文件。<br>每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中。</p><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><ul><li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout --</code>。</li><li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD</code>，就回到了场景1，第二步按场景1操作。</li><li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，使用命令<code>git reset --hard</code>，不过前提是没有推送到远程库。</li></ul><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>想要在github上面删除，但又不想在本地删除</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git rm -r --cached &lt;<span class="hljs-keyword">file</span>&gt;  # --cached不会删除本地的<span class="hljs-keyword">file</span><br><span class="hljs-symbol">$</span> git commit -m <span class="hljs-string">&#x27;delete &lt;file&gt;&#x27;</span><br><span class="hljs-symbol">$</span> git push -u origin master<br></code></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><code>git checkout --</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</li><li>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</li></ul><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><p>本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p><ol><li>创建SSH Key。<code>$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></li><li>打开<code>git bash</code>，输入<code>cat ~/.ssh/id_rsa.pub</code>即可查看ssh公钥。</li><li>“Add SSH Key”，在Key文本框里粘贴id_rsa.pub文件的内容。</li></ol><h3 id="何谓公钥"><a href="#何谓公钥" class="headerlink" title="何谓公钥"></a>何谓公钥</h3><ol><li>很多服务器都是需要认证的，ssh认证是其中的一种。在客户端生成公钥，把生成的公钥添加到服务器，你以后连接服务器就不用每次都输入用户名和密码了。</li><li>很多git服务器都是用ssh认证方式，你需要把你生成的公钥发送给代码仓库管理员，让他给你添加到服务器上，你就可以通过ssh自由地拉取和提交代码了。</li></ol><h3 id="为什么GitHub需要SSH-Key呢？"><a href="#为什么GitHub需要SSH-Key呢？" class="headerlink" title="为什么GitHub需要SSH Key呢？"></a>为什么GitHub需要SSH Key呢？</h3><p>因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><ul><li>要关联一个远程库，使用命令<code>git remote add origin git@github.com:&lt;server-name&gt;/&lt;repo-name&gt;.git</code>；</li><li>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</li><li>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；(远程库的名字就是origin，这是Git默认的叫法)</li><li>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作。</li></ul><h2 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h2><ul><li>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。</li><li>Git支持多种协议，包括<code>https</code>，但通过<code>ssh</code>支持的原生<code>git</code>协议速度最快。</li></ul><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="创建于合并分支"><a href="#创建于合并分支" class="headerlink" title="创建于合并分支"></a>创建于合并分支</h2><p><img src="https://img2018.cnblogs.com/blog/1677222/202002/1677222-20200215032332010-1516736742.png" alt="img"></p><ul><li>查看分支：<code>git branch</code></li><li>创建分支：<code>git branch</code></li><li>切换分支：<code>git checkout</code>或者<code>git switch</code></li><li>创建+切换分支：<code>git checkout -b</code>或者<code>git switch -c</code></li><li>合并某分支到当前分支：<code>git merge</code></li><li>删除分支：<code>git branch -d</code></li><li>删除远程分支：<code>git push origin --delete</code></li></ul><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p><img src="https://img2018.cnblogs.com/blog/1677222/202002/1677222-20200215033101385-1093798650.png" alt="img"></p><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。<br>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。<br>用<code>git log --graph</code>命令可以看到分支合并图。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>本地代码<br>=======<br>远程仓库代码<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; commmit id<br></code></pre></td></tr></table></figure><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，==分割线上方是本地数据库的内容，下方是远程数据库的编辑内容。</p><h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><p><img src="https://img2018.cnblogs.com/blog/1677222/202002/1677222-20200215033530403-1782330777.png" alt="img"></p><p>Git分支十分强大，在团队开发中应该充分应用。<br>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p><h2 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h2><ul><li>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</li><li>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场；</li><li>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</li></ul><h2 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h2><ul><li>开发一个新feature，最好新建一个分支；</li><li>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D</code>强行删除。</li></ul><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。可以用<code>git branch</code>命令看看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch<br>* master<br></code></pre></td></tr></table></figure><p>现在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -b dev origin/dev<br></code></pre></td></tr></table></figure><p>因此，多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to origin/</code>。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><p><code>git diff a b</code>，基于a来看b有什么变化。如<code>-hello</code>，表示基于a分支，b少了<code>hello</code>。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>远程库信息，使用<code>git remote -v</code>；</li><li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li><li>从本地推送分支，使用<code>git push origin</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</li><li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li><li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li><li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li></ul><h2 id="Rebase-变基"><a href="#Rebase-变基" class="headerlink" title="Rebase(变基)"></a>Rebase(变基)</h2><ul><li><code>git rebase</code>操作可以把本地未push的分叉提交历史整理成直线；</li><li>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</li></ul><h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。<br>tag是一个让人容易记住的有意义的名字，如v1.0，它跟某个commit绑在一起。</p><h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><ul><li>命令<code>git tag</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</li><li>命令<code>git tag -a  -m &quot;blablabla...&quot;</code>可以指定标签信息；</li><li>命令<code>git tag</code>可以查看所有标签。</li></ul><h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2><ul><li>命令<code>git push origin</code>可以推送一个本地标签；</li><li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li><li>命令<code>git tag -d</code>可以删除一个本地标签；</li><li>命令<code>git push origin: refs/tags/</code>可以删除一个远程标签。</li></ul><h1 id="使用GitHub"><a href="#使用GitHub" class="headerlink" title="使用GitHub"></a>使用GitHub</h1><p>点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：<br><code>git clone git@github.com:/bootstrap.git</code><br>一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址<a href="mailto:git@github.com">git@github.com</a>:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。</p><p>当你提交一个 Pull Request 的时候，你做的事情是 请求（request） 另一个开发者（比如项目维护者）来 拉取（pull） 你仓库中的一个分支到他们的仓库。</p><p>你的仓库会被默认设置为<strong>源仓库</strong>（head fork），被询问指定源分支（compare）、目标仓库（base fork）和目标分支（base）。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>在GitHub上，可以任意Fork开源仓库；</li><li>自己拥有Fork后的仓库的读写权限；</li><li>可以推送pull request给官方仓库来贡献代码。</li></ul><h1 id="使用Gitee"><a href="#使用Gitee" class="headerlink" title="使用Gitee"></a>使用Gitee</h1><p>如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——Gitee（gitee.com）。<br>用<code>git remote -v</code>查看远程库信息。<br>由于远程库不能同名，要先删除已有的GitHub远程库。<code>git remote rm origin</code><br>再分别关联GitHub和Gitee：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote add github git@github.com:&lt;server-name&gt;/&lt;repo-name&gt;.git<br>$ git remote add gitee git@gitee.com:&lt;server-name&gt;/&lt;repo-name&gt;.git<br></code></pre></td></tr></table></figure><p>或修改远程仓库名:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote rename origin github<br></code></pre></td></tr></table></figure><p>之后推送，使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push github master<br>$ git push gitee master<br></code></pre></td></tr></table></figure><h1 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h1><p><code>$ git config --global color.ui true</code>让Git显示颜色</p><h2 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h2><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff">/*<br><span class="hljs-addition">!.gitignore</span><br></code></pre></td></tr></table></figure><p>忽略根目录下所有文件，除了<code>.gitignore</code></p><ul><li>忽略某些文件时，需要编写<code>.gitignore</code>；</li><li><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理！</li></ul><h2 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h2><p>用st表示status：<code>$ git config --global alias.st status</code><br>很多人都用co表示checkout，ci表示commit，br表示branch：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global alias.co checkout<br>$ git config --global alias.ci commit<br>$ git config --global alias.br branch<br></code></pre></td></tr></table></figure><p>配置一个git last，让其显示最后一次提交信息：<br><code>$ git config --global alias.last &#39;log -1&#39;</code><br><code>--global</code>参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</p><h1 id="QUESTION"><a href="#QUESTION" class="headerlink" title="QUESTION"></a>QUESTION</h1><p><a href="https://gitee.com/help/articles/4110#article-header0">Git的基本概念/常用命令及实例</a></p><p><a href="https://blog.csdn.net/qq1332479771/article/details/56087333">Git Fork后与源作者同步更新</a></p><p><a href="https://gitee.com/help/articles/4194">如何解决代码冲突</a></p><p><a href="https://blog.csdn.net/ShuSheng0007/article/details/80791849">实际项目中如何使用Git做分支管理</a></p><p><a href>git merge：删除我要保留的文件！</a><br>切换到dev分支时，删除master分支想保留的文件，需注意，修改master分支中的文件，以便与dev主干中的删除发生合并冲突。</p><p><span style="color:red">删除时，需注意<code>.gitignore</code>里写的文件</span>。</p><p><a href="https://www.jianshu.com/p/80542dc3164e">git diff 命令详解</a></p><p>github提交代码却没有显示绿格子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config user.email<br>$ git config --global user.email <span class="hljs-string">&quot;oeong@foxmail.com&quot;</span><br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/syzdev/article/details/119704690">github报错“remote: Support for password authentication was removed on August 13, 2021. Please use a p”</a></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/1998/09/29/hello-world/"/>
    <url>/1998/09/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
